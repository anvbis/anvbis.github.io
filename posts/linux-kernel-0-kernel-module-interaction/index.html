<!doctype html><html lang=en>
<head>
<title>Linux Kernel :: 0x00 :: Kernel Module Interaction :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="An introduction to kernel module interaction. Part one of a series of posts on Linux kernel exploitation techniques.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/>
<link rel=stylesheet href=https://anvbis.github.io/assets/style.css>
<link rel=stylesheet href=https://anvbis.github.io/assets/red.css>
<link rel=apple-touch-icon href=https://anvbis.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://anvbis.github.io/img/favicon/red.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Kernel :: 0x00 :: Kernel Module Interaction">
<meta property="og:description" content="An introduction to kernel module interaction. Part one of a series of posts on Linux kernel exploitation techniques.">
<meta property="og:url" content="https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://anvbis.github.io/img/favicon/red.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="Linux Kernel Exploitation">
<meta property="article:published_time" content="2022-01-19 00:00:00 +0000 UTC">
</head>
<body class=red>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
Anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/>Linux Kernel :: 0x00 :: Kernel Module Interaction</a></h1>
<div class=post-meta>
<span class=post-date>
2022-01-19
</span>
</div>
<span class=post-tags>
#<a href=https://anvbis.github.io/tags/linux/>linux</a>&nbsp;
#<a href=https://anvbis.github.io/tags/kernel/>kernel</a>&nbsp;
</span>
<div class=post-content><div>
<ol>
<li><a href=/posts/linux-kernel-0-kernel-module-interaction>Linux Kernel :: 0x00 :: Kernel Module Interaction</a></li>
<li><a href=/posts/linux-kernel-1-ret2usr>Linux Kernel :: 0x01 :: Return to User-space</a></li>
<li><a href=/posts/linux-kernel-2-bypassing-smep>Linux Kernel :: 0x02 :: Bypassing SMEP with CR4 Overwrite</a></li>
<li><a href=/posts/linux-kernel-3-bypassing-smap>Linux Kernel :: 0x03 :: Bypassing SMAP with Signal Handlers</a></li>
<li><a href=/posts/linux-kernel-4-bypassing-kpti>Linux Kernel :: 0x04 :: Bypassing KPTI</a></li>
<li><a href=/posts/linux-kernel-5-stack-pivot>Linux Kernel :: 0x05 :: Stack Pivot in the Kernel</a></li>
<li><a href=/posts/linux-kernel-6-modprobe-path-overwrite>Linux Kernel :: 0x06 :: Modprobe Path Overwrite</a></li>
<li><a href=/posts/linux-kernel-7-bypassing-kaslr>Linux Kernel :: 0x07 :: Bypassing KASLR</a></li>
<li><a href=/posts/linux-kernel-8-ret2dir>Linux Kernel :: 0x08 :: Return to Direct-mapped Memory</a></li>
</ol>
<h2 id=table-of-contents>Table of Contents<a href=#table-of-contents class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<ol>
<li><a href=#environment-setup>Environment Setup</a></li>
<li><a href=#debugging-in-the-kernel>Debugging in the Kernel</a></li>
<li><a href=#kernel-module-overview>Kernel Module Overview</a></li>
<li><a href=#compiling-kernel-modules>Compiling Kernel Modules</a></li>
<li><a href=#inserting-kernel-modules>Inserting Kernel Modules</a></li>
<li><a href=#interacting-with-file-based-operations>Interacting with File-based Operations</a></li>
<li><a href=#interacting-with-ioctl>Interacting with IOCTL</a></li>
</ol>
<h2 id=environment-setup>Environment Setup<a href=#environment-setup class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:</p>
<ul>
<li>Downloading and building specific Kernel versions.</li>
<li>Streamlining the kernel module build process.</li>
<li>Emulate specific kernel versions under the QEMU virtual machine.</li>
</ul>
<p>Installation is pretty simple, just clone the repository and run the build script.</p>
<pre><code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
</code></pre><p>You can optionally specify the kernel version you want to download and compile within the <code>build.sh</code> script. By default it should be Linux version 5.4.0.</p>
<pre><code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
</code></pre><p>Running the virtual machine is equally simple, it&rsquo;s as easy as executing the <code>launch.sh</code> script. Note that the target kernel version is specified within this script. After executing we can see we&rsquo;re dropped into a shell inside the virtual machine.</p>
<p>Note: by defauled pwnkernel launches the emulator without any kernel space protections (e.g. kpti, smap, smep, etc).</p>
<pre><code>~/pwnkernel $ ./launch.sh
</code></pre><pre><code>/ # id
uid=0(root) gid=0 
</code></pre><h2 id=debugging-in-the-kernel>Debugging in the Kernel<a href=#debugging-in-the-kernel class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>First launch the kernel virtual machine in a separate terminal window.</p>
<pre><code>~/pwnkernel $ ./launch.sh
</code></pre><p>Then we need to open <code>pwnkernel/linux-5.4/vmlinux</code> with GDB and we&rsquo;ll be able to debug the kernel as we see fit. This will allow us to resolve kernel symbols and view kernel memory.</p>
<pre><code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
</code></pre><p>By default the <code>launch.sh</code> script will run QEMU with a gdbserver instance on port <code>1234</code>. We can connect to this with the following command.</p>
<pre><code>pwndbg&gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
</code></pre><p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.</p>
<h2 id=kernel-module-overview>Kernel Module Overview<a href=#kernel-module-overview class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Below is a code snippet containing the core parts of a kernel module. These include <code>open</code>, <code>release</code>, <code>init_module</code>, and <code>cleanup_module</code> functions.</p>
<p>The <code>init_module</code> function is called when the module is inserted into the kernel. It will typically create an entry under &lsquo;/proc/&rsquo; or &lsquo;/dev/&rsquo; that the user can interact with.</p>
<p>The <code>cleanup_module</code> function is called when the kernel module is removed from the kernel. It will typically remove whatever entry it created within the <code>init_module</code> function logic.</p>
<p>The <code>open</code> function is called when the entry is opened for read/write operations. While the <code>release</code> function is called when that entry is closed.</p>
<p>The <code>read</code> and <code>write</code> functions are also important for interacting with the kernel module, but more on these later.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_read</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#75715e>// read from kernel space
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_write</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#75715e>// write to kernel space
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>challenge_open</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp)
{
    <span style=color:#75715e>// when kernel module is opened
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>challenge_release</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp)
{
    <span style=color:#75715e>// when kernel module is released
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_operations fops <span style=color:#f92672>=</span> {
    .read    <span style=color:#f92672>=</span> challenge_read,
    .write   <span style=color:#f92672>=</span> challenge_write,
    .open    <span style=color:#f92672>=</span> challenge_open,
    .release <span style=color:#f92672>=</span> challenge_release
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>// when the module is inserted into the kernel
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>// when the module is removed from the kernel
</span><span style=color:#75715e></span>}
</code></pre></div><p>One way to create a kernel module entry is to utilise the <code>register_chrdev</code> function. This will assign what is called a &lsquo;major number&rsquo; to the kernel module, allowing us to create a kernel module entry under the &lsquo;/dev/&rsquo; directory. The <code>unregister_chrdev</code> function is used to remove the kernel module entry.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    major_number <span style=color:#f92672>=</span> register_chrdev(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;challenge&#34;</span>, <span style=color:#f92672>&amp;</span>fops);

    <span style=color:#66d9ef>if</span> (major_number <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> major_number;

    printk(KERN_INFO <span style=color:#e6db74>&#34;create device with: &#39;mknod /dev/challenge c %d 0&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, major_number);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    unregister_chrdev(major_number, <span style=color:#e6db74>&#34;challenge&#34;</span>);
}
</code></pre></div><p>We can create an entry in the &lsquo;/dev/&rsquo; directory with the command below.</p>
<pre><code>/ # mknod /dev/&lt;module name&gt; c &lt;major number&gt; 0
</code></pre><p>An even simpler way to initialise a kernel module entry is via the <code>proc_create</code> function. It creates a kernel module entry under the &lsquo;/proc/&rsquo; directory. It does not require any further user input to set up. The <code>proc_remove</code> function is used to remove the kernel module entry.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> proc_dir_entry <span style=color:#f92672>*</span>proc_entry;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    proc_entry <span style=color:#f92672>=</span> proc_create(<span style=color:#e6db74>&#34;challenge&#34;</span>, <span style=color:#ae81ff>0666</span>, NULL, <span style=color:#f92672>&amp;</span>fops);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>if</span> (proc_entry) {
        proc_remove(proc_entry);
    }
}
</code></pre></div><p>While the <code>read</code> and <code>write</code> functions are often great for kernel module interaction, there is another utility that we can use if we need even greater control over our input, this being <code>ioctl</code>.</p>
<p>It takes two main arguments an <code>ioctl_num</code> and an <code>ioctl_param</code>, where the <code>ioctl_num</code> can be used (for example) to specify various tasks, and the <code>ioctl_param</code> can be used to provide something like a pointer to an array or struct.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>challenge_ioctl</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>filp, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ioctl_num, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ioctl_param)
{
    <span style=color:#75715e>// when interacted with via ioctl
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_operations fops <span style=color:#f92672>=</span> {
    .read           <span style=color:#f92672>=</span> challenge_read,
    .write          <span style=color:#f92672>=</span> challenge_write,
    .unlocked_ioctl <span style=color:#f92672>=</span> challenge_ioctl,
    .open           <span style=color:#f92672>=</span> challenge_open,
    .release        <span style=color:#f92672>=</span> challenge_release
};
</code></pre></div><h2 id=compiling-kernel-modules>Compiling Kernel Modules<a href=#compiling-kernel-modules class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>As mentioned before, pwnkernel makes the process of compiling new kernel modules very simple. Just move your kernel module source code to the &lsquo;src/&rsquo; directory within pwnkernel. Make sure you update the makefile within the same &lsquo;src/&rsquo; directory, as this is what is used to compile your kernel module.</p>
<p>See the below makefile for reference.</p>
<div class=collapsable-code>
<input id=1 type=checkbox>
<label for=1>
<span class=collapsable-code__language>makefile</span>
<span class=collapsable-code__title>Makefile</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-makefile><code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4

all: 
    echo $(OBJECTS)
    make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules

clean:
    make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
</code></pre>
</div>
<p>After updating the makefile, building a new kernel module is as simple as running the below commands.</p>
<pre><code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
</code></pre><h2 id=inserting-kernel-modules>Inserting Kernel Modules<a href=#inserting-kernel-modules class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Before you can interact with your freshly compiled kernel module, it needs to be inserted into the kernel itself. Below is a pre-written kernel module that will be used for the purposes of this exercise. Compile it and run the launch script to start.</p>
<p><a href=/files/linux-kernel/0/5/challenge.c>challenge.c</a></p>
<div class=collapsable-code>
<input id=2 type=checkbox checked>
<label for=2>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed&#34;);
    return 0;
}

static struct file_operations fops = {
    .read    = challenge_read,
    .write   = challenge_write,
    .open    = challenge_open,
    .release = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed&#34;);
}
</code></pre>
</div>
<p>Once we&rsquo;ve compiled the above and started the kernel virtual machine, it&rsquo;s as simple as running the <code>insmod</code> command to insert the kernel module. There are other commands to do this such as <code>modprobe</code>, which is better at resolving dependencies, but for this kernel module <code>insmod</code> is sufficient.</p>
<p>Running <code>dmesg</code> we can see that the <code>init_module</code> function was executed when we inserted the kernel module.</p>
<pre><code>/ # insmod ./challenge.ko
/ # dmesg
...
[    8.437878] challenge: loading out-of-tree module taints kernel.
[    8.445662] module '/proc/challenge' created
</code></pre><h2 id=interacting-with-file-based-operations>Interacting with File-based Operations<a href=#interacting-with-file-based-operations class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>The majority of user interaction with kernel modules is done via file-based operations. Once the kernel module entry has been opened, the module has function handlers for read and write operations. For the sake of simplicity, you can think of this as a kind of file-based socket.</p>
<p>Interaction is performed first by opening the module entry. When you read from that open file descriptor the kernel module&rsquo;s <code>read</code> handler is called. When you write to the open file descriptor the kernel module&rsquo;s <code>write</code> handler is called.</p>
<p>Below is a pre-written kernel module that can be used for this exercise.</p>
<p><a href=/files/linux-kernel/0/6/challenge.c>challenge.c</a></p>
<div class=collapsable-code>
<input id=3 type=checkbox checked>
<label for=3>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    char data[18] = &#34;Here&#39;s some data!&#34;;
    copy_to_user(buf, data, 18);

    return 0;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    char data[16];
    copy_from_user(data, buf, 16);

    printk(KERN_ALERT &#34;Message: &#39;%s&#39;.\n&#34;, data);

    return 0;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed&#34;);
    return 0;
}

static struct file_operations fops = {
    .read    = challenge_read,
    .write   = challenge_write,
    .open    = challenge_open,
    .release = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed&#34;);
}
</code></pre>
</div>
<p>The below proof-of-concept code will do a few things to demonstrate how read / write actions are handled within the kernel module:</p>
<ul>
<li>It will first open the module entry with read/write access.</li>
<li>Then it&rsquo;ll perform a read, reading from the kernel module (calling its <code>read</code> handler function).</li>
<li>Then it&rsquo;ll perform a write, writing to the kernel module (calling its &lsquo;write` handler function).</li>
<li>Finally it&rsquo;ll close the file descriptor.</li>
</ul>
<p><a href=/files/linux-kernel/0/6/exploit.c>exploit.c</a></p>
<div class=collapsable-code>
<input id=4 type=checkbox>
<label for=4>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>exploit.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char** argv)
{
    /* open the device */
    int fd = open(&#34;/proc/challenge&#34;, O_RDWR);
    assert(fd &gt; 0);

    /* perform a read */
    char output[32];
    read(fd, output, sizeof(char) * 32);
    puts(output);

    /* perform a write */
    char input[32] = &#34;Hello, World!&#34;;
    write(fd, input, sizeof(char) * 32); 

    /* close the device */
    close(fd);

    return 0;
}
</code></pre>
</div>
<pre><code>~/ $ gcc exploit.c -o exploit -static 
</code></pre><p>Let&rsquo;s start by inserting the kernel module and running our demonstration code. Running <code>dmesg</code> afterwards we can see the result of our read / write actions.</p>
<pre><code>/ # insmod ./challenge.ko
/ # ./exploit
Here's some data!
</code></pre><pre><code>/ # dmesg
...
[   12.547802] challenge: loading out-of-tree module taints kernel.
[   12.557454] module '/proc/challenge' created
[   18.904788] device '/proc/challenge' opened
[   18.909735] Message: 'Hello, World!'.
[   18.911169] device '/proc/challenge' closed
</code></pre><h2 id=interacting-with-ioctl>Interacting with IOCTL<a href=#interacting-with-ioctl class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>As mentioned before, ioctl can provide us with much greater control over the way we interact with the kernel. Below is an example kernel module that will perform different actions depending on the input provided.</p>
<p>Here is a pre-written kernel module that you can use for this exercise.</p>
<p><a href=/files/linux-kernel/0/7/challenge.c>challenge.c</a></p>
<div class=collapsable-code>
<input id=5 type=checkbox checked>
<label for=5>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

#define HELLO   _IO(&#39;p&#39;, 1)
#define GOODBYE _IO(&#39;p&#39;, 2)

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened\n&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed\n&#34;);
    return 0;
}

static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
    if (ioctl_num == HELLO) {
        printk(KERN_ALERT &#34;Hello, %s!\n&#34;, (char *)ioctl_param);
    }
    else if (ioctl_num == GOODBYE) {
        printk(KERN_ALERT &#34;Goodbye, %s!\n&#34;, (char *)ioctl_param);
    }

    return 0;
}

static struct file_operations fops = {
    .read           = challenge_read,
    .write          = challenge_write,
    .unlocked_ioctl = challenge_ioctl,
    .open           = challenge_open,
    .release        = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created\n&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed\n&#34;);
}
</code></pre>
</div>
<p>After compiling our kernel module we&rsquo;ll want to check the values of <code>HELLO</code> and <code>GOODBYE</code>, so we can send them to the module via ioctl. We can see that <code>HELLO = 0x7001</code> and <code>GOODBYE = 0x7002</code>.</p>
<pre><code>~/pwnkernel $ objdump -d src/challenge.ko -M intel
...
000000000000001e &lt;challenge_ioctl&gt;:
  1e:   41 54                   push   r12
  20:   48 c7 c7 00 00 00 00    mov    rdi,0x0
  27:   49 89 d4                mov    r12,rdx
  2a:   55                      push   rbp
  2b:   89 f5                   mov    ebp,esi
  2d:   e8 00 00 00 00          call   32 &lt;challenge_ioctl+0x14&gt;
  32:   81 fd 01 70 00 00       cmp    ebp,0x7001
  38:   75 11                   jne    4b &lt;challenge_ioctl+0x2d&gt;
  3a:   4c 89 e6                mov    rsi,r12
  3d:   48 c7 c7 00 00 00 00    mov    rdi,0x0
  44:   e8 00 00 00 00          call   49 &lt;challenge_ioctl+0x2b&gt;
  49:   eb 27                   jmp    72 &lt;challenge_ioctl+0x54&gt;
  4b:   81 fd 02 70 00 00       cmp    ebp,0x7002
  51:   75 11                   jne    64 &lt;challenge_ioctl+0x46&gt;
  53:   4c 89 e6                mov    rsi,r12
  56:   48 c7 c7 00 00 00 00    mov    rdi,0x0
  5d:   e8 00 00 00 00          call   62 &lt;challenge_ioctl+0x44&gt;
  62:   eb 0e                   jmp    72 &lt;challenge_ioctl+0x54&gt;
  64:   89 ee                   mov    esi,ebp
  66:   48 c7 c7 00 00 00 00    mov    rdi,0x0
  6d:   e8 00 00 00 00          call   72 &lt;challenge_ioctl+0x54&gt;
  72:   31 c0                   xor    eax,eax
  74:   5d                      pop    rbp
  75:   41 5c                   pop    r12
  77:   c3                      ret
...
</code></pre><p>Below is an example interaction with the above kernel module, it&rsquo;ll do several things:</p>
<ul>
<li>First it&rsquo;ll open the kernel module entry with read/write access.</li>
<li>Next it&rsquo;ll send the <code>ioctl_num</code> for the <code>HELLO</code> command, with a string pointer as the <code>ioctl_param</code>.</li>
<li>Next it&rsquo;ll send the <code>ioctl_num</code> for the <code>HELLO</code> command, with a string pointer as the <code>ioctl_param</code>.</li>
<li>Finally it&rsquo;ll close the file descriptor.</li>
</ul>
<p><a href=/files/linux-kernel/0/7/exploit.c>exploit.c</a></p>
<div class=collapsable-code>
<input id=6 type=checkbox>
<label for=6>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>exploit.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;

#define HELLO   0x7001
#define GOODBYE 0x7002

int main(int argc, char** argv)
{
    /* open the device */
    int fd = open(&#34;/proc/challenge&#34;, O_RDWR);
    assert(fd &gt; 0);

    /* interact with ioctl here */
    char name[7] = &#34;Anvbis&#34;;
    ioctl(fd, HELLO, name); 
    ioctl(fd, GOODBYE, name);

    /* close the device */
    close(fd);

    return 0;
}
</code></pre>
</div>
<pre><code>~/ $ gcc exploit.c -o exploit -static 
</code></pre><p>After running our exploit, and checking <code>dmesg</code>, we can see that the kernel printed &ldquo;Hello, Anvbis!&rdquo; and &ldquo;Goodbye, Anvbis!&rdquo; as per the instructions we sent it via ioctl.</p>
<pre><code>/ # insmod ./challenge.ko
/ # ./exploit
</code></pre><pre><code>/ # dmesg
...
[   12.187784] device '/proc/challenge' opened
[   12.188714] Hello, Anvbis!
[   12.189492] Goodbye, Anvbis!
[   12.189747] device '/proc/challenge' closed
</code></pre>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Anvbis &copy; 2022</span>
</div>
</div>
</footer>
<script src=https://anvbis.github.io/assets/main.js></script>
<script src=https://anvbis.github.io/assets/prism.js></script>
</div>
</body>
</html>