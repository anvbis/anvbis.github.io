<!doctype html><html lang=en>
<head>
<title>Linux Kernel :: 0x00 :: Kernel Module Interaction :: Anvbis</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="An introduction to Kernel module interaciton. Part one on a series of posts on Linux kernel exploitation techniques.">
<meta name=keywords content>
<meta name=robots content="noodp">
<link rel=canonical href=https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/>
<link rel=stylesheet href=https://anvbis.github.io/assets/style.css>
<link rel=stylesheet href=https://anvbis.github.io/assets/red.css>
<link rel=apple-touch-icon href=https://anvbis.github.io/img/apple-touch-icon-192x192.png>
<link rel="shortcut icon" href=https://anvbis.github.io/img/favicon/red.png>
<meta name=twitter:card content="summary">
<meta property="og:locale" content="en">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux Kernel :: 0x00 :: Kernel Module Interaction">
<meta property="og:description" content="An introduction to Kernel module interaciton. Part one on a series of posts on Linux kernel exploitation techniques.">
<meta property="og:url" content="https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/">
<meta property="og:site_name" content="Anvbis">
<meta property="og:image" content="https://anvbis.github.io/img/favicon/red.png">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="Linux Kernel Exploitation">
<meta property="article:published_time" content="2022-01-19 00:00:00 +0000 UTC">
</head>
<body class=red>
<div class="container center headings--one-size">
<header class=header>
<div class=header__inner>
<div class=header__logo>
<a href=/>
<div class=logo>
Anvbis
</div>
</a>
</div>
<div class=menu-trigger>menu</div>
</div>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/about>About</a></li>
<li><a href=/categories>Categories</a></li>
<li><a href=/posts>Posts</a></li>
</ul>
</nav>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>
<a href=https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/>Linux Kernel :: 0x00 :: Kernel Module Interaction</a></h1>
<div class=post-meta>
<span class=post-date>
2022-01-19
</span>
</div>
<span class=post-tags>
#<a href=https://anvbis.github.io/tags/linux/>linux</a>&nbsp;
#<a href=https://anvbis.github.io/tags/kernel/>kernel</a>&nbsp;
</span>
<div class=post-content><div>
<h2 id=environment-setup>Environment Setup<a href=#environment-setup class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>The easiest Kernel exploitation environment to set up (in my opinion) is <code>pwnkernel</code> developed by the guys over at &lsquo;pwn.college&rsquo;. It will allow us to easily compile different Kernels, in addition to streamlining building custom Kernel modules.</p>
<p>It also allows us to easily emulate the various Kernel versions we want to test via the QEMU virtual machine.</p>
<pre><code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
</code></pre><p>To download and build the Kernel version specified in <code>pwnkernel/build.sh</code> (in addition to compiling Kernel modules for testing - but more on that later) all we need to do is run the <code>build.sh</code> script itself.</p>
<pre><code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
</code></pre><p>We can run the kernel emulator by simply executing the <code>launch.sh</code> script - note that the target Kernel version is specified within this script. After execution we can see that we&rsquo;re dropped into a shell inside the QEMU virtual machine.</p>
<pre><code>~/pwnkernel $ ./launch.sh
</code></pre><pre><code>/ # id
uid=0(root) gid=0 
</code></pre><h2 id=debugging-in-the-kernel>Debugging in the Kernel<a href=#debugging-in-the-kernel class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>First launch the Kernel virtual machine in a separate terminal window.</p>
<pre><code>~/pwnkernel $ ./launch.sh
</code></pre><p>Then we need to open <code>pwnkernel/linux-5.4/vmlinux</code> in our debugger (in this case, <code>gdb</code>) - in order to resolve Kernel symbols and view Kernel code.</p>
<pre><code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &quot;show copying&quot; and &quot;show warranty&quot; for details.
This GDB was configured as &quot;x86_64-linux-gnu&quot;.
Type &quot;show configuration&quot; for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type &quot;help&quot;.
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
</code></pre><p>By default the <code>launch.sh</code> script will run QEMU with a gdbserver instance on port <code>1234</code>. We can connect to this via the following command.</p>
<pre><code>pwndbg&gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
</code></pre><p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.</p>
<h2 id=kernel-module-overview>Kernel Module Overview<a href=#kernel-module-overview class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<p>Below is a code snippet containing the core parts of any Kernel module. These include <code>open</code>, <code>release</code>, <code>init_module</code>, and <code>cleanup_module</code> functions.</p>
<p>The <code>init_module</code> function is called when the module is inserted into the Kernel - typically creates an entry under <code>/proc</code> or <code>/dev</code> that the user can interact with.</p>
<p>The <code>cleanup_module</code> function is called when the kernel module is removed from the kernel - typically will remove whatever entry it created within the <code>init_module</code> function logic.</p>
<p>The <code>open</code> function is called when the entry under <code>/proc</code> or <code>/dev</code> is opened for read/write operations. While the <code>release</code> function is called when that entry is closed.</p>
<p>The <code>read</code> and <code>write</code> functions are also important for interacting with the Kernel module, but more on these later.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_read</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#75715e>// read from kernel space
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> ssize_t <span style=color:#a6e22e>challenge_write</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buf, size_t len, loff_t <span style=color:#f92672>*</span>off)
{
    <span style=color:#75715e>// write to kernel space
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>challenge_open</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp)
{
    <span style=color:#75715e>// when kernel module is opened
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>challenge_release</span>(<span style=color:#66d9ef>struct</span> inode <span style=color:#f92672>*</span>inode, <span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>fp)
{
    <span style=color:#75715e>// when kernel module is released
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_operations fops <span style=color:#f92672>=</span> {
    .read    <span style=color:#f92672>=</span> challenge_read,
    .write   <span style=color:#f92672>=</span> challenge_write,
    .open    <span style=color:#f92672>=</span> challenge_open,
    .release <span style=color:#f92672>=</span> challenge_release
};

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>// when the module is inserted into the kernel
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#75715e>// when the module is removed from the kernel
</span><span style=color:#75715e></span>}
</code></pre></div><p>One way to create a Kernel module entry (so we can interact with it) is to use the <code>register_chrdev</code> function. This function will assign what is called a &lsquo;major number&rsquo; to the Kernel module and we can create an entry under the <code>/dev</code> directory for interaction with the module - using the command below.</p>
<p>The <code>unregister_chrdev</code> function is used to remove the module entry.</p>
<pre><code>/ # mknod /dev/&lt;module name&gt; c &lt;major number&gt; 0
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    major_number <span style=color:#f92672>=</span> register_chrdev(<span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;challenge&#34;</span>, <span style=color:#f92672>&amp;</span>fops);

    <span style=color:#66d9ef>if</span> (major_number <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
            <span style=color:#66d9ef>return</span> major_number;

    printk(KERN_INFO <span style=color:#e6db74>&#34;create device with: &#39;mknod /dev/challenge c %d 0&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, major_number);

    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    unregister_chrdev(major_number, <span style=color:#e6db74>&#34;challenge&#34;</span>);
}
</code></pre></div><p>An even simpler way (in my opinion) to initialise a Kernel module entry is via the <code>proc_create</code> function. It creates an entry under the <code>/proc</code> directory for interaction with the module. It does not require any further user input to set up.</p>
<p>The <code>proc_remove</code> function is used to remove the module entry.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>struct</span> proc_dir_entry <span style=color:#f92672>*</span>proc_entry;

<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>init_module</span>(<span style=color:#66d9ef>void</span>)
{
    proc_entry <span style=color:#f92672>=</span> proc_create(<span style=color:#e6db74>&#34;challenge&#34;</span>, <span style=color:#ae81ff>0666</span>, NULL, <span style=color:#f92672>&amp;</span>fops);
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}

<span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cleanup_module</span>(<span style=color:#66d9ef>void</span>)
{
    <span style=color:#66d9ef>if</span> (proc_entry) {
        proc_remove(proc_entry);
    }
}
</code></pre></div><p>While the <code>read</code> and <code>write</code> functions are often great for interacting with the module, there is another utility that we can use if we need even greater control over our input. This is <code>ioctl</code>, which takes two main arguments an <code>ioctl_num</code> and an <code>ioctl_param</code>, where the <code>ioctl_num</code> can be used (for example) to specify various tasks, and the <code>ioctl_param</code> can be used to provide a pointer to an array or struct.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>challenge_ioctl</span>(<span style=color:#66d9ef>struct</span> file <span style=color:#f92672>*</span>filp, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> ioctl_num, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> ioctl_param)
{
    <span style=color:#75715e>// when interacted with via ioctl
</span><span style=color:#75715e></span>}

<span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> file_operations fops <span style=color:#f92672>=</span> {
    .read           <span style=color:#f92672>=</span> challenge_read,
    .write          <span style=color:#f92672>=</span> challenge_write,
    .unlocked_ioctl <span style=color:#f92672>=</span> challenge_ioctl,
    .open           <span style=color:#f92672>=</span> challenge_open,
    .release        <span style=color:#f92672>=</span> challenge_release
};
</code></pre></div><h2 id=compiling-kernel-modules>Compiling Kernel Modules<a href=#compiling-kernel-modules class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<div class=collapsable-code>
<input id=1 type=checkbox>
<label for=1>
<span class=collapsable-code__language>makefile</span>
<span class=collapsable-code__title>Makefile</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-makefile><code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4

all: 
    echo $(OBJECTS)
    make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules

clean:
    make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
</code></pre>
</div>
<pre><code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
</code></pre><h2 id=inserting-kernel-modules>Inserting Kernel Modules<a href=#inserting-kernel-modules class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<div class=collapsable-code>
<input id=2 type=checkbox checked>
<label for=2>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed&#34;);
    return 0;
}

static struct file_operations fops = {
    .read    = challenge_read,
    .write   = challenge_write,
    .open    = challenge_open,
    .release = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed&#34;);
}
</code></pre>
</div>
<pre><code>/ # insmod ./challenge.ko
/ # dmesg
...
</code></pre><h2 id=reading--writing-to-modules>Reading / Writing to Modules<a href=#reading--writing-to-modules class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<div class=collapsable-code>
<input id=3 type=checkbox checked>
<label for=3>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    // read logic
    return 0;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    // write logic
    return 0;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed&#34;);
    return 0;
}

static struct file_operations fops = {
    .read    = challenge_read,
    .write   = challenge_write,
    .open    = challenge_open,
    .release = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed&#34;);
}
</code></pre>
</div>
<div class=collapsable-code>
<input id=4 type=checkbox checked>
<label for=4>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>exploit.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char** argv)
{
    /* open the device */
    int fd = open(&#34;/proc/challenge&#34;, O_RDWR);
    assert(fd &gt; 0);

    /* perform a read */
    char output[32];
    read(fd, output, sizeof(char) * 32);

    /* perform a write */
    char input[32] = &#34;Hello, World!\n&#34;;
    write(fd, input, sizeof(char) * 32); 

    /* close the device */
    close(fd);

    return 0;
}
</code></pre>
</div>
<pre><code>/ # insmod ./challenge.ko
/ # ./exploit
...

/ # dmesg
...
</code></pre><h2 id=interacting-with-ioctl>Interacting with IOCTL<a href=#interacting-with-ioctl class=hanchor arialabel=Anchor>&#8983;</a> </h2>
<div class=collapsable-code>
<input id=5 type=checkbox checked>
<label for=5>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>challenge.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

MODULE_LICENSE(&#34;GPL&#34;);

struct proc_dir_entry *proc_entry;

static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
    return -EINVAL;
}

static int challenge_open(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; opened&#34;);
    return 0;
}

static int challenge_release(struct inode *inode, struct file *fp)
{
    printk(KERN_ALERT &#34;device &#39;/proc/challenge&#39; closed&#34;);
    return 0;
}

static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
    // ioctl logic
    return 0;
}

static struct file_operations fops = {
    .read           = challenge_read,
    .write          = challenge_write,
    .unlocked_ioctl = challenge_ioctl,
    .open           = challenge_open,
    .release        = challenge_release
};

int init_module(void)
{
    proc_entry = proc_create(&#34;challenge&#34;, 0666, NULL, &amp;fops);
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; created&#34;);

    return 0;
}

void cleanup_module(void)
{
    if (proc_entry) {
        proc_remove(proc_entry);
    }
    printk(KERN_ALERT &#34;module &#39;/proc/challenge&#39; removed&#34;);
}
</code></pre>
</div>
<div class=collapsable-code>
<input id=6 type=checkbox checked>
<label for=6>
<span class=collapsable-code__language>c</span>
<span class=collapsable-code__title>exploit.c</span>
<span class=collapsable-code__toggle data-label-expand=Show data-label-collapse=Hide></span>
</label>
<pre class=language-c><code>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/ioctl.h&gt;

int main(int argc, char** argv)
{
    /* open the device */
    int fd = open(&#34;/proc/challenge&#34;, O_RDWR);
    assert(fd &gt; 0);

    /* interact with ioctl here */

    /* close the device */
    close(fd);

    return 0;
}
</code></pre>
</div>
<pre><code>/ # insmod ./challenge.ko
/ # ./exploit
...

/ # dmesg
...
</code></pre>
</div></div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user">
<span>Anvbis &copy; 2022</span>
</div>
</div>
</footer>
<script src=https://anvbis.github.io/assets/main.js></script>
<script src=https://anvbis.github.io/assets/prism.js></script>
</div>
</body>
</html>