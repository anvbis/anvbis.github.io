<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Anubis</title><link>https://anvbis.github.io/categories/linux/</link><description>Recent content in Linux on Anubis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Fri, 10 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel :: Ret2usr</title><link>https://anvbis.github.io/posts/linux-kernel-ret2usr/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-ret2usr/</guid><description>Environment Setup ~/ $ git clone https://github.com/pwncollege/pwnkernel.git Cloning into 'pwnkernel'... remote: Enumerating objects: 115, done. remote: Counting objects: 100% (115/115), done. remote: Compressing objects: 100% (73/73), done. remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0 Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done. Resolving deltas: 100% (59/59), done. ~/ $ cd pwnkernel/ ~/pwnkernel $ ./build.sh ... #!/bin/bash # build root fs pushd fs find .</description></item><item><title>Linux Kernel :: SMEP Bypass</title><link>https://anvbis.github.io/posts/linux-kernel-smep-bypass/</link><pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-smep-bypass/</guid><description>Environment Setup #!/bin/bash # build root fs pushd fs find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; ../initramfs.cpio.gz popd # launch /usr/bin/qemu-system-x86_64 \ -kernel linux-5.4/arch/x86/boot/bzImage \ -initrd $PWD/initramfs.cpio.gz \ -fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \ -device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \ -nographic \ -monitor none \ -s \ -cpu kvm64,+smep \ -append &amp;#34;console=ttyS0 nokaslr quiet&amp;#34; ~/pwnkernel $ ./launch.sh Practice Kernel Module #include &amp;lt;linux/kernel.</description></item><item><title>DUCTF 2020 :: Return to What's Revenge</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</guid><description>Reverse Engineering Running file tells us that the target binary is a 64-bit dynamically linked linux executable.
$ file ./return-to-whats-revenge ./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped We can run pwntools' checksec tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.</description></item><item><title>DUCTF 2020 :: Return to What</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-what/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-what/</guid><description>Reverse Engineering We&amp;rsquo;ll start by running file to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.
$ file return-to-what return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped Running pwntools' checksec tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.</description></item><item><title>CSAW 2019 :: Smallboi</title><link>https://anvbis.github.io/posts/csaw-2019-smallboi/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-smallboi/</guid><description>Reverse Engineering Like usual, we&amp;rsquo;ll start by running file to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.
$ ./small_boi ./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped Running checksec reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.</description></item><item><title>CSAW 2019 :: Babyboi</title><link>https://anvbis.github.io/posts/csaw-2019-babyboi/</link><pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-babyboi/</guid><description>Reverse Engineering Let&amp;rsquo;s use the file command to get a little bit of insight into this executable. Note that it is a 64-bit linux binary.
$ file ./baby_boi baby_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=e1ff55dce2efc89340b86a666bba5e7ff2b37f62, not stripped We can also use pwntools' checksec tool to see what exploit protections it has in place. Note that the NX bit is set, but there is no stack canary, and PIE is disabled.</description></item><item><title>X-CTF 2016 :: B0verflow</title><link>https://anvbis.github.io/posts/xctf-2016-b0verflow/</link><pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/xctf-2016-b0verflow/</guid><description>Reverse Engineering Let&amp;rsquo;s begin by using the file command to get a little insight into this executable. Note that it is a 32-bit linux binary.
$ file ./b0verflow ./b0verflow: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=9f2d9dc0c9cc531c9656e6e84359398dd765b684, not stripped We can also use checksec to get an overview of what exploit protections it has. Note that there is no stack canary and the NX bit is not set, so it is likely vulnerable to a classic stack overflow.</description></item><item><title>ROP Emporium :: Ret2csu</title><link>https://anvbis.github.io/posts/rop-emporium-ret2csu/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/rop-emporium-ret2csu/</guid><description>Reverse Engineering Let&amp;rsquo;s run the file command to get a brief overview of the binary. Note that it is a 64-bit linux executable.
$ file ./ret2csu ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped We can also run checksec against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection.</description></item><item><title>TuCTF 2018 :: Shella Easy</title><link>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</guid><description>Reverse Engineering From the file command we can see that it is a dynamically linked linux executable.
$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped Running checksec on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</description></item></channel></rss>